<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="ja" xml:lang="ja" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Extensible Markup Language (XML) 1.1 (第二版)</title>
<style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

/* Modified by Hiroaki Hasegawa at 2007-04-29T18:24:06+09:00, to make it more legible in Japanese */
em.rfc2119 {
	text-transform: lowercase;
	font-variant: small-caps;
	font-style: italic;	/* Otherwise the keywords seem not to be significant */
}
/* Added by Hiroaki Hasegawa at 2007-04-29T18:24:06+09:00 */
p.original em.rfc2119 {
	text-transform: lowercase;
	font-variant: small-caps;
	font-style: normal;
}
</style>
<link rel="stylesheet" type="text/css" title="原文付き" media="all" href="../../stylesheet/W3C-REC-translated.css" />
<link rel="alternate stylesheet" type="text/css" title="原文無し" media="all" href="../../stylesheet/W3C-REC-translated.css" />
<link rel="alternate stylesheet" type="text/css" title="原文無し" media="all" href="../../stylesheet/W3C-REC-translated-hide-original.css" />
</head>

<body>

<div class="head">

<div class="annotation-header">
	<div class="stratum"><a href="http://www.eplusx.net">eplusx.net</a> &gt; Extensible Markup Language (XML) 1.1 (第二版)</div>
	<dl>
		<dt><strong>重要な注意事項</strong></dt>
		<dd>
			<ul>
				<li><strong>この文書のオリジナル版はW3C勧告文書<a href="http://www.w3.org/TR/2006/REC-xml11-20060816">Extensible Markup Language (XML) 1.1 (Second Edition)</a>です</strong>。オリジナル版の著作権は<a href="http://www.w3.org/">W3C</a>が保持します。</li>
				<li><strong><a href="http://www.w3.org/">W3C</a>が公開するオリジナルの英語版(<a href="http://www.w3.org/TR/2006/REC-xml11-20060816">http://www.w3.org/TR/2006/REC-xml11-20060816</a>)のみがこの仕様書の規範的なバージョンです</strong>。この文書は参考にすぎません。</li>
				<li><strong>この文書には恐らく翻訳上の誤りが含まれます</strong>。繰り返しますが、この文書は参考にすぎません。</li>
			</ul>
		</dd>
		<dt>翻訳者 Translator</dt>
			<dd>Hiroaki Hasegawa</dd>
		<dt>公開日 Publication Date</dt>
			<dd>2007-04-29T18:24:06+09:00</dd>
		<dt>最終更新日 Latest Modification Date</dt>
			<dd>2008-12-06T16:00:15+09:00</dd>
		<dt>その他の情報</dt>
		<dd>
			<ul>
				<li>明らかな翻訳上の間違いを確認するのが簡単になるように、オリジナル版の文章も載せていますが、この翻訳版に載っている文章は翻訳者の編集上の誤りによってオリジナル版と変わっている恐れもあります。<em>この文書に載っている文章を規範的なものとしては引用しないで下さい</em>。オリジナル版の文章を引用する場合は、必ずW3Cのサイトの<a href="http://www.w3.org/TR/2006/REC-xml11-20060816">http://www.w3.org/TR/2006/REC-xml11-20060816</a>を使って下さい。</li>
				<li>必要が無ければオリジナル版の文章を隠す事もできます。印刷に便利かも知れません。Mozilla FirefoxやOperaなどの代替スタイルシートを選択できるブラウザでご覧下さい。</li>
			</ul>
		</dd>
	</dl>
	<div class="annotation">
		<p class="context-flow">[訳者註開始]</p>
		<p class="prefix"><em>訳者註</em></p>
		<p>この翻訳版の中には、このようにマークアップされた段落が幾つかあります。これらは翻訳者が独自の判断でやむを得ず追加した註釈(annotation)です。殆どのものは、オリジナル版の読解の為にではなく、翻訳版を読むに当たって問題となるかも知れない事柄に補足する為に追加したものです。元々オリジナル版の仕様書にはこれらの註釈は無く、勿論これらの註釈の内容が間違っていたとしても、それはオリジナル版の誤りではありません。註釈の中に誤りを見つけたら、Hiroaki Hasegawaまでお知らせ下さい。</p>
		<p>なお、オリジナル版にはNoteがありますが、これは別物です。混乱を避ける為、オリジナル版のNoteはメモと呼びます。</p>
		<p class="context-flow">[訳者註終了]</p>
	</div>
</div>
<p><a href="http://www.w3.org/"><img src="../../image/w3c_home.png" alt="W3C" height="48" width="72" /></a></p>
<h1><a name="title" id="title"></a>Extensible Markup Language (XML) 1.1 (第二版)<span class="original" lang="en" xml:lang="en"> Extensible Markup Language (XML) 1.1 (Second Edition)</span></h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C勧告 2006年8月16日 (2006年9月29日編集)<span class="original" lang="en" xml:lang="en"> W3C Recommendation 16 August 2006, edited in place 29 September 2006</span></h2>
<dl>
	<dt>このバージョン<span class="original" lang="en" xml:lang="en"> This version:</span></dt>
	<dd><a href="http://www.w3.org/TR/2006/REC-xml11-20060816">http://www.w3.org/TR/2006/REC-xml11-20060816</a></dd>
	<dt>最新のバージョン<span class="original" lang="en" xml:lang="en"> Latest version:</span></dt>
	<dd><a href="http://www.w3.org/TR/xml11">http://www.w3.org/TR/xml11</a></dd>
	<dt>一つ前のバージョン<span class="original" lang="en" xml:lang="en"> Previous version:</span></dt>
	<dd><a href="http://www.w3.org/TR/2006/PER-xml11-20060614">http://www.w3.org/TR/2006/PER-xml11-20060614</a></dd>
	<dt>編集者<span class="original" lang="en" xml:lang="en"> Editors:</span></dt>
	<dd lang="en" xml:lang="en">Tim Bray, Textuality and Netscape <a href="mailto:tbray@textuality.com">&lt;tbray@textuality.com&gt;</a></dd>
	<dd lang="en" xml:lang="en">Jean Paoli, Microsoft <a href="mailto:jeanpa@microsoft.com">&lt;jeanpa@microsoft.com&gt;</a></dd>
	<dd lang="en" xml:lang="en">C. M. Sperberg-McQueen, W3C <a href="mailto:cmsmcq@w3.org">&lt;cmsmcq@w3.org&gt;</a></dd>
	<dd lang="en" xml:lang="en">Eve Maler, Sun Microsystems, Inc. <a href="mailto:elm@east.sun.com">&lt;eve.maler@east.sun.com&gt;</a></dd>
	<dd lang="en" xml:lang="en">François Yergeau</dd>
	<dd lang="en" xml:lang="en">John Cowan <a href="mailto:cowan@ccil.org">&lt;cowan@ccil.org&gt;</a></dd>
</dl>
<p>この文書の公開後に規範的な訂正があるかも知れない。<a href="http://www.w3.org/XML/xml-V11-2e-errata"><strong>正誤表</strong></a>を確認してほしい。</p>
<p class="original" lang="en" xml:lang="en">Please refer to the <a href="http://www.w3.org/XML/xml-V11-2e-errata"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>翻訳版の誤りは、是非Hiroaki Hasegawaまでお知らせ下さい。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<p><a href="http://www.w3.org/XML/xml-V11-1e-errata">第一版の正誤表</a>も提供されている。</p>
<p class="original" lang="en" xml:lang="en">The <a href="http://www.w3.org/XML/xml-V11-1e-errata">previous errata</a> for this document, are also available.</p>
<p><a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml11"><strong>翻訳版</strong></a>も参照すると良い。</p>
<p class="original" lang="en" xml:lang="en">See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml11"><strong>translations</strong></a>.</p>
<p>この文書には、規範的ではないが、<a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml11-20060816.xml">XML形式</a>や<a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml11-20060816-review.html">修正箇所が色分けされたXHTML形式</a>もある。</p>
<p class="original" lang="en" xml:lang="en">This document is also available in these non-normative formats: <a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml11-20060816.xml">XML</a> and <a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml11-20060816-review.html">XHTML with color-coded revision indicators</a>.</p>
<p class="copyright" lang="en" xml:lang="en"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2006 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
</div>

<hr />

<div>
<h2><a name="abstract" id="abstract"></a>概要<span class="original" lang="en" xml:lang="en"> Abstract</span></h2>
<p>Extensible Markup Language (XML)は、この文書で全容を明らかにする、SGMLのサブセットである。XMLの目標は、一般的なSGMLを──現在HTMLで実現されているように──ウェブ上で授受し、処理する事を可能にする事である。XMLは、実装が容易であるように、またSGMLやHTMLと相互運用する事が可能であるように設計されている。</p>
<p class="original" lang="en" xml:lang="en">The Extensible Markup Language (XML) is a subset of SGML that is completely described in this document. Its goal is to enable generic SGML to be served, received, and processed on the Web in the way that is now possible with HTML. XML has been designed for ease of implementation and for interoperability with both SGML and HTML.</p>
</div>

<div>
<h2><a name="status" id="status"></a>この文書の位置付け<span class="original" lang="en" xml:lang="en"> Status of this Document</span></h2>
<p><em>このセクションでは、この文書を公開した時点での、この文書の位置付けを説明する。他の文書がより優れたものとして、この文書に取って代わる可能性がある。W3Cが現在公開している文書や、この技術情報の最新版は<a href="http://www.w3.org/TR/">W3C技術情報索引</a>(http://www.w3.org/TR/)で得られる。</em></p>
<p class="original" lang="en" xml:lang="en"><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>
<p>この文書は、既に広く使われている国際的なテキスト処理規格の標準(Standard Generalized Markup Language、ISO 8879:1986(E)に修正・訂正を加えたもの)をワールドワイドウェブで使う為、そのサブセットを取る事で作られる構文の仕様を定める。これは、<a href="http://www.w3.org/XML/Activity">XML Activity</a>の一環として、<a href="http://www.w3.org/XML/Core/">XML Core Working Group</a>が策定したものである。</p>
<p class="original" lang="en" xml:lang="en">This document specifies a syntax created by subsetting an existing, widely used international text processing standard (Standard Generalized Markup Language, ISO 8879:1986(E) as amended and corrected) for use on the World Wide Web. It is a product of the <a href="http://www.w3.org/XML/Core/">XML Core Working Group</a> as part of the <a href="http://www.w3.org/XML/Activity">XML Activity</a>.</p>
<p>2006年9月29日に、この文書から、大量の、不要かつ誤解を招きかねない空白が除去された。</p>
<p class="original" lang="en" xml:lang="en">On 29 September 2006 this document was edited in place to remove a number of spurious and potentially misleading spaces.</p>
<p>この仕様書は、英語版のみが規範である。しかし、この文書の翻訳版を見たいなら、<a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml11">http://www.w3.org/2003/03/Translations/byTechnology?technology=xml11</a>を見ると良い。</p>
<p class="original" lang="en" xml:lang="en">The English version of this specification is the only normative version. However, for translations of this document, see <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml11">http://www.w3.org/2003/03/Translations/byTechnology?technology=xml11</a>.</p>
<p>この文書は<a href="http://www.w3.org/2005/10/Process-20051014/tr.html#q74">W3Cの勧告文書</a>である。この第二版は、XMLの新しいバージョン<em>ではない</em>。読者の簡便の為、<a href="http://www.w3.org/TR/2004/REC-xml11-20040204/">2004年2月4日に公開されたXML 1.1 (第一版)</a>で報告され、集積された正誤情報(<a href="http://www.w3.org/XML/xml-V11-1e-errata">http://www.w3.org/XML/xml-V11-1e-errata</a>)をまとめ、修正を反映したものである。加えて、<a href="#rfc2119">[IETF RFC 2119]</a>で定義される意味で使った命令語に対するマークアップを、より<a href="#rfc2119">[IETF RFC 2119]</a>の趣旨に添うように変更した。この版は<a href="http://www.w3.org/TR/2004/REC-xml11-20040204">2004年2月4日に公開した第一版のW3C勧告</a>に取って代わる。</p>
<p class="original" lang="en" xml:lang="en">This document is a <a href="http://www.w3.org/2005/10/Process-20051014/tr.html#q74">W3C Recommendation</a>. This second edition is <em>not</em> a new version of XML. As a convenience to readers, it incorporates the changes dictated by the accumulated errata (available at <a href="http://www.w3.org/XML/xml-V11-1e-errata">http://www.w3.org/XML/xml-V11-1e-errata</a>) to the <a href="http://www.w3.org/TR/2004/REC-xml11-20040204/">First Edition of XML 1.1, dated 4 February 2004</a>. In addition, the markup introduced to clarify when prescriptive keywords are used in the formal sense defined in <a href="#rfc2119">[IETF RFC 2119]</a>, has been modified to better match the intent of <a href="#rfc2119">[IETF RFC 2119]</a>. This edition supersedes the previous <a href="http://www.w3.org/TR/2004/REC-xml11-20040204">W3C Recommendation of 4 February 2004</a>.</p>
<p>この文書に誤りを見つけたら、是非とも公開メーリングリスト<a href="mailto:xml-editor@w3.org">xml-editor@w3.org</a>に報告してほしい。このメーリングリストにおける<a href="http://lists.w3.org/Archives/Public/xml-editor/">過去の投稿</a>も見られる。また、読者の簡便の為、<a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml11-20060816-review.html">修正箇所が色分けされたXHTML版</a>も用意されている。これは、<a href="http://www.w3.org/XML/xml-V11-1e-errata">正誤表</a>に載っている誤りを目立たせ、その正誤情報を扱っている箇所にリンクしてある。誤りの殆どは、修正の根拠が説明されている。この第二版の正誤表は<a href="http://www.w3.org/XML/xml-V11-2e-errata">http://www.w3.org/XML/xml-V11-2e-errata</a>で見られる。</p>
<p class="original" lang="en" xml:lang="en">Please report errors in this document to the public <a href="mailto:xml-editor@w3.org">xml-editor@w3.org</a> mailing list; <a href="http://lists.w3.org/Archives/Public/xml-editor/">archives</a> are available. For the convenience of readers, an <a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml11-20060816-review.html">XHTML version with color-coded revision indicators</a> is also provided; this version highlights each change due to an erratum published in the <a href="http://www.w3.org/XML/xml-V11-1e-errata">errata list</a>, together with a link to the particular erratum in that list. Most of the errata in the list provide a rationale for the change. The errata list for this second edition is available at <a href="http://www.w3.org/XML/xml-V11-2e-errata">http://www.w3.org/XML/xml-V11-2e-errata</a>.</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>翻訳版の誤りは、是非Hiroaki Hasegawaまでお知らせ下さい。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<p>実装の報告は<a href="http://www.w3.org/XML/2006/06/xml11-2e-implementation.html">http://www.w3.org/XML/2006/06/xml11-2e-implementation.html</a>で見られる。この仕様への適合度評価を助ける為、<a href="http://www.w3.org/XML/Test/">Test Suite</a>が提供されている。</p>
<p class="original" lang="en" xml:lang="en">An implementation report is available at <a href="http://www.w3.org/XML/2006/06/xml11-2e-implementation.html">http://www.w3.org/XML/2006/06/xml11-2e-implementation.html</a>. A <a href="http://www.w3.org/XML/Test/">Test Suite</a> is maintained to help assessing conformance to this specification.</p>
<p>この文書は、W3C会員、ソフトウェア開発者や、W3Cの他のグループ、またこれに興味を持った団体によって審査され、W3C勧告として公開しても問題無いとW3Cディレクターに認められたものである。この文書は安定しており、リファレンスとして使ったり、他の文書から引用したりしても構わない。W3Cが勧告文書を作るのは、仕様書に注意を集め、その仕様が広く普及する事を促す為である。これは、ウェブの機能性と相互運用性を高めるのに役立つ。</p>
<p class="original" lang="en" xml:lang="en">This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>
<p>この文書は、<a href="http://www.w3.org/2004/02/05-pp-transition">W3C Patent Policy Transition Procedure</a>によって修正を受ける、<a href="http://www.w3.org/TR/2002/NOTE-patent-practice-20020124">2002年1月24日付けのCurrent Patent Practice</a>の影響を受ける。W3Cは、W3Cの提供する文書と関係する<a href="http://www.w3.org/2002/08/xmlcore-IPR-statements" rel="disclosure">すべての特許情報開示の公開リスト</a>を提供する。リストを提供する文書では、特許情報を開示する為の方法も書かれている。<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>を含んでいると考えられる特許について実際の情報を知っている者は、<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C Patent Policyのセクション6</a>に従ってその情報を開示しなければならない。</p>
<p class="original" lang="en" xml:lang="en">This document is governed by the <a href="http://www.w3.org/TR/2002/NOTE-patent-practice-20020124">24 January 2002 CPP</a> as amended by the <a href="http://www.w3.org/2004/02/05-pp-transition">W3C Patent Policy Transition Procedure</a>. W3C maintains a <a href="http://www.w3.org/2002/08/xmlcore-IPR-statements" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>この特許に関する段落については全く以て自信がありません。この段落については本翻訳を読むより、<a href="http://www.w3.org/TR/2006/REC-xml11-20060816">オリジナル版</a>で確認して下さい。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
</div>

<div class="toc">
<h2><a name="contents" id="contents"></a>目次<span class="original" lang="en" xml:lang="en"> Table of Contents</span></h2>
<p class="toc">
1 <a href="#sec-intro">導入<span class="original" lang="en" xml:lang="en"> Introduction</span></a><br />
    1.1 <a href="#sec-origin-goals">始まりと目標<span class="original" lang="en" xml:lang="en"> Origin and Goals</span></a><br />
    1.2 <a href="#sec-terminology">専門用語<span class="original" lang="en" xml:lang="en"> Terminology</span></a><br />
    1.3 <a href="#sec-xml11">XML 1.1での変更点とその原理的説明<span class="original" lang="en" xml:lang="en"> Rationale and list of changes for XML 1.1</span></a><br />
2 <a href="#sec-documents">文書<span class="original" lang="en" xml:lang="en"> Document</span></a><br />
    2.1 <a href="#sec-well-formed">整形式のXML文書<span class="original" lang="en" xml:lang="en"> Well-Formed XML Documents</span></a><br />
    2.2 <a href="#charsets">文字<span class="original" lang="en" xml:lang="en"> Characters</span></a><br />
    2.3 <a href="#sec-common-syn">一般的な構文構成子<span class="original" lang="en" xml:lang="en"> Common Syntactic Constructs</span></a><br />
    2.4 <a href="#syntax">文字データとマークアップ<span class="original" lang="en" xml:lang="en"> Character Data and Markup</span></a><br />
    2.5 <a href="#sec-comments">コメント<span class="original" lang="en" xml:lang="en"> Comments</span></a><br />
    2.6 <a href="#sec-pi">処理命令<span class="original" lang="en" xml:lang="en"> Processing Instructions</span></a><br />
    2.7 <a href="#sec-cdata-sect">CDATAセクション<span class="original" lang="en" xml:lang="en"> CDATA Sections</span></a><br />
    2.8 <a href="#sec-prolog-dtd">プロローグと文書型宣言<span class="original" lang="en" xml:lang="en"> Prolog and Document Type Declaration</span></a><br />
    2.9 <a href="#sec-rmd">スタンドアローン文書宣言<span class="original" lang="en" xml:lang="en"> Standalone Document Declaration</span></a><br />
    2.10 <a href="#sec-white-space">ホワイトスペースの取り扱い<span class="original" lang="en" xml:lang="en"> White Space Handling</span></a><br />
    2.11 <a href="#sec-line-ends">行末の取り扱い<span class="original" lang="en" xml:lang="en"> End-of-Line Handling</span></a><br />
    2.12 <a href="#sec-lang-tag">言語識別<span class="original" lang="en" xml:lang="en"> Language Identification</span></a><br />
    2.13 <a href="#sec-normalization-checking">正規化検査<span class="original" lang="en" xml:lang="en"> Normalization Checking</span></a><br />
3 <a href="#sec-logical-struct">論理構造<span class="original" lang="en" xml:lang="en"> Logical Structures</span></a><br />
    3.1 <a href="#sec-starttags">開始タグ、終了タグ、空要素タグ<span class="original" lang="en" xml:lang="en"> Start-Tags, End-Tags, and Empty-Element Tags</span></a><br />
    3.2 <a href="#elemdecls">要素型宣言<span class="original" lang="en" xml:lang="en"> Element Type Declarations</span></a><br />
        3.2.1 <a href="#sec-element-content">要素内容<span class="original" lang="en" xml:lang="en"> Element Content</span></a><br />
        3.2.2 <a href="#sec-mixed-content">混合内容<span class="original" lang="en" xml:lang="en"> Mixed Content</span></a><br />
    3.3 <a href="#attdecls">属性リスト宣言<span class="original" lang="en" xml:lang="en"> Attribute-List Declarations</span></a><br />
        3.3.1 <a href="#sec-attribute-types">属性型<span class="original" lang="en" xml:lang="en"> Attribute Types</span></a><br />
        3.3.2 <a href="#sec-attr-defaults">属性デフォルト<span class="original" lang="en" xml:lang="en"> Attribute Defaults</span></a><br />
        3.3.3 <a href="#AVNormalize">属性値正規化<span class="original" lang="en" xml:lang="en"> Attribute-Value Normalization</span></a><br />
    3.4 <a href="#sec-condition-sect">条件付きセクション<span class="original" lang="en" xml:lang="en"> Conditional Sections</span></a><br />
4 <a href="#sec-physical-struct">物理構造<span class="original" lang="en" xml:lang="en"> Physical Structures</span></a><br />
    4.1 <a href="#sec-references">文字参照と実体参照<span class="original" lang="en" xml:lang="en"> Character and Entity References</span></a><br />
    4.2 <a href="#sec-entity-decl">実体宣言<span class="original" lang="en" xml:lang="en"> Entity Declarations</span></a><br />
        4.2.1 <a href="#sec-internal-ent">内部実体<span class="original" lang="en" xml:lang="en"> Internal Entities</span></a><br />
        4.2.2 <a href="#sec-external-ent">外部実体<span class="original" lang="en" xml:lang="en"> External Entities</span></a><br />
    4.3 <a href="#TextEntities">解析対象実体<span class="original" lang="en" xml:lang="en"> Parsed Entities</span></a><br />
        4.3.1 <a href="#sec-TextDecl">テキスト宣言<span class="original" lang="en" xml:lang="en"> The Text Declaration</span></a><br />
        4.3.2 <a href="#wf-entities">整形式の解析対象実体<span class="original" lang="en" xml:lang="en"> Well-Formed Parsed Entities</span></a><br />
        4.3.3 <a href="#charencoding">実体で使われる文字エンコーディング<span class="original" lang="en" xml:lang="en"> Character Encoding in Entities</span></a><br />
        4.3.4 <a href="#sec-version-info">実体のバージョン情報<span class="original" lang="en" xml:lang="en"> Version Information in Entities</span></a><br />
    4.4 <a href="#entproc">XMLプロセッサによる実体と参照の扱い<span class="original" lang="en" xml:lang="en"> XML Processor Treatment of Entities and References</span></a><br />
        4.4.1 <a href="#not-recognized">認識されない<span class="original" lang="en" xml:lang="en"> Not Recognized</span></a><br />
        4.4.2 <a href="#included">インクルードされる<span class="original" lang="en" xml:lang="en"> Included</span></a><br />
        4.4.3 <a href="#include-if-valid">妥当性を検証する場合インクルードされる<span class="original" lang="en" xml:lang="en"> Included If Validating</span></a><br />
        4.4.4 <a href="#forbidden">許されない<span class="original" lang="en" xml:lang="en"> Forbidden</span></a><br />
        4.4.5 <a href="#inliteral">リテラルの中でインクルードされる<span class="original" lang="en" xml:lang="en"> Included in Literal</span></a><br />
        4.4.6 <a href="#notify">通知する<span class="original" lang="en" xml:lang="en"> Notify</span></a><br />
        4.4.7 <a href="#bypass">バイパスされる<span class="original" lang="en" xml:lang="en"> Bypassed</span></a><br />
        4.4.8 <a href="#as-PE">パラメータ実体としてインクルードされる<span class="original" lang="en" xml:lang="en"> Included as PE</span></a><br />
        4.4.9 <a href="#error">エラー<span class="original" lang="en" xml:lang="en"> Error</span></a><br />
    4.5 <a href="#intern-replacement">実体の置換テキストの構築<span class="original" lang="en" xml:lang="en"> Construction of Entity Replacement Text</span></a><br />
    4.6 <a href="#sec-predefined-ent">定義済み実体<span class="original" lang="en" xml:lang="en"> Predefined Entities</span></a><br />
    4.7 <a href="#Notations">記法宣言<span class="original" lang="en" xml:lang="en"> Notation Declarations</span></a><br />
    4.8 <a href="#sec-doc-entity">文書実体<span class="original" lang="en" xml:lang="en"> Document Entity</span></a><br />
5 <a href="#sec-conformance">適合性<span class="original" lang="en" xml:lang="en"> Conformance</span></a><br />
    5.1 <a href="#proc-types">妥当性を検証するプロセッサとしないプロセッサ<span class="original" lang="en" xml:lang="en"> Validating and Non-Validating Processors</span></a><br />
    5.2 <a href="#safe-behavior">XMLプロセッサの使用<span class="original" lang="en" xml:lang="en"> Using XML Processors</span></a><br />
6 <a href="#sec-notation">仕様書の記法<span class="original" lang="en" xml:lang="en"> Notation</span></a><br />
</p>

<h3><a name="appendices" id="appendices"></a>附録<span class="original" lang="en" xml:lang="en"> Appendices</span></h3>
<p class="toc">
A <a href="#sec-bibliography">参考文献<span class="original" lang="en" xml:lang="en"> References</span></a><br />
    A.1 <a href="#sec-existing-stds">規範的な参考文献<span class="original" lang="en" xml:lang="en"> Normative References</span></a><br />
    A.2 <a href="#null">その他の参考文献<span class="original" lang="en" xml:lang="en"> Other References</span></a><br />
B <a href="#sec-CharNorm">文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></a><br />
C <a href="#sec-entexpand">実体参照と文字参照の展開<span class="original" lang="en" xml:lang="en"> Expansion of Entity and Character References</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
D <a href="#determinism">決定的内容モデル<span class="original" lang="en" xml:lang="en"> Deterministic Content Models</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
E <a href="#sec-guessing">文字エンコーディングの自動検知<span class="original" lang="en" xml:lang="en"> Autodetection of Character Encodings</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
    E.1 <a href="#sec-guessing-no-ext-info">外部エンコーディング情報を使わない検知<span class="original" lang="en" xml:lang="en"> Detection Without External Encoding Information</span></a><br />
    E.2 <a href="#sec-guessing-with-ext-info">外部エンコーディング情報が存在する時の優先度<span class="original" lang="en" xml:lang="en"> Priorities in the Presence of External Encoding Information</span></a><br />
F <a href="#sec-xml-wg">W3C XML Working Group<span class="original" lang="en" xml:lang="en"> W3C XML Working Group</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
G <a href="#sec-core-wg">W3C XML Core Working Group<span class="original" lang="en" xml:lang="en"> W3C XML Core Working Group</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
H <a href="#prod-notes">生成メモ<span class="original" lang="en" xml:lang="en"> Production Notes</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
I <a href="#sec-suggested-names">XML名前の為の提案<span class="original" lang="en" xml:lang="en"> Suggestions for XML Names</span></a> (非規範的)<span class="original" lang="en" xml:lang="en"> (Non-Normative)</span><br />
</p>

</div>

<hr />

<div class="body">

<div class="div1">
<h2><a name="sec-intro" id="sec-intro"></a>1 導入<span class="original" lang="en" xml:lang="en"> Introduction</span></h2>
<p>Extensible Markup Language(XMLと略される)は、<a title="XML文書" href="#dt-xml-doc">XML文書</a>と呼ばれるデータオブジェクトのクラスを説明する。また、XMLを処理するコンピュータプログラムの動作の一部も説明する。XMLはSGML(Standard Generalized Markup Language <a href="#ISO8879">[ISO 8879]</a>)のアプリケーションプロファイルであるか、制限された形式のものである。構造上、XML文書はSGML文書に適合する。</p>
<p class="original" lang="en" xml:lang="en">Extensible Markup Language, abbreviated XML, describes a class of data objects called <a title="XML Document" href="#dt-xml-doc">XML documents</a> and partially describes the behavior of computer programs which process them. XML is an application profile or restricted form of SGML, the Standard Generalized Markup Language <a href="#ISO8879">[ISO 8879]</a>. By construction, XML documents are conforming SGML documents.</p>
<p>XML文書は、<a title="実体" href="#dt-entity">実体</a>と呼ばれる記録単位から成る。実体は、解析対象となるデータ、ならないデータの何れかを持つ。解析対象となるデータは<a title="Character" href="#dt-character">文字</a>から成る。文字は、幾つかが集まって<a title="文字データ" href="#dt-chardata">文字データ</a>を作る事もあるし、<a title="マークアップ" href="#dt-markup">マークアップ</a>を作る事もある。マークアップは、文書の記録データの配置や、論理構造についての情報をエンコードする。XMLは、記録データの配置や論理構造についての制約を課す機構を提供する。</p>
<p class="original" lang="en" xml:lang="en">XML documents are made up of storage units called <a title="Entity" href="#dt-entity">entities</a>, which contain either parsed or unparsed data. Parsed data is made up of <a title="Character" href="#dt-character">characters</a>, some of which form <a title="Character Data" href="#dt-chardata">character data</a>, and some of which form <a title="Markup" href="#dt-markup">markup</a>. Markup encodes a description of the document's storage layout and logical structure. XML provides a mechanism to impose constraints on the storage layout and logical structure.</p>
<p>[<a name="dt-xml-proc" id="dt-xml-proc" title="XMLプロセッサ">定義</a>: <b>XMLプロセッサ</b>と呼ばれるソフトウェアモジュールは、XML文書を読み込み、その内容と構造にアクセスする手段を提供する為に使われる。] [<a name="dt-app" id="dt-app" title="アプリケーション">定義</a>: XMLプロセッサは、別のモジュールで、XMLプロセッサが提供する内容・構造を利用する為に使われると考えられる。この、XMLプロセッサを利用するモジュールを<b>アプリケーション</b>と呼ぶ。] この仕様書では、アプリケーションに渡さなければならないXMLデータや情報を読み取るに当たって、XMLプロセッサに必要とされる動作を説明する。</p>
<p class="original" lang="en" xml:lang="en">[Definition: A software module called an <b>XML processor</b> is used to read XML documents and provide access to their content and structure.] [Definition: It is assumed that an XML processor is doing its work on behalf of another module, called the <b>application</b>.] This specification describes the required behavior of an XML processor in terms of how it must read XML data and the information it must provide to the application.</p>

<div class="div2">
<h3><a name="sec-origin-goals" id="sec-origin-goals"></a>1.1 始まりと目標<span class="original" lang="en" xml:lang="en"> Origin and Goals</span></h3>
<p>XMLの発展は、1996年にWorld Wide Web Consortium(W3C)の援助の下発足したSGML Editorial Review Board──後のXML Working Groupの手によるものである。XML Working Groupの議長はSun MicrosystemsのJon Bosakが務めた。XML Working Groupの活動には、同じくW3Cで組織されたSGML Working Group──現在のXML Special Interest Groupが積極的に参加してくれた。XML Working Groupのメンバは附録に載せておく。XML Working GroupとW3Cとの連絡はDan Connollyが取り持った。</p>
<p class="original" lang="en" xml:lang="en">XML was developed by an XML Working Group (originally known as the SGML Editorial Review Board) formed under the auspices of the World Wide Web Consortium (W3C) in 1996. It was chaired by Jon Bosak of Sun Microsystems with the active participation of an XML Special Interest Group (previously known as the SGML Working Group) also organized by the W3C. The membership of the XML Working Group is given in an appendix. Dan Connolly served as the Working Group's contact with the W3C.</p>
<p>XMLの設計目標は次の通り。</p>
<p class="original" lang="en" xml:lang="en">The design goals for XML are:</p>
<ol class="enumar">
	<li>
		<p>XMLが、インターネットのどこでもそのまま使える事。</p>
		<p class="original" lang="en" xml:lang="en">XML shall be straightforwardly usable over the Internet.</p>
	</li>
	<li>
		<p>XMLが多岐に渡るアプリケーションの役に立つ事。</p>
		<p class="original" lang="en" xml:lang="en">XML shall support a wide variety of applications.</p>
	</li>
	<li>
		<p>XMLがSGMLと互換性を持っている事。</p>
		<p class="original" lang="en" xml:lang="en">XML shall be compatible with SGML.</p>
	</li>
	<li>
		<p>XML文書を処理するプログラムを書く事が簡単である事。</p>
		<p class="original" lang="en" xml:lang="en">It shall be easy to write programs which process XML documents.</p>
	</li>
	<li>
		<p>XMLの、実装によってばらつきが出るような機能が限りなく少なく保たれる事……理想を言えば、そんな機能が全く無い事。</p>
		<p class="original" lang="en" xml:lang="en">The number of optional features in XML is to be kept to the absolute minimum, ideally zero.</p>
	</li>
	<li>
		<p>XML文書が、できれば人間にも読みやすく、道理に適ってすっきりしている事。</p>
		<p class="original" lang="en" xml:lang="en">XML documents should be human-legible and reasonably clear.</p>
	</li>
	<li>
		<p>XMLの設計が、できれば素早く用意される事。</p>
		<p class="original" lang="en" xml:lang="en">The XML design should be prepared quickly.</p>
	</li>
	<li>
		<p>XMLの設計が、きちんとした形式でありながら同時に簡潔である事。</p>
		<p class="original" lang="en" xml:lang="en">The design of XML shall be formal and concise.</p>
	</li>
	<li>
		<p>XML文書を作る事が簡単である事。</p>
		<p class="original" lang="en" xml:lang="en">XML documents shall be easy to create.</p>
	</li>
	<li>
		<p>XMLのマークアップにおいては、(厳密さに比べて)簡潔さは全然重要でない事。</p>
		<p class="original" lang="en" xml:lang="en">Terseness in XML markup is of minimal importance.</p>
	</li>
</ol>
<p>この仕様書には、関連する標準規格(文字に関してはUnicode <a href="#Unicode">[Unicode]</a>とISO/IEC 10646 <a href="#ISO10646">[ISO/IEC 10646]</a>、言語識別タグに関してはInternet RFC 3066 <a href="#RFC1766">[IETF RFC 3066]</a>、言語コードについてはISO 639 <a href="#ISO639">[ISO 639]</a>、そして国コードについてはISO 3166 <a href="#ISO3166">[ISO 3166]</a>)と共に読む事で、XML バージョン1.1を理解し、それを処理する事のできるコンピュータプログラムを構築する為に必要なすべての情報が書かれている。</p>
<p class="original" lang="en" xml:lang="en">This specification, together with associated standards (Unicode <a href="#Unicode">[Unicode]</a> and ISO/IEC 10646 <a href="#ISO10646">[ISO/IEC 10646]</a> for characters, Internet RFC 3066 <a href="#RFC1766">[IETF RFC 3066]</a> for language identification tags, ISO 639 <a href="#ISO639">[ISO 639]</a> for language name codes, and ISO 3166 <a href="#ISO3166">[ISO 3166]</a> for country name codes), provides all the information necessary to understand XML Version 1.1 and construct computer programs to process it.</p>
<p>このバージョンのXML仕様書は、テキスト及び法律上の注意事項のすべてをそのままにするならば、自由に配付して良い。</p>
<p class="original" lang="en" xml:lang="en">This version of the XML specification may be distributed freely, as long as all text and legal notices remain intact.</p>
</div>

<div class="div2">
<h3><a name="sec-terminology" id="sec-terminology"></a>1.2 専門用語<span class="original" lang="en" xml:lang="en"> Terminology</span></h3>
<p>XML文書を記述する際に使われる用語については、この仕様書の本文で定義する。キーワード<em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">SHALL</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">SHALL NOT</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD NOT</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">RECOMMENDED</em>、<em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em>、そして<em class="rfc2119" title="Keyword in RFC 2119 context">OPTIONAL</em>が<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">強調されて</em>使われた場合、それらは<a href="#rfc2119">[IETF RFC 2119]</a>で説明されている意味で使われているものとする。加えて、次に挙げるリストで定義される用語は、本文中の用語の定義や、XMLプロセッサの動作の記述に使われる。</p>
<p class="original" lang="en" xml:lang="en">The terminology used to describe XML documents is defined in the body of this specification. The key words <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">SHALL</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">SHALL NOT</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD NOT</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">RECOMMENDED</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em>, and <em class="rfc2119" title="Keyword in RFC 2119 context">OPTIONAL</em>, when <em class="rfc2119" title="Keyword in RFC 2119 context">EMPHASIZED</em>, are to be interpreted as described in <a href="#rfc2119">[IETF RFC 2119]</a>. In addition, the terms defined in the following list are used in building those definitions and in describing the actions of an XML processor:</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p><a href="#rfc2119">[IETF RFC 2119]</a>で定義されるキーワード、即ちMUSTからOPTIONALまでが強調されて使われている場合、この翻訳版でも括弧書きでキーワードを添えるようにしています。これらのキーワードに対応する日本語として、この翻訳版では、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しなければならない(MUST)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">してはならない(MUST NOT)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">必須とされる(REQUIRED)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">すべきである(SHALL)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">すべきでない(SHALL NOT)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">望ましい(SHOULD)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">望ましくない(SHOULD NOT)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">推奨される(RECOMMENDED)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しても良い(MAY)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">任意である(OPTIONAL)</em>などという表現を使います。正確な定義やニュアンスを知るには<a href="#rfc2119">[IETF RFC 2119]</a>を読んでもらいたいのですが、特に、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">すべきである(SHALL)</em>と<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">すべきでない(SHALL NOT)</em>は絶対的な要件(強制)、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">望ましい(SHOULD)</em>と<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">望ましくない(SHOULD NOT)</em>は最大限の推奨(強制ではない)である事に気を付けて下さい。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<dl>
	<dt class="label">エラー<span class="original" lang="en" xml:lang="en"> error</span></dt>
	<dd>
		<p>[<a name="dt-error" id="dt-error" title="エラー">定義</a>: この仕様書で定められる規則に対する違反。その結果は定義されない。特別な記述が無い限り、この仕様書で、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しなければならない(MUST)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">必須とされる(REQUIRED)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">してはならない(MUST NOT)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">すべきである(SHALL)</em>、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">すべきでない(SHALL NOT)</em>とされている規定を遵守しないものはエラーである。仕様に適合するソフトウェアは、エラーを検知してアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しても良い(MAY)</em>し、エラーを修復してその状態から<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">復帰しても良い(MAY)</em>。</p>
		<p class="original" lang="en" xml:lang="en">[Definition: A violation of the rules of this specification; results are undefined. Unless otherwise specified, failure to observe a prescription of this specification indicated by one of the keywords <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em>, <em class="rfc2119" title="Keyword in RFC 2119 context">SHALL</em> and <em class="rfc2119" title="Keyword in RFC 2119 context">SHALL NOT</em> is an error. Conforming software <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> detect and report an error and <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> recover from it.]</p>
	</dd>
	<dt class="label">致命的エラー<span class="original" lang="en" xml:lang="en"> fatal error</span></dt>
	<dd>
		<p>[<a name="dt-fatal" id="dt-fatal" title="致命的エラー">定義</a>: 仕様に適合する<a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>が検知し、アプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しなければならない(MUST)</em>エラー。XMLプロセッサは、一つめの致命的エラーに出くわした後、更なるエラーを探す為に処理を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">続けても良い(MAY)</em>し、アプリケーションにそれらのエラーを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しても良い(MAY)</em>。XMLプロセッサは、エラーの訂正を支援する為、文書の処理しなかったデータを(文字データとマークアップとに分けたものと共に)アプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">渡しても良い(MAY)</em>。しかし、一度致命的エラーを検知したならば、XMLプロセッサは通常の処理を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">続けてはならない(MUST NOT)</em>。即ち、通常のやり方で、文字データや文書の論理構造に関する情報をアプリケーションに渡す事を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">続けてはならない(MUST NOT)</em>。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: An error which a conforming <a title="XML Processor" href="#dt-xml-proc">XML processor</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> detect and report to the application. After encountering a fatal error, the processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> continue processing the data to search for further errors and <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> report such errors to the application. In order to support correction of errors, the processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> make unprocessed data from the document (with intermingled character data and markup) available to the application. Once a fatal error is detected, however, the processor <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> continue normal processing (i.e., it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> continue to pass character data and information about the document's logical structure to the application in the normal way).]</p>
	</dd>
	<dt class="label">ユーザが選択した場合<span class="original" lang="en" xml:lang="en"> at user option</span></dt>
	<dd>
		<p>[<a name="dt-atuseroption" id="dt-atuseroption" title="ユーザが選択した場合">定義</a>: 仕様に適合するソフトウェアは、そこで説明されているような動作を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しても良い(MAY)</em>、あるいは<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しなければならない(MUST)</em>(文章で使われている法の助動詞に依る)。そのような動作をする場合は、ユーザにその動作の有効・無効を選択する手段を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">提供しなければならない(MUST)</em>。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: Conforming software <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> or <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> (depending on the modal verb in the sentence) behave as described; if it does, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> provide users a means to enable or disable the behavior described.]</p>
	</dd>
	<dt class="label">妥当性制約<span class="original" lang="en" xml:lang="en"> validity constraint</span></dt>
	<dd>
		<p>[<a name="dt-vc" id="dt-vc" title="妥当性制約">定義</a>: すべての<a title="妥当性" href="#dt-valid">妥当</a>なXML文書に適用される規則。妥当性制約に対する違反はエラーである。<a title="妥当性を検証するプロセッサ" href="#dt-validating">妥当性を検証するXMLプロセッサ</a>は、ユーザが選択した場合、それらのエラーを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しなければならない(MUST)</em>。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: A rule which applies to all <a title="Validity" href="#dt-valid">valid</a> XML documents. Violations of validity constraints are errors; they <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em>, at user option, be reported by <a title="Validating Processor" href="#dt-validating">validating XML processors</a>.]</p>
	</dd>
	<dt class="label">整形式性制約<span class="original" lang="en" xml:lang="en"> well-formedness constraint</span></dt>
	<dd>
		<p>[<a name="dt-wfc" id="dt-wfc" title="整形式性制約">定義</a>: すべての<a title="整形式性" href="#dt-wellformed">整形式</a>のXML文書に適用される規則。整形式性制約に対する違反は<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>である。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: A rule which applies to all <a title="Well-Formed" href="#dt-wellformed">well-formed</a> XML documents. Violations of well-formedness constraints are <a title="Fatal Error" href="#dt-fatal">fatal errors</a>.]</p>
	</dd>
	<dt class="label">マッチする<span class="original" lang="en" xml:lang="en"> match</span></dt>
	<dd>
		<p>[<a name="dt-match" id="dt-match" title="マッチする">定義</a>: (文字列や名前がマッチする:) 比較対象の二つの文字列、あるいは比較対象の二つの名前があらゆる点で一致する。Unicodeにおいて複数の表現方法がある文字(例えば、最初から組み合わさっている形式(合成済み形式)と、元となる文字(基底文字)に発音区別符号を組み合わせる形式がある文字)は、両方の文字列で同じ表現方法が使われている時にのみマッチする。ケースフォールディングは行われない。(文字列と文法規則がマッチする:) 文字列が、生成規則によって生成される言語(生成規則によって課される制約を満たすあらゆる文字列の集合)に属する時、文字列は生成規則にマッチする。(内容と内容モデルがマッチする:) <b>[妥当性制約: <a href="#elementvalid">妥当な要素</a>]</b>を満たす時、要素はその宣言にマッチする。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: (Of strings or names:) Two strings or names being compared are identical. Characters with multiple possible representations in Unicode (e.g. characters with both precomposed and base+diacritic forms) match only if they have the same representation in both strings. No case folding is performed. (Of strings and rules in the grammar:) A string matches a grammatical production if it belongs to the language generated by that production. (Of content and content models:) An element matches its declaration when it conforms in the fashion described in the constraint <b>[VC: <a href="#elementvalid">Element Valid</a>]</b>.]</p>
		<div class="annotation">
			<p class="context-flow">[訳者註開始]</p>
			<p class="prefix"><em>訳者註</em></p>
			<p>ケースフォールディング(Case Folding)とは、(この仕様書の原文では明示されていませんが)UnicodeにおけるCase Foldingの事でしょう。ケースフォールディングは、ケース間の、大抵の場合は大文字小文字の間の差異を無視する操作の事です。例えば、ラテン文字の大文字はラテン文字の小文字に変換されるので、ケースフォールディングを行う場合は、MathとmAthは両方ともmathになるので一致します。完全ケースフォールディングをする場合、ドイツ語のアルファベットの一つ、エスツェット('&#xdf;')はラテン文字の小文字のエス二つ('ss')に変換されるので、da&#xdf;とdassは両方ともdassになって一致します。</p>
			<p><em>XMLで文字列や名前がマッチするかどうかを判定する時にはケースフォールディングが行われない</em>事に気を付けて下さい。なお、ケースフォールディングで変換される文字のリストは<a href="ftp://ftp.unicode.org/Public/UNIDATA/CaseFolding.txt">CaseFolding.txt</a>で得られます。</p>
			<p class="context-flow">[訳者註終了]</p>
		</div>
	</dd>
	<dt class="label">互換性の為に<span class="original" lang="en" xml:lang="en"> for compatibility</span></dt>
	<dd>
		<p>[<a name="dt-compat" id="dt-compat" title="互換性の為に">定義</a>: XMLがSGMLと互換性を持つようにする為だけに付け加えられたXMLの機能を説明する文章に付く句。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: Marks a sentence describing a feature of XML included solely to ensure that XML remains compatible with SGML.]</p>
	</dd>
	<dt class="label">相互運用性の為に<span class="original" lang="en" xml:lang="en"> for interoperability</span></dt>
	<dd>
		<p>[<a name="dt-interop" id="dt-interop" title="相互運用性の為に">定義</a>: XML文書が、ISO 8879に対するWebSGML Adaptions Annexが出される前に作られたSGMLプロセッサでも処理できる機会を増やす為に付け加えられた、拘束力を持たない推奨事項を説明する文章に付く句。]</p>
		<p class="original" lang="en" xml:lang="en">[Definition: Marks a sentence describing a non-binding recommendation included to increase the chances that XML documents can be processed by the existing installed base of SGML processors which predate the WebSGML Adaptations Annex to ISO 8879.]</p>
	</dd>
</dl>
</div>

<div class="div2">
<h3><a name="sec-xml11" id="sec-xml11"></a>1.3 XML 1.1での変更点とその原理的説明<span class="original" lang="en" xml:lang="en"> Rationale and list of changes for XML 1.1</span></h3>
<p>W3CのXML 1.0の勧告文書が最初に発行されたのは1998年である。沢山の誤りの発見と訂正の積み重ねは2004年に第三版を登場させる事となったが、それでもXML 1.0は、どんなXML文書が整形式で、どんなXML文書が整形式でないかという点では不変であった(これは意図的な狙いに因る)。この安定性は相互運用性を確保するという点において、非常に便利であった。しかしながらXML 1.0が文字についての仕様として頼っていたUnicode Standardは変わり続け、バージョン2.0からバージョン4.0、そして更に後続のバージョンへと発展していった。Unicode 2.0には登場しない文字でも、XML 1.0の文字データでは既に使う事ができた。しかし、それらの文字はXML名前、例えば要素型名、属性名、列挙属性値、処理命令の対象などに用いる事は許されていなかった。しかも、Unicode 2.0の仕様書で見落としをして、Unicode 2.0との間で整合性が保たれていなかった為に、本来XML名前で許されるべきだった文字の一部は、使用が許されていなかった。</p>
<p class="original" lang="en" xml:lang="en">The W3C's XML 1.0 Recommendation was first issued in 1998, and despite the issuance of many errata culminating in a Third Edition of 2004, has remained (by intention) unchanged with respect to what is well-formed XML and what is not. This stability has been extremely useful for interoperability. However, the Unicode Standard on which XML 1.0 relies for character specifications has not remained static, evolving from version 2.0 to version 4.0 and beyond. Characters not present in Unicode 2.0 may already be used in XML 1.0 character data. However, they are not allowed in XML names such as element type names, attribute names, enumerated attribute values, processing instruction targets, and so on. In addition, some characters that should have been permitted in XML names were not, due to oversights and inconsistencies in Unicode 2.0.</p>
<p>名前に関する方針はXML 1.0のものからがらりと変わった。XML 1.0の名前の定義は融通が利かず、許されていないものはすべて禁止されていたが、XML 1.1の名前では、特別な理由で禁止されていなければ、それらはすべて許される。Unicodeはバージョン4.0を出した後でも発展を続けるだろう。それ故、Unicodeでまだ割り当てられていない文字も含めて殆どすべての文字を名前に使う事を許可する事は、度重なるXMLの改訂を回避する事に繋がると考えられるのである。</p>
<p class="original" lang="en" xml:lang="en">The overall philosophy of names has changed since XML 1.0. Whereas XML 1.0 provided a rigid definition of names, wherein everything that was not permitted was forbidden, XML 1.1 names are designed so that everything that is not forbidden (for a specific reason) is permitted. Since Unicode will continue to grow past version 4.0, further changes to XML can be avoided by allowing almost any character, including those not yet assigned, in names.</p>
<p>加えて、XML 1.0はモダンなOSで用いられる行末の慣習を幅広く受け容れようとしたが、IBM及びIBM互換のメインフレームで使われる行末の慣習に対する配慮が無かった。その結果、XML文書は、メインフレームではプレーンテキストではなくなってしまった。メインフレームでXML 1.0文書を生成するには、ローカルな行末の慣習に逆らうか、あるいは構文解析の前と生成の後に不必要な変換をしなければならなかった。メインフレームとメインフレームでない環境の間でデータストアが共有される場合には、データストアがそのまま使えるという事(相互運用性)は特に重要な事である。故に、XML 1.1はNEL(#x85)を行末記号のリストに加える。更に万全を期す為、Unicodeの行区切り文字である#x2028もサポートされる。</p>
<p class="original" lang="en" xml:lang="en">In addition, XML 1.0 attempts to adapt to the line-end conventions of various modern operating systems, but discriminates against the conventions used on IBM and IBM-compatible mainframes. As a result, XML documents on mainframes are not plain text files according to the local conventions. XML 1.0 documents generated on mainframes must either violate the local line-end conventions, or employ otherwise unnecessary translation phases before parsing and after generation. Allowing straightforward interoperability is particularly important when data stores are shared between mainframe and non-mainframe systems (as opposed to being copied from one to the other). Therefore XML 1.1 adds NEL (#x85) to the list of line-end characters. For completeness, the Unicode line separator character, #x2028, is also supported.</p>
<p>そして、XML文書で任意のUnicode文字を使う為の標準的な表現方法を定めるよう、強い要望があった。これを受けてXML 1.1では、制御文字である#x1から#x1Fまでを参照する文字参照の使用を認めている。これらの文字参照の殆どはXML 1.0では禁止されていた。しかし、堅牢性の観点から、これらの文字を(文字参照を使わず)直接文書で使う事はXML 1.1でも認められない。また、文字エンコーディング検知の堅牢性を高める為、XML 1.0では文書中で自由に使う事が許されていた制御文字、つまり#x7Fから#x9Fまでの文字は、文字参照としてしか現れ得ない。勿論、ホワイトスペース文字はこの制限の対象ではない。後方互換性を僅かに犠牲にした事は、さして重要ではないと考えられる。また、APIが潜在的な問題を抱えている為、#x0についてはXML 1.1でも、直接記述する事も文字参照を使って表す事も禁止されている。</p>
<p class="original" lang="en" xml:lang="en">Finally, there is considerable demand to define a standard representation of arbitrary Unicode characters in XML documents. Therefore, XML 1.1 allows the use of character references to the control characters #x1 through #x1F, most of which are forbidden in XML 1.0. For reasons of robustness, however, these characters still cannot be used directly in documents. In order to improve the robustness of character encoding detection, the additional control characters #x7F through #x9F, which were freely allowed in XML 1.0 documents, now must also appear only as character references. (Whitespace characters are of course exempt.) The minor sacrifice of backward compatibility is considered not significant. Due to potential problems with APIs, #x0 is still forbidden both directly and as a character reference.</p>
<p>最後に、XML 1.1は、XML文書における「完全正規化」を定義する。文書の作成者は完全正規化を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">固守する事が望ましく(SHOULD)</em>、文書のプロセッサは<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">検証する事が望ましい(SHOULD)</em>。完全に正規化された文書を用いれば、名前、属性値や内容の文字が完全に同一であるかどうかの比較が、単にバイナリレベルでUnicode文字列を比較する事によって正確に行われる事が保証される。</p>
<p class="original" lang="en" xml:lang="en">Finally, XML 1.1 defines a set of constraints called "full normalization" on XML documents, which document creators <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> adhere to, and document processors <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> verify. Using fully normalized documents ensures that identity comparisons of names, attribute values, and character content can be made correctly by simple binary comparison of Unicode strings.</p>
<p>XML 1.0の誤りを直すのではなく、XMLの新しいバージョンが作られているのは、変更が整形式の文書の定義に及んだからである。XML 1.0プロセッサは依然として、XML名前に新しい文字、新しい行末の慣習、そして制御文字を参照する文字参照を含む文書を拒絶しなければならない。文書がXML 1.0文書であるか、XML 1.1文書であるかは、各文書の最初に置かれるXML宣言のバージョン番号情報で示される。</p>
<p class="original" lang="en" xml:lang="en">A new XML version, rather than a set of errata to XML 1.0, is being created because the changes affect the definition of well-formed documents. XML 1.0 processors must continue to reject documents that contain new characters in XML names, new line-end conventions, and references to control characters. The distinction between XML 1.0 and XML 1.1 documents is indicated by the version number information in the XML declaration at the start of each document.</p>
</div>
</div>

<div class="div1">
<h2><a name="sec-documents" id="sec-documents"></a>2 文書<span class="original" lang="en" xml:lang="en"> Documents</span></h2>
<p>[<a name="dt-xml-doc" id="dt-xml-doc" title="XML文書">定義</a>: データオブジェクトは、この仕様書で定義するように<a title="整形式性" href="#dt-wellformed">整形式</a>であるならば、<b>XML文書</b>となる。加えて、更なる所定の制約を満たす時、XML文書は<a title="妥当性" href="#dt-valid">妥当</a>となる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A data object is an <b>XML document</b> if it is <a title="Well-Formed" href="#dt-wellformed">well-formed</a>, as defined in this specification. In addition, the XML document is <a title="Validity" href="#dt-valid">valid</a> if it meets certain further constraints.]</p>
<p>各XML文書は、論理構造と物理構造を併せ持っている。物理的には、文書は<a title="実体" href="#dt-entity">実体</a>と呼ばれる単位から成る。実体は、文書中に取り込む為に他の実体を<a title="実体参照" href="#dt-entref">参照</a>しても良い。文書は「ルート」、即ち<a title="文書実体" href="#dt-docent">文書実体</a>から始まる。論理的には、文書は宣言、要素、コメント、文字参照、そして処理命令から成り、これらはすべて文書の中で明示的にマークアップされて示される。論理構造や物理構造がネストする時は、<a href="#wf-entities"><b>4.3.2 整形式の解析対象実体<span class="original" lang="en" xml:lang="en"> Well-Formed Parsed Entities</span></b></a>で説明されるように、適切に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">ネストしなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">Each XML document has both a logical and a physical structure. Physically, the document is composed of units called <a title="Entity" href="#dt-entity">entities</a>. An entity may <a title="Entity Reference" href="#dt-entref">refer</a> to other entities to cause their inclusion in the document. A document begins in a "root" or <a title="Document Entity" href="#dt-docent">document entity</a>. Logically, the document is composed of declarations, elements, comments, character references, and processing instructions, all of which are indicated in the document by explicit markup. The logical and physical structures <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> nest properly, as described in <a href="#wf-entities"><b>4.3.2 Well-Formed Parsed Entities</b></a>.</p>

<div class="div2">
<h3><a name="sec-well-formed" id="sec-well-formed"></a>2.1 整形式のXML文書<span class="original" lang="en" xml:lang="en"> Well-Formed XML Documents</span></h3>
<p>[<a name="dt-wellformed" id="dt-wellformed" title="整形式性">Definition</a>: 次に挙げる条件をすべて満たす時、テキストオブジェクトは<b>整形式</b>XML文書となる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A textual object is a <b>well-formed</b> XML document if:]</p>
<ol class="enumar">
	<li>
		<p>全体として、<a href="#NT-document">document</a>生成規則にマッチする。</p>
		<p class="original" lang="en" xml:lang="en">Taken as a whole, it matches the production labeled <a href="#NT-document">document</a>.</p>
	</li>
	<li>
		<p>この仕様書が定めるすべての整形式性制約を満たす。</p>
		<p class="original" lang="en" xml:lang="en">It meets all the well-formedness constraints given in this specification.</p>
	</li>
	<li>
		<p>文書中で直接的あるいは間接的に参照されるすべての<a title="テキスト実体" href="#dt-parsedent">解析対象実体</a>がそれぞれ<a title="整形式性" href="#dt-wellformed">整形式</a>である。</p>
		<p class="original" lang="en" xml:lang="en">Each of the <a title="Text Entity" href="#dt-parsedent">parsed entities</a> which is referenced directly or indirectly within the document is <a title="Well-Formed" href="#dt-wellformed">well-formed</a>.</p>
	</li>
</ol>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>この翻訳版では、限定用法の"well-formed"に対して「整形式の」を、叙述用法の"well-formed"に対して「整形式である」などを、"well-formedness"に対して「整形式性」を使います。"well-formedness"に対して「整形式性」を使うのは少数派のようですが、この方が正確でしょう。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<h5><a name="document" id="document"></a>文書<span class="original" lang="en" xml:lang="en"> Document</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-document" id="NT-document"></a>[1]   </td>
		<td><code>document</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-prolog">prolog</a> <a href="#NT-element">element</a> <a href="#NT-Misc">Misc</a>* ) - ( <a href="#NT-Char">Char</a>* <a href="#NT-RestrictedChar">RestrictedChar</a> <a href="#NT-Char">Char</a>* )</code></td>
	</tr>
</tbody>
</table>
<p><a href="#NT-document">document</a>生成規則にマッチする事は、次の事をも暗に意味する。</p>
<p class="original" lang="en" xml:lang="en">Matching the <a href="#NT-document">document</a> production implies that:</p>
<ol class="enumar">
	<li>
		<p>一つ以上の<a title="要素" href="#dt-element">要素</a>を含む。</p>
		<p class="original" lang="en" xml:lang="en">It contains one or more <a title="Element" href="#dt-element">elements</a>.</p>
	</li>
	<li>
		<p>[<a name="dt-root" id="dt-root" title="ルート要素">定義</a>: <b>ルート</b>、あるいは文書要素と呼ばれる要素がただ一つのみ存在する。ルート要素は、自身の一部あるいは全部が他の要素の<a title="内容" href="#dt-content">内容</a>となる事が一切無い。] ルート要素以外のすべての要素は、その<a title="開始タグ" href="#dt-stag">開始タグ</a>が他の要素の内容に含まれた時、その<a title="終了タグ" href="#dt-etag">終了タグ</a>も同じ要素の内容に含まれる。もっと簡単に言えば、要素は開始タグと終了タグでその範囲が定められ、そして互いに適切にネストする。</p>
		<p class="original" lang="en" xml:lang="en">[Definition: There is exactly one element, called the <b>root</b>, or document element, no part of which appears in the <a title="Content" href="#dt-content">content</a> of any other element.] For all other elements, if the <a title="Start-Tag" href="#dt-stag">start-tag</a> is in the content of another element, the <a title="End Tag" href="#dt-etag">end-tag</a> is in the content of the same element. More simply stated, the elements, delimited by start- and end-tags, nest properly within each other.</p>
	</li>
</ol>
<p>[<a name="dt-parentchild" id="dt-parentchild" title="親と子">定義</a>: この結果、文書中に存在する非ルート要素<code>C</code>それぞれについて、他の要素<code>P</code>が存在すると考えられる。<code>C</code>が、<code>P</code>の内容に含まれるが、<code>P</code>の内容に含まれる他のすべての要素の内容には含まれない時、<code>P</code>は<code>C</code>の<b>親</b>と、<code>C</code>は<code>P</code>の<b>子</b>と呼ばれる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: As a consequence of this, for each non-root element <code>C</code> in the document, there is one other element <code>P</code> in the document such that <code>C</code> is in the content of <code>P</code>, but is not in the content of any other element that is in the content of <code>P</code>. <code>P</code> is referred to as the <b>parent</b> of <code>C</code>, and <code>C</code> as a <b>child</b> of <code>P</code>.]</p>
</div>

<div class="div2">
<h3><a name="charsets" id="charsets"></a>2.2 文字<span class="original" lang="en" xml:lang="en"> Characters</span></h3>
<p>[<a name="dt-text" id="dt-text" title="テキスト">定義</a>: 解析対象実体は<b>テキスト</b>、即ち一連の<a title="文字" href="#dt-character">文字</a>を含む。テキストはマークアップか文字データを表す。] [<a name="dt-character" id="dt-character" title="文字">定義</a>: <b>文字</b>は、ISO/IEC 10646 <a href="#ISO10646">[ISO/IEC 10646]</a>で定義されている、テキストを構成する最小単位である。使用が認められる文字は、タブ、キャリッジリターン、ラインフィード、及びUnicodeとISO/IEC 10646で使用を認められている文字である。<a href="#sec-existing-stds"><b>A.1 規範的な参考文献<span class="original" lang="en" xml:lang="en"> Normative References</span></b></a>で引用されているこれらの標準規格のバージョンは、この文書が用意された時点で最新のものである。これらの規格には、修正や改版によって、新たな文字が追加される事があるかも知れない。よって、XMLプロセッサは<a href="#NT-Char">Char</a>で指定される範囲に含まれるすべての文字を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">受け容れなければならない(MUST)</em>。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A parsed entity contains <b>text</b>, a sequence of <a title="Character" href="#dt-character">characters</a>, which may represent markup or character data.] [Definition: A <b>character</b> is an atomic unit of text as specified by ISO/IEC 10646 <a href="#ISO10646">[ISO/IEC 10646]</a>. Legal characters are tab, carriage return, line feed, and the legal characters of Unicode and ISO/IEC 10646. The versions of these standards cited in <a href="#sec-existing-stds"><b>A.1 Normative References</b></a> were current at the time this document was prepared. New characters may be added to these standards by amendments or new editions. Consequently, XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> accept any character in the range specified for <a href="#NT-Char">Char</a>.]</p>
<h5><a name="char32" id="char32"></a>文字の範囲<span class="original" lang="en" xml:lang="en"> Character Range</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Char" id="NT-Char"></a>[2]   </td>
		<td><code>Char</code></td>
		<td>   ::=   </td>
		<td><code>[#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]</code></td>
		<td><i>/* サロゲートブロック、FFFE、FFFFを除くすべてのUnicode文字。<span class="original" lang="en" xml:lang="en"> any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.</span> */</i></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-RestrictedChar" id="NT-RestrictedChar"></a>[2a]   </td>
		<td><code>RestrictedChar</code></td>
		<td>   ::=   </td>
		<td><code>[#x1-#x8] | [#xB-#xC] | [#xE-#x1F] | [#x7F-#x84] | [#x86-#x9F]</code></td>
	</tr>
</tbody>
</table>
<p>文字コード点をビットパターンにエンコードする機構は、実体によって異なっていても良い。すべてのXMLプロセッサは、Unicode <a href="#Unicode">[Unicode]</a>のUTF-8エンコーディングとUTF-16エンコーディングを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">受け容れなければならない(MUST)</em>。二つのエンコーディングのどちらが使われているかを知らせる機構や、他のエンコーディングを使う為の機構については、<a href="#charencoding"><b>4.3.3 実体で使われる文字エンコーディング<span class="original" lang="en" xml:lang="en"> Character Encoding in Entities</span></b></a>で取り扱う。</p>
<p class="original" lang="en" xml:lang="en">The mechanism for encoding character code points into bit patterns may vary from entity to entity. All XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> accept the UTF-8 and UTF-16 encodings of Unicode <a href="#Unicode">[Unicode]</a>; the mechanisms for signaling which of the two is in use, or for bringing other encodings into play, are discussed later, in <a href="#charencoding"><b>4.3.3 Character Encoding in Entities</b></a>.</p>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p>文書の著者には、Unicode <a href="#Unicode">[Unicode]</a>で定義されている「互換性文字」を使わない事をお勧めする。次の範囲にある文字も、使用を避けた方が良い。これらの文字は制御文字であるか、この先永遠に定義される事が無いUnicode文字である。</p>
	<p class="original" lang="en" xml:lang="en">Document authors are encouraged to avoid "compatibility characters", as defined in Unicode <a href="#Unicode">[Unicode]</a>. The characters defined in the following ranges are also discouraged. They are either control characters or permanently undefined Unicode characters:</p>
	<div class="exampleInner">
<pre>
[#x1-#x8], [#xB-#xC], [#xE-#x1F], [#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
[#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
[#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
[#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
[#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
[#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF],
[#x10FFFE-#x10FFFF].
</pre>
	</div>
</div>
</div>

<div class="div2">
<h3><a name="sec-common-syn" id="sec-common-syn"></a>2.3 一般的な構文構成子<span class="original" lang="en" xml:lang="en"> Common Syntactic Constructs</span></h3>
<p>このセクションでは、XMLの文法で広く使われるシンボルを定義する。</p>
<p class="original" lang="en" xml:lang="en">This section defines some symbols used widely in the grammar.</p>
<p><a href="#NT-S">S</a>(ホワイトスペース)は、一つ以上のスペース文字(#x20)、キャリッジリターン、ラインフィード、タブから成る。</p>
<p class="original" lang="en" xml:lang="en"><a href="#NT-S">S</a> (white space) consists of one or more space (#x20) characters, carriage returns, line feeds, or tabs.</p>
<h5><a name="white" id="white"></a>ホワイトスペース<span class="original" lang="en" xml:lang="en"> White Space</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-S" id="NT-S"></a>[3]   </td>
		<td><code>S</code></td>
		<td>   ::=   </td>
		<td><code>( #x20 | #x9 | #xD | #xA )+</code></td>
	</tr>
</tbody>
</table>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p>上記の生成規則に#xDが含まれているのは、ただ単に<a href="http://www.w3.org/TR/1998/REC-xml-19980210">XML 1.0の第一版</a>との後方互換性を確保する為である。<a href="#sec-line-ends"><b>2.11 行末の取り扱い<span class="original" lang="en" xml:lang="en"> End-of-Line Handling</span></b></a>で説明されているように、XML文書に直接現れる#xD文字は、他の処理をするよりも前に、除去されるか、あるいは#xA文字に置換される。#xD文字をこの生成規則にマッチさせる唯一の方法は、実体値リテラルの中で文字参照を使う事である。</p>
	<p class="original" lang="en" xml:lang="en">The presence of #xD in the above production is maintained purely for backward compatibility with the <a href="http://www.w3.org/TR/1998/REC-xml-19980210">First Edition</a>. As explained in <a href="#sec-line-ends"><b>2.11 End-of-Line Handling</b></a>, all #xD characters literally present in an XML document are either removed or replaced by #xA characters before any other processing is done. The only way to get a #xD character to match this production is to use a character reference in an entity value literal.</p>
</div>
<p>[<a name="dt-name" id="dt-name" title="名前">定義</a>: <b>Name</b>(名前)は、レター一つあるいは限られた種類の句読点一つから始まり、複数のレター、数字、ハイフン、アンダースコア、コロン、終止符が続くトークンである。これらの文字は名前文字として知られる。] 文字列"<code>xml</code>"から始まる名前や、<code>(('X'|'x')('M'|'m')('L'|'l'))</code>にマッチする文字列から始まる名前は、この仕様書のこのバージョン及び将来のバージョンにおける標準化の為に予約されている。</p>
<p class="original" lang="en" xml:lang="en">[Definition: A <b>Name</b> is a token beginning with a letter or one of a few punctuation characters, and continuing with letters, digits, hyphens, underscores, colons, or full stops, together known as name characters.] Names beginning with the string "<code>xml</code>", or with any string which would match <code>(('X'|'x') ('M'|'m') ('L'|'l'))</code>, are reserved for standardization in this or future versions of this specification.</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>このレター(letter)は、勿論手紙の事ではなく文字の事ですが、ここでは単に文字(character)と置き換えられるものではなく、表音文字や表意文字を指しています。表音文字には、各国語のアルファベット的文字、例えばラテン文字の大文字や小文字、日本語の平仮名や片仮名などがあり、表意文字には日本語の漢字などがあります。数字(digit)もアラビア数字のみを指しているのではなく、各国語の数字的文字を含みます(日本語の漢数字は漢字に分類され、レターに含まれます)。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p>勧告文書Napespaces in XML <a href="#xml-names">[XML Names]</a>で、コロンを含む名前に特殊な意味を割り当てている。それ故、文書の著者が、名前空間として使う以外の目的でコロンをXML名前に使う事は望ましくない。しかし、XMLプロセッサは、コロンを名前文字として受け容れなければならない。</p>
	<p class="original" lang="en" xml:lang="en">The Namespaces in XML Recommendation <a href="#xml-names">[XML Names]</a> assigns a meaning to names containing colon characters. Therefore, authors should not use the colon in XML names except for namespace purposes, but XML processors must accept the colon as a name character.</p>
</div>
<p><a href="#NT-Nmtoken">Nmtoken</a>(名前トークン)は名前文字を任意に組み合わせたものである。</p>
<p class="original" lang="en" xml:lang="en">An <a href="#NT-Nmtoken">Nmtoken</a> (name token) is any mixture of name characters.</p>
<p>Nameの最初の文字はNameStartCharで<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">なければならい(MUST)</em>。同時に、名前の二文字目以降の文字はNameCharで<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">なければならない(MUST)</em>。この機構が使われるのは、ASCIIの欧州数字や、基本的結合文字から始まる事を避ける為である。名前に使える文字は、区切り子として使われるもの、あるいは区切り子として使われたとしても合理的なものを除く殆どすべての文字である。その意図は排他的ではなく非排他的であり、まだUnicodeでエンコードされていない記述体系もXML名前で使えるようにする為のものである。なお、新しいXML名前を作る際には<a href="#sec-suggested-names"><b>I XML名前の為の提案<span class="original" lang="en" xml:lang="en"> Suggestions for XML Names</span></b></a>を参照してほしい。</p>
<p class="original" lang="en" xml:lang="en">The first character of a Name <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be a NameStartChar, and any other characters <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be NameChars; this mechanism is used to prevent names from beginning with European (ASCII) digits or with basic combining characters. Almost all characters are permitted in names, except those which either are or reasonably could be used as delimiters. The intention is to be inclusive rather than exclusive, so that writing systems not yet encoded in Unicode can be used in XML names. See <a href="#sec-suggested-names"><b>I Suggestions for XML Names</b></a> for suggestions on the creation of names.</p>
<p>文書の著者には、自然言語において意味のある単語、あるいはその組み合わせを名前に使い、シンボル的な文字や、ホワイトスペース文字を使う事は避ける事をお勧めする。COLON(コロン)、HYPHEN-MINUS(マイナスのハイフン)、FULL STOP(ピリオド)、LOW LINE(アンダースコア)、MIDDLE DOT(ミドルドット(#xB7)、即ち'&#xB7;')が明示的に許可されている事にも注意してほしい。</p>
<p class="original" lang="en" xml:lang="en">Document authors are encouraged to use names which are meaningful words or combinations of words in natural languages, and to avoid symbolic or white space characters in names. Note that COLON, HYPHEN-MINUS, FULL STOP (period), LOW LINE (underscore), and MIDDLE DOT are explicitly permitted.</p>
<p>ASCIIのシンボルや句読点、そしてUnicodeのかなり大きなグループであるシンボル文字グループに含まれる文字は、名前に使う事が許されない。これは、XML文書の外でXML名前が使われる文脈で、これらの文字が区切り子として使えた方が便利だからである。このグループの文字を区切り子にすれば、そのような文脈に、XML名前に<em>なり得ない</em>ものについての確かな保証を与える事ができる。GREEK QUESTION MARK(ギリシャ語の疑問符(#x037E)、即ち'&#x037E;')も名前に使う事が許されない。もし許せば、この文字は正規化された時セミコロンになり、実体参照の意味を変えてしまう為である。</p>
<p class="original" lang="en" xml:lang="en">The ASCII symbols and punctuation marks, along with a fairly large group of Unicode symbol characters, are excluded from names because they are more useful as delimiters in contexts where XML names are used outside XML documents; providing this group gives those contexts hard guarantees about what <em>cannot</em> be part of an XML name. The character #x037E, GREEK QUESTION MARK, is excluded because when normalized it becomes a semicolon, which could change the meaning of entity references.</p>
<h5><a name="IDAKUDS" id="IDAKUDS"></a>名前とトークン<span class="original" lang="en" xml:lang="en"> Names and Tokens</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-NameStartChar" id="NT-NameStartChar"></a>[4]   </td>
		<td><code>NameStartChar</code></td>
		<td>   ::=   </td>
		<td><code>":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-NameChar" id="NT-NameChar"></a>[4a]   </td>
		<td><code>NameChar</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-NameStartChar">NameStartChar</a> | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Name" id="NT-Name"></a>[5]   </td>
		<td><code>Name</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-NameStartChar">NameStartChar</a> ( <a href="#NT-NameChar">NameChar</a> )*</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Names" id="NT-Names"></a>[6]   </td>
		<td><code>Names</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Name">Name</a> ( #x20 <a href="#NT-Name">Name</a> )*</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Nmtoken" id="NT-Nmtoken"></a>[7]   </td>
		<td><code>Nmtoken</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-NameChar">NameChar</a> )+</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Nmtokens" id="NT-Nmtokens"></a>[8]   </td>
		<td><code>Nmtokens</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Nmtoken">Nmtoken</a> ( #x20 <a href="#NT-Nmtoken">Nmtoken</a> )*</code></td>
	</tr>
</tbody>
</table>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p><a href="#NT-Names">Names</a>及び<a href="#NT-Nmtokens">Nmtokens</a>生成規則は、正規化後のトークン化された属性値の妥当性を定義する為に使われる。<a href="#sec-attribute-types"><b>3.3.1 属性型<span class="original" lang="en" xml:lang="en"> Attribute Types</span></b></a>を参照してほしい。</p>
	<p class="original" lang="en" xml:lang="en">The <a href="#NT-Names">Names</a> and <a href="#NT-Nmtokens">Nmtokens</a> productions are used to define the validity of tokenized attribute values after normalization (see <a href="#sec-attribute-types"><b>3.3.1 Attribute Types</b></a>).</p>
</div>
<p>リテラルデータは、引用符で括られた文字列である。但し、文字列の区切り子として使われている引用符をその中に含む事はできない。リテラルは内部エンティティの内容(<a href="#NT-EntityValue">EntityValue</a>)や、属性の値(<a href="#NT-AttValue">AttValue</a>)、外部識別子(<a href="#NT-SystemLiteral">SystemLiteral</a>)を指定する為に使われる。<a href="#NT-SystemLiteral">SystemLiteral</a>はマークアップを走査せずに解析され得る事に注意してほしい。</p>
<p class="original" lang="en" xml:lang="en">Literal data is any quoted string not containing the quotation mark used as a delimiter for that string. Literals are used for specifying the content of internal entities (<a href="#NT-EntityValue">EntityValue</a>), the values of attributes (<a href="#NT-AttValue">AttValue</a>), and external identifiers (<a href="#NT-SystemLiteral">SystemLiteral</a>). Note that a <a href="#NT-SystemLiteral">SystemLiteral</a> can be parsed without scanning for markup.</p>
<h5><a name="IDAKYDS" id="IDAKYDS"></a>リテラル<span class="original" lang="en" xml:lang="en"> Literals</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EntityValue" id="NT-EntityValue"></a>[9]   </td>
		<td><code>EntityValue</code></td>
		<td>   ::=   </td>
		<td><code>'"' ( [^%&amp;"] | <a href="#NT-PEReference">PEReference</a> | <a href="#NT-Reference">Reference</a> )* '"'</code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>|  "'" ( [^%&amp;'] | <a href="#NT-PEReference">PEReference</a> | <a href="#NT-Reference">Reference</a> )* "'"</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-AttValue" id="NT-AttValue"></a>[10]   </td>
		<td><code>AttValue</code></td>
		<td>   ::=   </td>
		<td><code>'"' ( [^&lt;&amp;"] | <a href="#NT-Reference">Reference</a> )* '"'</code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>|  "'" ( [^&lt;&amp;'] | <a href="#NT-Reference">Reference</a> )* "'"</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-SystemLiteral" id="NT-SystemLiteral"></a>[11]   </td>
		<td><code>SystemLiteral</code></td>
		<td>   ::=   </td>
		<td><code>( '"' [^"]* '"' ) | ( "'" [^']* "'" )</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-PubidLiteral" id="NT-PubidLiteral"></a>[12]   </td>
		<td><code>PubidLiteral</code></td>
		<td>   ::=   </td>
		<td><code>'"' <a href="#NT-PubidChar">PubidChar</a>* '"' | "'" ( <a href="#NT-PubidChar">PubidChar</a> - "'" )* "'"</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-PubidChar" id="NT-PubidChar"></a>[13]   </td>
		<td><code>PubidChar</code></td>
		<td>   ::=   </td>
		<td><code>#x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]</code></td>
	</tr>
</tbody>
</table>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p><a href="#NT-EntityValue">EntityValue</a>生成規則は、単独の<code>&lt;</code>を直接の値とする一般実体の定義(例えば<code>&lt;!ENTITY mylt "&lt;"&gt;</code>)を許してしまうが、このような実体を実際に定義する事は避けるよう強くお薦めする。その実体への参照が整形式性制約エラーを引き起こしてしまうからである。</p>
	<p class="original" lang="en" xml:lang="en">Although the <a href="#NT-EntityValue">EntityValue</a> production allows the definition of a general entity consisting of a single explicit <code>&lt;</code> in the literal (e.g., <code>&lt;!ENTITY mylt "&lt;"&gt;</code>), it is strongly advised to avoid this practice since any reference to that entity will cause a well-formedness error.</p>
</div>
</div>

<div class="div2">
<h3><a name="syntax" id="syntax"></a>2.4 文字データとマークアップ<span class="original" lang="en" xml:lang="en"> Character Data and Markup</span></h3>
<p><a title="テキスト" href="#dt-text">テキスト</a>は<a title="文字データ" href="#dt-chardata">文字データ</a>とマークアップを混ぜ合わせたものから成る。 [<a name="dt-markup" id="dt-markup" title="Markup">定義</a>: <b>マークアップ</b>は、次のような形態を採る。<a title="開始タグ" href="#dt-stag">開始タグ</a>、<a title="終了タグ" href="#dt-etag">終了タグ</a>、<a title="空" href="#dt-empty">空要素タグ</a>、<a title="実体参照" href="#dt-entref">実体参照</a>、<a title="文字参照" href="#dt-charref">文字参照</a>、<a title="コメント" href="#dt-comment">コメント</a>、<a title="CDATAセクション" href="#dt-cdsection">CDATAセクション</a>区切り子、<a title="文書型宣言" href="#dt-doctype">文書型宣言</a>、<a title="処理命令" href="#dt-pi">処理命令</a>、<a href="#NT-XMLDecl">XML宣言</a>、<a href="#NT-TextDecl">テキスト宣言</a>、そして文書実体の最上層(つまり、文書要素の外かつ他のすべてのマークアップに含まれない場所)にあるホワイトスペース。]</p>
<p class="original" lang="en" xml:lang="en"><a title="Text" href="#dt-text">Text</a> consists of intermingled <a title="Character Data" href="#dt-chardata">character data</a> and markup. [Definition: <b>Markup</b> takes the form of <a title="Start-Tag" href="#dt-stag">start-tags</a>, <a title="End Tag" href="#dt-etag">end-tags</a>, <a title="Empty" href="#dt-empty">empty-element tags</a>, <a title="Entity Reference" href="#dt-entref">entity references</a>, <a title="Character Reference" href="#dt-charref">character references</a>, <a title="Comment" href="#dt-comment">comments</a>, <a title="CDATA Section" href="#dt-cdsection">CDATA section</a> delimiters, <a title="Document Type Declaration" href="#dt-doctype">document type declarations</a>, <a title="Processing instruction" href="#dt-pi">processing instructions</a>, <a href="#NT-XMLDecl">XML declarations</a>, <a href="#NT-TextDecl">text declarations</a>, and any white space that is at the top level of the document entity (that is, outside the document element and not inside any other markup).]</p>
<p>[<a name="dt-chardata" id="dt-chardata" title="文字データ">定義</a>: マークアップでないすべてのテキストは文書の<b>文字データ</b>を成す。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: All text that is not markup constitutes the <b>character data</b> of the document.]</p>
<p>アンパサンド文字(&amp;)と左山括弧(&lt;)は、マークアップ区切り子として使われる場合、あるいは<a title="コメント" href="#dt-comment">コメント</a>、<a title="処理命令" href="#dt-pi">処理命令</a>、<a title="CDATAセクション" href="#dt-cdsection">CDATAセクション</a>の中に現れる場合を除き、直接<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。もしそれらの文字を他の場所で使わなければならない場合は、<a title="文字参照" href="#dt-charref">数値による文字参照</a>を使うか、それぞれ文字列"<code>&amp;amp;</code>"と"<code>&amp;lt;</code>"を使うかして<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="エスケープ" href="#dt-escape">エスケープ</a>しなければならない(MUST)</em>。右山括弧(&gt;)は、通常はそうする必要は無いが、文字列"<code>&amp;gt;</code>"で表しても良い。但し、文字列"<code>]]&gt;</code>"が<a title="CDATAセクション" href="#dt-cdsection">CDATAセクション</a>の終わりを意味する為に現れたのでなければ、<a title="互換性の為に" href="#dt-compat">互換性の為に</a>、その文字列の中に現れる右山括弧を"<code>&amp;gt;</code>"か文字参照を使って<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">エスケープしなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">The ampersand character (&amp;) and the left angle bracket (&lt;) <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear in their literal form, except when used as markup delimiters, or within a <a title="Comment" href="#dt-comment">comment</a>, a <a title="Processing instruction" href="#dt-pi">processing instruction</a>, or a <a title="CDATA Section" href="#dt-cdsection">CDATA section</a>. If they are needed elsewhere, they <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be <a title="escape" href="#dt-escape">escaped</a> using either <a title="Character Reference" href="#dt-charref">numeric character references</a> or the strings "<code>&amp;amp;</code>" and "<code>&amp;lt;</code>" respectively. The right angle bracket (&gt;) may be represented using the string "<code>&amp;gt;</code>", and <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em>, <a title="For Compatibility" href="#dt-compat">for compatibility</a>, be escaped using either "<code>&amp;gt;</code>" or a character reference when it appears in the string "<code>]]&gt;</code>" in content, when that string is not marking the end of a <a title="CDATA Section" href="#dt-cdsection">CDATA section</a>.</p>
<p>要素の内容では、文字データは、あらゆる種類のマークアップの開始区切り子やCDATAセクション終了区切り子("]]&gt;")を含まない、ありとあらゆる文字列である。CDATAセクションでは、文字データは、CDATAセクション終了区切り子を含まない、ありとあらゆる文字列である。</p>
<p class="original" lang="en" xml:lang="en">In the content of elements, character data is any string of characters which does not contain the start-delimiter of any markup or the CDATA-section-close delimiter, "<code>]]&gt;</code>". In a CDATA section, character data is any string of characters not including the CDATA-section-close delimiter.</p>
<p>属性値に単引用符と二重引用符を両方含ませる為に、アポストロフィあるいは単引用符(')を"<code>&amp;apos;</code>"で、二重引用符(")を"<code>&amp;quot;</code>"で表す事がよくある。</p>
<p class="original" lang="en" xml:lang="en">To allow attribute values to contain both single and double quotes, the apostrophe or single-quote character (') may be represented as "<code>&amp;apos;</code>", and the double-quote character (") as "<code>&amp;quot;</code>".</p>
<h5><a name="IDAABES" id="IDAABES"></a>文字データ<span class="original" lang="en" xml:lang="en"> Character Data</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-CharData" id="NT-CharData"></a>[14]   </td>
		<td><code>CharData</code></td>
		<td>   ::=   </td>
		<td><code>[^&lt;&amp;]* - ( [^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]* )</code></td>
	</tr>
</tbody>
</table>
</div>

<div class="div2">
<h3><a name="sec-comments" id="sec-comments"></a>2.5 コメント<span class="original" lang="en" xml:lang="en"> Comments</span></h3>
<p>[<a name="dt-comment" id="dt-comment" title="コメント">定義</a>: <b>コメント</b>は、他の<a title="マークアップ" href="#dt-markup">マークアップ</a>の外になら、どこに現れても良い。加えて、文書型宣言の中にも、文法が許す場所になら現れて良い。コメントは文書の<a title="文字データ" href="#dt-chardata">文字データ</a>の一部ではない。故に、XMLプロセッサはコメントに含まれるテキストをアプリケーションが受け取れるように<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しても良い(MAY)</em>が、必ずしもそうする必要は無い。<a title="互換性の為に" href="#dt-compat">互換性の為に</a>、文字列"<code>--</code>"(二つのハイフン)はコメントの中に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。] コメントの中では、パラメータ実体参照を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">認識してはならない(MUST NOT)</em>。</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Comments</b> may appear anywhere in a document outside other <a title="Markup" href="#dt-markup">markup</a>; in addition, they may appear within the document type declaration at places allowed by the grammar. They are not part of the document's <a title="Character Data" href="#dt-chardata">character data</a>; an XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em>, but need not, make it possible for an application to retrieve the text of comments. <a title="For Compatibility" href="#dt-compat">For compatibility</a>, the string "<code>--</code>" (double-hyphen) <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> occur within comments.] Parameter entity references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> be recognized within comments.</p>
<h5><a name="IDA5CES" id="IDA5CES"></a>コメント<span class="original" lang="en" xml:lang="en"> Comments</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Comment" id="NT-Comment"></a>[15]   </td>
		<td><code>Comment</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!--' ( ( <a href="#NT-Char">Char</a> - '-' ) | ( '-' ( <a href="#NT-Char">Char</a> - '-' ) ) )* '--&gt;'</code></td>
	</tr>
</tbody>
</table>
<p>コメントの一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">An example of a comment:</p>
<div class="exampleInner">
<pre>
&lt;!-- declarations for &lt;head&gt; &amp; &lt;body&gt; --&gt;
</pre>
</div>
<p><code>---&gt;</code>で終わるコメントは文法的に許されない事に注意してほしい。次の例は整形式<em>ではない</em>。</p>
<p class="original" lang="en" xml:lang="en">Note that the grammar does not allow a comment ending in <code>---&gt;</code>. The following example is <em>not</em> well-formed.</p>
<div class="exampleInner">
<pre>
&lt;!-- B+, B, or B---&gt;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="sec-pi" id="sec-pi"></a>2.6 処理命令<span class="original" lang="en" xml:lang="en"> Processing Instructions</span></h3>
<p>[<a name="dt-pi" id="dt-pi" title="処理命令">定義</a>: <b>処理命令</b>(PIと略される事もある)は、文書中にアプリケーションへの命令を記述するものである。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Processing instructions</b> (PIs) allow documents to contain instructions for applications.]</p>
<h5><a name="IDAREES" id="IDAREES"></a>処理命令<span class="original" lang="en" xml:lang="en"> Processing Instructions</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-PI" id="NT-PI"></a>[16]   </td>
		<td><code>PI</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;?' <a href="#NT-PITarget">PITarget</a> ( <a href="#NT-S">S</a> ( <a href="#NT-Char">Char</a>* - ( <a href="#NT-Char">Char</a>* '?&gt;' <a href="#NT-Char">Char</a>* ) ) )? '?&gt;'</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-PITarget" id="NT-PITarget"></a>[17]   </td>
		<td><code>PITarget</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Name">Name</a> - ( ( 'X' | 'x' ) ( 'M' | 'm' ) ( 'L' | 'l' ) )</code></td>
	</tr>
</tbody>
</table>
<p>処理命令は文書の<a title="文字データ" href="#dt-chardata">文字データ</a>の一部ではないが、アプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">渡されなければならない(MUST)</em>。処理命令は、命令を与えるアプリケーションを識別する為に使われる対象(<a href="#NT-PITarget">PITarget</a>)から始まる。"<code>XML</code>"や"<code>xml</code>"などの対象名は、この仕様書のこのバージョン及び将来のバージョンにおける標準化の為に予約されている。処理命令対象の正式な宣言の為に、XML<a title="記法" href="#dt-notation">記法</a>機構が使われる事もある。処理命令の中では、パラメータ実体参照を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">認識してはならない(MUST NOT)</em>。</p>
<p class="original" lang="en" xml:lang="en">PIs are not part of the document's <a title="Character Data" href="#dt-chardata">character data</a>, but <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be passed through to the application. The PI begins with a target (<a href="#NT-PITarget">PITarget</a>) used to identify the application to which the instruction is directed. The target names "<code>XML</code>", "<code>xml</code>", and so on are reserved for standardization in this or future versions of this specification. The XML <a title="Notation" href="#dt-notation">Notation</a> mechanism may be used for formal declaration of PI targets. Parameter entity references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> be recognized within processing instructions.</p>
</div>

<div class="div2">
<h3><a name="sec-cdata-sect" id="sec-cdata-sect"></a>2.7 CDATAセクション<span class="original" lang="en" xml:lang="en"> CDATA Sections</span></h3>
<p>[<a name="dt-cdsection" id="dt-cdsection" title="CDATAセクション">定義</a>: <b>CDATAセクション</b>は、文字データが現れて良い所なら、どこに現れても良い。CDATAセクションは、そのままではマークアップと認識されてしまう文字を含むテキストをエスケープする為に使われる。CDATAセクションは文字列"<code>&lt;![CDATA[</code>"から始まり、文字列"<code>]]&gt;</code>"で終わる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>CDATA sections</b> may occur anywhere character data may occur; they are used to escape blocks of text containing characters which would otherwise be recognized as markup. CDATA sections begin with the string "<code>&lt;![CDATA[</code>" and end with the string "<code>]]&gt;</code>":]</p>
<h5><a name="IDA2HES" id="IDA2HES"></a>CDATAセクション<span class="original" lang="en" xml:lang="en"> CDATA Sections</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-CDSect" id="NT-CDSect"></a>[18]   </td>
		<td><code>CDSect</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-CDStart">CDStart</a> <a href="#NT-CData">CData</a> <a href="#NT-CDEnd">CDEnd</a></code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-CDStart" id="NT-CDStart"></a>[19]   </td>
		<td><code>CDStart</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;![CDATA['</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-CData" id="NT-CData"></a>[20]   </td>
		<td><code>CData</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-Char">Char</a>* - ( <a href="#NT-Char">Char</a>* ']]&gt;' <a href="#NT-Char">Char</a>* ) )</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-CDEnd" id="NT-CDEnd"></a>[21]   </td>
		<td><code>CDEnd</code></td>
		<td>   ::=   </td>
		<td><code>']]&gt;'</code></td>
	</tr>
</tbody>
</table>
<p>CDATAセクションの中では、<a href="#NT-CDEnd">CDEnd</a>文字列だけが唯一マークアップとして認識される。この為、左山括弧とアンパサンドは直接現れて良い。つまり、"<code>&amp;lt;</code>"や"<code>&amp;amp;</code>"などとエスケープされなくて良いし、される事もできない。CDATAセクションはネストできない。</p>
<p class="original" lang="en" xml:lang="en">Within a CDATA section, only the <a href="#NT-CDEnd">CDEnd</a> string is recognized as markup, so that left angle brackets and ampersands may occur in their literal form; they need not (and cannot) be escaped using "<code>&amp;lt;</code>" and "<code>&amp;amp;</code>". CDATA sections cannot nest.</p>
<p>CDATAセクションの一例を挙げる。ここでは"<code>&lt;greeting&gt;</code>"と"<code>&lt;/greeting&gt;</code>"は、<a title="マークアップ" href="#dt-markup">マークアップ</a>ではなく<a title="文字データ" href="#dt-chardata">文字データ</a>であると認識される。</p>
<p class="original" lang="en" xml:lang="en">An example of a CDATA section, in which "<code>&lt;greeting&gt;</code>" and "<code>&lt;/greeting&gt;</code>" are recognized as <a title="Character Data" href="#dt-chardata">character data</a>, not <a title="Markup" href="#dt-markup">markup</a>:</p>
<div class="exampleInner">
<pre>
&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="sec-prolog-dtd" id="sec-prolog-dtd"></a>2.8 プロローグと文書型宣言<span class="original" lang="en" xml:lang="en"> Prolog and Document Type Declaration</span></h3>
<p>[<a name="dt-xmldecl" id="dt-xmldecl" title="XML宣言">Definition</a>: XML 1.1文書は、使われるXMLのバージョンを指定する<b>XML宣言</b>から<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">始まらなければならない(MUST)</em>。] 例えば、次に挙げるのは完全なXML 1.1文書である。これは<a title="整形式性" href="#dt-wellformed">整形式</a>であるが<a title="妥当性" href="#dt-valid">妥当</a>ではない。</p>
<p class="original" lang="en" xml:lang="en">[Definition: XML 1.1 documents <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> begin with an <b>XML declaration</b> which specifies the version of XML being used.] For example, the following is a complete XML 1.1 document, <a title="Well-Formed" href="#dt-wellformed">well-formed</a> but not <a title="Validity" href="#dt-valid">valid</a>:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.1"?&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>
</div>
<p>しかし、次に挙げるものは、XML宣言を持っていない為、XML 1.0文書である。</p>
<p class="original" lang="en" xml:lang="en">but the following is an XML 1.0 document because it does not have an XML declaration:</p>
<div class="exampleInner">
<pre>&lt;greeting&gt;Hello, world!&lt;/greeting&gt;</pre>
</div>
<p>XML文書におけるマークアップの役割は、記録の構造と論理構造を記述し、属性の名前と値のペアを論理構造に関連付ける事である。XMLは、論理構造に制約を課し、定義済みの記録単位の使用を助ける機構である<a title="文書型宣言" href="#dt-doctype">文書型宣言</a>を提供する。 [<a name="dt-valid" id="dt-valid" title="妥当性">定義</a>: XML文書は、関連付けられる文書型宣言を持ち、かつその文書型が課す制約に従う時、<b>妥当</b>となる。]</p>
<p class="original" lang="en" xml:lang="en">The function of the markup in an XML document is to describe its storage and logical structure and to associate attribute name-value pairs with its logical structures. XML provides a mechanism, the <a title="Document Type Declaration" href="#dt-doctype">document type declaration</a>, to define constraints on the logical structure and to support the use of predefined storage units. [Definition: An XML document is <b>valid</b> if it has an associated document type declaration and if the document complies with the constraints expressed in it.]</p>
<p>文書型宣言は、文書中で最初に現れる<a title="要素" href="#dt-element">要素</a>よりも前に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">The document type declaration <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> appear before the first <a title="Element" href="#dt-element">element</a> in the document.</p>
<h5><a name="xmldoc" id="xmldoc"></a>プロローグ<span class="original" lang="en" xml:lang="en"> Prolog</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-prolog" id="NT-prolog"></a>[22]   </td>
		<td><code>prolog</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-XMLDecl">XMLDecl</a> <a href="#NT-Misc">Misc</a>* ( <a href="#NT-doctypedecl">doctypedecl</a> <a href="#NT-Misc">Misc</a>* )?</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-XMLDecl" id="NT-XMLDecl"></a>[23]   </td>
		<td><code>XMLDecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;?xml' <a href="#NT-VersionInfo">VersionInfo</a> <a href="#NT-EncodingDecl">EncodingDecl</a>? <a href="#NT-SDDecl">SDDecl</a>? <a href="#NT-S">S</a>? '?&gt;'</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-VersionInfo" id="NT-VersionInfo"></a>[24]   </td>
		<td><code>VersionInfo</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-S">S</a> 'version' <a href="#NT-Eq">Eq</a> ( "'" <a href="#NT-VersionNum">VersionNum</a> "'" | '"' <a href="#NT-VersionNum">VersionNum</a> '"' )</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-Eq" id="NT-Eq"></a>[25]   </td>
		<td><code>Eq</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-S">S</a>? '=' <a href="#NT-S">S</a>?</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-VersionNum" id="NT-VersionNum"></a>[26]   </td>
		<td><code>VersionNum</code></td>
		<td>   ::=   </td>
		<td><code>'1.1'</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-Misc" id="NT-Misc"></a>[27]   </td>
		<td><code>Misc</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Comment">Comment</a> | <a href="#NT-PI">PI</a> | <a href="#NT-S">S</a></code></td>
	</tr>
</tbody>
</table>
<p>[<a name="dt-doctype" id="dt-doctype" title="文書型宣言">定義</a>: XML<b>文書型宣言</b>は、文書のクラスの文法を提供する<a title="マークアップ宣言" href="#dt-markupdecl">マークアップ宣言</a>を、含むか指すかする。この文法は、<b>DTD</b>(文書型定義)として知られる。文書型宣言は、マークアップ宣言を含む外部サブセット(特別な種類の<a title="外部実体" href="#dt-extent">外部実体</a>)を指しても良いし、内部サブセットの中に直接マークアップ宣言を含んでも良いし、その両方をやっても良い。文書が使うDTDは、それらのサブセットを両方併せたものとなる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: The XML <b>document type declaration</b> contains or points to <a title="markup declaration" href="#dt-markupdecl">markup declarations</a> that provide a grammar for a class of documents. This grammar is known as a document type definition, or <b>DTD</b>. The document type declaration can point to an external subset (a special kind of <a title="External Entity" href="#dt-extent">external entity</a>) containing markup declarations, or can contain the markup declarations directly in an internal subset, or can do both. The DTD for a document consists of both subsets taken together.]</p>
<p>[<a name="dt-markupdecl" id="dt-markupdecl" title="マークアップ宣言">定義</a>: <b>マークアップ宣言</b>は、<a title="要素型宣言" href="#dt-eldecl">要素型宣言</a>、<a title="属性リスト宣言" href="#dt-attdecl">属性リスト宣言</a>、<a title="実体宣言" href="#dt-entdecl">実体宣言</a>、<a title="記法宣言" href="#dt-notdecl">記法宣言</a>の何れかである。] これらの宣言は、この後で述べる整形式性制約や妥当性制約で説明されているように、宣言の一部あるいは全部が<a title="パラメータ実体" href="#dt-PE">パラメータ実体</a>に含まれても良い。更なる情報は、<a href="#sec-physical-struct"><b>4 物理構造<span class="original" lang="en" xml:lang="en"> Physical Structures</span></b></a>で確認してほしい。</p>
<p class="original" lang="en" xml:lang="en">[Definition: A <b>markup declaration</b> is an <a title="Element Type declaration" href="#dt-eldecl">element type declaration</a>, an <a title="Attribute-List Declaration" href="#dt-attdecl">attribute-list declaration</a>, an <a title="entity declaration" href="#dt-entdecl">entity declaration</a>, or a <a title="Notation Declaration" href="#dt-notdecl">notation declaration</a>.] These declarations may be contained in whole or in part within <a title="Parameter entity" href="#dt-PE">parameter entities</a>, as described in the well-formedness and validity constraints below. For further information, see <a href="#sec-physical-struct"><b>4 Physical Structures</b></a>.</p>
<h5><a name="dtd" id="dtd"></a>文書型定義<span class="original" lang="en" xml:lang="en"> Document Type Definition</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-doctypedecl" id="NT-doctypedecl"></a>[28]   </td>
		<td><code>doctypedecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!DOCTYPE' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a> ( <a href="#NT-S">S</a> <a href="#NT-ExternalID">ExternalID</a> )? <a href="#NT-S">S</a>? ( '[' <a href="#NT-intSubset">intSubset</a> ']' <a href="#NT-S">S</a>? )? '&gt;'</code></td>
		<td><a href="#vc-roottype">[妥当性制約: ルート要素の型]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#ExtSubset">[整形式性制約: 外部サブセット]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-DeclSep" id="NT-DeclSep"></a>[28a]   </td>
		<td><code>DeclSep</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-PEReference">PEReference</a> | <a href="#NT-S">S</a></code></td>
		<td><a href="#PE-between-Decls">[整形式性制約: 宣言の間のパラメータ実体]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-intSubset" id="NT-intSubset"></a>[28b]   </td>
		<td><code>intSubset</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-markupdecl">markupdecl</a> | <a href="#NT-DeclSep">DeclSep</a> )*</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-markupdecl" id="NT-markupdecl"></a>[29]   </td>
		<td><code>markupdecl</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-elementdecl">elementdecl</a> | <a href="#NT-AttlistDecl">AttlistDecl</a> | <a href="#NT-EntityDecl">EntityDecl</a> | <a href="#NT-NotationDecl">NotationDecl</a> | <a href="#NT-PI">PI</a> | <a href="#NT-Comment">Comment</a></code></td>
		<td><a href="#vc-PEinMarkupDecl">[妥当性制約: 宣言とパラメータ実体の適切なネスト]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#wfc-PEinInternalSubset">[整形式性制約: 内部サブセットの中のパラメータ実体]</a></td>
	</tr>
</tbody>
</table>
<p>外部サブセットを指さず、内部サブセットも含まない<a href="#NT-doctypedecl">doctypedecl</a>を含む整形式の文書を作る事も可能である事に注意してほしい。</p>
<p class="original" lang="en" xml:lang="en">Note that it is possible to construct a well-formed document containing a <a href="#NT-doctypedecl">doctypedecl</a> that neither points to an external subset nor contains an internal subset.</p>
<p>マークアップ宣言は、一部あるいは全部が<a title="パラメータ実体" href="#dt-PE">パラメータ実体</a>の<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>から作られても良い。この仕様書の後の方にある、各非終端シンボル(<a href="#NT-elementdecl">elementdecl</a>や<a href="#NT-AttlistDecl">AttlistDecl</a>など)の生成規則は、すべてのパラメータ実体が<a title="インクルードする" href="#dt-include">インクルード</a>された<em>後の</em>定義を記述する。</p>
<p class="original" lang="en" xml:lang="en">The markup declarations may be made up in whole or in part of the <a title="Replacement Text" href="#dt-repltext">replacement text</a> of <a title="Parameter entity" href="#dt-PE">parameter entities</a>. The productions later in this specification for individual nonterminals (<a href="#NT-elementdecl">elementdecl</a>, <a href="#NT-AttlistDecl">AttlistDecl</a>, and so on) describe the declarations <em>after</em> all the parameter entities have been <a title="Include" href="#dt-include">included</a>.</p>
<p>パラメータ実体参照は、DTD(内部及び外部サブセットと外部パラメータ実体)の中ならどこでも認識されるが、リテラル、処理命令、コメント、及び無視される条件付きセクション(<a href="#sec-condition-sect"><b>3.4 条件付きセクション<span class="original" lang="en" xml:lang="en"> Conditional Sections</span></b></a>参照)の中は例外である。実体値リテラルの中でも認識される。内部サブセットでのパラメータ実体の使用は、以下で説明されるように、制限される。</p>
<p class="original" lang="en" xml:lang="en">Parameter entity references are recognized anywhere in the DTD (internal and external subsets and external parameter entities), except in literals, processing instructions, comments, and the contents of ignored conditional sections (see <a href="#sec-condition-sect"><b>3.4 Conditional Sections</b></a>). They are also recognized in entity value literals. The use of parameter entities in the internal subset is restricted as described below.</p>
<div class="constraint">
	<p class="prefix"><a name="vc-roottype" id="vc-roottype"></a><b>妥当性制約: ルート要素の型<span class="original" lang="en" xml:lang="en"> Validity constraint: Root Element Type</span></b></p>
	<p>文書型宣言の<a href="#NT-Name">Name</a>は、<a title="ルート要素" href="#dt-root">ルート要素</a>の要素型に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The <a href="#NT-Name">Name</a> in the document type declaration <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the element type of the <a title="Root Element" href="#dt-root">root element</a>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="vc-PEinMarkupDecl" id="vc-PEinMarkupDecl"></a><b>妥当性制約: 宣言とパラメータ実体の適切なネスト<span class="original" lang="en" xml:lang="en"> Validity constraint: Proper Declaration/PE Nesting</span></b></p>
	<p>パラメータ実体の<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>は、マークアップ宣言に関して、適切に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">ネストされなければならない(MUST)</em>。それはつまり、マークアップ宣言(上記の<a href="#NT-markupdecl">markupdecl</a>)の最初の文字か最後の文字の何れかが<a title="パラメータ実体参照" href="#dt-PERef">パラメータ実体参照</a>の置換テキストに含まれる場合、両方とも同じ置換テキストの中に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まれなければならない(MUST)</em>という事である。</p>
	<p class="original" lang="en" xml:lang="en">Parameter-entity <a title="Replacement Text" href="#dt-repltext">replacement text</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be properly nested with markup declarations. That is to say, if either the first character or the last character of a markup declaration (<a href="#NT-markupdecl">markupdecl</a> above) is contained in the replacement text for a <a title="Parameter-entity reference" href="#dt-PERef">parameter-entity reference</a>, both <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be contained in the same replacement text.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="wfc-PEinInternalSubset" id="wfc-PEinInternalSubset"></a><b>整形式性制約: 内部サブセットの中のパラメータ実体<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: PEs in Internal Subset</span></b></p>
	<p>内部DTDサブセットの中では、<a title="パラメータ実体参照" href="#dt-PERef">パラメータ実体参照</a>はマークアップ宣言の中に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。マークアップ宣言が現れ得る場所に現れる事はあっても良い。この制約は、外部パラメータ実体の中に現れる参照や、外部サブセットには適用されない。</p>
	<p class="original" lang="en" xml:lang="en">In the internal DTD subset, <a title="Parameter-entity reference" href="#dt-PERef">parameter-entity references</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> occur within markup declarations; they may occur where markup declarations can occur. (This does not apply to references that occur in external parameter entities or to the external subset.)</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="ExtSubset" id="ExtSubset"></a><b>整形式性制約: 外部サブセット<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: External Subset</span></b></p>
	<p>外部サブセットを使用する場合は、その外部サブセットは生成規則<a href="#NT-extSubset">extSubset</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The external subset, if any, <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the production for <a href="#NT-extSubset">extSubset</a>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="PE-between-Decls" id="PE-between-Decls"></a><b>宣言の間のパラメータ実体<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: PE Between Declarations</span></b></p>
	<p><a href="#NT-DeclSep">DeclSep</a>のパラメータ実体参照の置換テキストは、生成規則<a href="#NT-extSubsetDecl">extSubsetDecl</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The replacement text of a parameter entity reference in a <a href="#NT-DeclSep">DeclSep</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the production <a href="#NT-extSubsetDecl">extSubsetDecl</a>.</p>
</div>
<p>内部サブセットと同様、外部サブセットや<a href="#NT-DeclSep">DeclSep</a>で参照される外部パラメータ実体は、一連の完全なマークアップ宣言から<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">成らなければならない(MUST)</em>。マークアップ宣言の間にはホワイトスペースや<a title="パラメータ実体参照" href="#dt-PERef">パラメータ実体参照</a>を交える事があるが、その宣言の種類は、非終端シンボル<a href="#NT-markupdecl">markupdecl</a>で許されているもので<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">なければならない(MUST)</em>。但し、外部サブセットの内容の一部や参照される外部パラメータ実体の内容の一部が、<a title="条件付きセクション" href="#dt-cond-section">条件付きセクション</a>構成子を使う事で条件に応じて無視される事はあっても良い。これは、内部サブセットでは使用する事ができないが、内部サブセットが参照する外部パラメータ実体では使用する事ができる。</p>
<p class="original" lang="en" xml:lang="en">Like the internal subset, the external subset and any external parameter entities referenced in a <a href="#NT-DeclSep">DeclSep</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> consist of a series of complete markup declarations of the types allowed by the non-terminal symbol <a href="#NT-markupdecl">markupdecl</a>, interspersed with white space or <a title="Parameter-entity reference" href="#dt-PERef">parameter-entity references</a>. However, portions of the contents of the external subset or of these external parameter entities may conditionally be ignored by using the <a title="conditional section" href="#dt-cond-section">conditional section</a> construct; this is not allowed in the internal subset but is allowed in external parameter entities referenced in the internal subset.</p>
<h5><a name="ext-Subset" id="ext-Subset"></a>外部サブセット<span class="original" lang="en" xml:lang="en"> External Subset</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-extSubset" id="NT-extSubset"></a>[30]   </td>
		<td><code>extSubset</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-TextDecl">TextDecl</a>? <a href="#NT-extSubsetDecl">extSubsetDecl</a></code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-extSubsetDecl" id="NT-extSubsetDecl"></a>[31]   </td>
		<td><code>extSubsetDecl</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-markupdecl">markupdecl</a> | <a href="#NT-conditionalSect">conditionalSect</a> | <a href="#NT-DeclSep">DeclSep</a> )*</code></td>
	</tr>
</tbody>
</table>
<p>外部サブセットと外部パラメータ実体は、<a title="パラメータ実体参照" href="#dt-PERef">パラメータ実体参照</a>が、マークアップ宣言<em>の間</em>だけではなくマークアップ宣言<em>の中</em>でも許されるという点においても、内部サブセットと異なる。</p>
<p class="original" lang="en" xml:lang="en">The external subset and external parameter entities also differ from the internal subset in that in them, <a title="Parameter-entity reference" href="#dt-PERef">parameter-entity references</a> are permitted <em>within</em> markup declarations, not only <em>between</em> markup declarations.</p>
<p>文書型宣言を持つXML文書の一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">An example of an XML document with a document type declaration:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.1"?&gt;
&lt;!DOCTYPE greeting SYSTEM "hello.dtd"&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>
</div>
<p><a title="システム識別子" href="#dt-sysid">システム識別子</a>"<code>hello.dtd</code>"は、文書に関連付けられるDTDのアドレスをURI参照で与える。</p>
<p class="original" lang="en" xml:lang="en">The <a title="System Identifier" href="#dt-sysid">system identifier</a> "<code>hello.dtd</code>" gives the address (a URI reference) of a DTD for the document.</p>
<p>文書型宣言は局所的に与えられても良い。例えば次のようにである。</p>
<p class="original" lang="en" xml:lang="en">The declarations can also be given locally, as in this example:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.1" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE greeting [
&lt;!ELEMENT greeting (#PCDATA)&gt;
]&gt;
&lt;greeting&gt;Hello, world!&lt;/greeting&gt;
</pre>
</div>
<p>外部サブセットと内部サブセットが両方使われた場合、内部サブセットは外部サブセットの前に現れると<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">見なされなければならない(MUST)</em>。これは、内部サブセットに現れる実体宣言や属性リスト宣言が、外部サブセットに現れるものよりも高い優先度を持つという事である。</p>
<p class="original" lang="en" xml:lang="en">If both the external and internal subsets are used, the internal subset <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be considered to occur before the external subset. This has the effect that entity and attribute-list declarations in the internal subset take precedence over those in the external subset.</p>
<p>もしある文書が整形式のXML 1.0文書、あるいは妥当なXML 1.0文書であり、なおかつ文書が[#x7F-#x9F]の範囲の制御文字を(文字エスケープを使う場合は別として)一切含まない場合、その文書は、単にバージョン番号を変える事で、それぞれ整形式のXML 1.1文書、あるいは妥当なXML 1.1文書になる事もできる。</p>
</div>
<p class="original" lang="en" xml:lang="en">If a document is well-formed or valid XML 1.0, and provided it does not contain any control characters in the range [#x7F-#x9F] other than as character escapes, it may be made well-formed or valid XML 1.1 respectively simply by changing the version number.</p>
</div>

<div class="div2">
<h3><a name="sec-rmd" id="sec-rmd"></a>2.9 スタンドアローン文書宣言<span class="original" lang="en" xml:lang="en"> Standalone Document Declaration</span></h3>
<p><a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>からアプリケーションに渡される過程で、マークアップ宣言は文書の内容に影響する事がある。例えば、属性デフォルトや実体宣言などがその例である。スタンドアローン文書宣言はXML宣言の構成要素として現れる事があり、<a title="文書実体" href="#dt-docent">文書実体</a>の外や、パラメータ実体の中に、文書の内容に影響するような宣言があるかどうかを知らせる。 [<a name="dt-extmkpdecl" id="dt-extmkpdecl" title="外部マークアップ宣言">定義</a>: <b>外部マークアップ宣言</b>は、外部サブセットの中、あるいはパラメータ実体の中に現れるマークアップ宣言の事である(このパラメータ実体は、外部パラメータ実体と内部パラメータ実体の両方である。内部パラメータ実体のマークアップ宣言が外部マークアップ宣言に含まれるのは、妥当性を検証しないプロセッサは内部パラメータ実体を読む事を必要とされないからである)。]</p>
<p class="original" lang="en" xml:lang="en">Markup declarations can affect the content of the document, as passed from an <a title="XML Processor" href="#dt-xml-proc">XML processor</a> to an application; examples are attribute defaults and entity declarations. The standalone document declaration, which may appear as a component of the XML declaration, signals whether or not there are such declarations which appear external to the <a title="Document Entity" href="#dt-docent">document entity</a> or in parameter entities. [Definition: An <b>external markup declaration</b> is defined as a markup declaration occurring in the external subset or in a parameter entity (external or internal, the latter being included because non-validating processors are not required to read them).]</p>
<h5><a name="fulldtd" id="fulldtd"></a>スタンドアローン文書宣言<span class="original" lang="en" xml:lang="en"> Standalone Document Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-SDDecl" id="NT-SDDecl"></a>[32]   </td>
		<td><code>SDDecl</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-S">S</a> 'standalone' <a href="#NT-Eq">Eq</a> ( ( "'" ( 'yes' | 'no' ) "'" ) | ( '"' ( 'yes' | 'no' ) '"' ) )</code></td>
		<td><a href="#vc-check-rmd">[妥当性制約: スタンドアローン文書宣言]</a></td>
	</tr>
</tbody>
</table>
<p>スタンドアローン文書宣言では、値"yes"は、XMLプロセッサからアプリケーションに渡される情報に影響する<a title="外部マークアップ宣言" href="#dt-extmkpdecl">外部マークアップ宣言</a>が存在しない事を示す。値"no"は、そのような外部マークアップ宣言が存在する事、あるいは存在するであろう事を示す。注意してほしいのは、スタンドアローン文書宣言は外部<em>宣言</em>の存在を示すものでしかないという事である。つまり、文書中に外部<em>実体</em>への参照があっても、それらの実体が内部で宣言されているならば、その外部実体への参照の存在は、文書がスタンドアローンであるかどうかという点には変更を来さない。</p>
<p class="original" lang="en" xml:lang="en">In a standalone document declaration, the value "yes" indicates that there are no <a title="External Markup Declaration" href="#dt-extmkpdecl">external markup declarations</a> which affect the information passed from the XML processor to the application. The value "no" indicates that there are or may be such external markup declarations. Note that the standalone document declaration only denotes the presence of external <em>declarations</em>; the presence, in a document, of references to external <em>entities</em>, when those entities are internally declared, does not change its standalone status.</p>
<p>外部マークアップ宣言が一切無ければ、スタンドアローン文書宣言は何ら意味を持たない。外部マークアップ宣言はあるもののスタンドアローン文書宣言が無い時は、値"no"が指定されたものと見なされる。</p>
<p class="original" lang="en" xml:lang="en">If there are no external markup declarations, the standalone document declaration has no meaning. If there are external markup declarations but there is no standalone document declaration, the value "no" is assumed.</p>
<p><code>standalone="no"</code>が適用されているXML文書は、どんな文書であっても、アルゴリズムに従ってスタンドアローン文書に変換する事ができる。ある種のネットワーク転送アプリケーションにとっては、この事は望ましい事であるかも知れない。</p>
<p class="original" lang="en" xml:lang="en">Any XML document for which <code>standalone="no"</code> holds can be converted algorithmically to a standalone document, which may be desirable for some network delivery applications.</p>
<div class="constraint">
	<p class="prefix"><a name="vc-check-rmd" id="vc-check-rmd"></a><b>妥当性制約: スタンドアローン文書宣言<span class="original" lang="en" xml:lang="en"> Validity constraint: Standalone Document Declaration</span></b></p>
	<p>スタンドアローン文書宣言は、外部マークアップ宣言の何れかが次の何れかを宣言した時、必ず値"no"を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">持たなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The standalone document declaration <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> have the value "no" if any external markup declarations contain declarations of:</p>
	<ul>
		<li>
			<p><a title="属性デフォルト" href="#dt-default">デフォルト</a>値を持つ属性。但し、文書中に、その属性が適用されるにも拘わらずその属性に値を指定しなかった要素が現れる時に限る。</p>
			<p class="original" lang="en" xml:lang="en">attributes with <a title="Attribute Default" href="#dt-default">default</a> values, if elements to which these attributes apply appear in the document without specifications of values for these attributes, or</p>
		</li>
		<li>
			<p><code>amp</code>、<code>lt</code>、<code>gt</code>、<code>apos</code>、<code>quot</code>以外の実体。但し、それらの実体への<a title="実体参照" href="#dt-entref">参照</a>が文書中に現れる時に限る。</p>
			<p class="original" lang="en" xml:lang="en">entities (other than <code>amp</code>, <code>lt</code>, <code>gt</code>, <code>apos</code>, <code>quot</code>), if <a title="Entity Reference" href="#dt-entref">references</a> to those entities appear in the document, or</p>
		</li>
		<li>
			<p>トークン化対象型の属性。但し、<a href="#AVNormalize"><cite>正規化</cite></a>によって、その宣言が無かった時と比べて異なる値が生成されるような値と共にその属性が文書中に現れる場合に限る。</p>
			<p class="original" lang="en" xml:lang="en">attributes with tokenized types, where the attribute appears in the document with a value such that <a href="#AVNormalize"><cite>normalization</cite></a> will produce a different value from that which would be produced in the absence of the declaration, or</p>
		</li>
		<li>
			<p><a title="要素内容" href="#dt-elemcontent">要素内容</a>を持つ要素型。但し、その型のインスタンスの何れかが直接ホワイトスペースを含む時に限る。</p>
			<p class="original" lang="en" xml:lang="en">element types with <a title="Element content" href="#dt-elemcontent">element content</a>, if white space occurs directly within any instance of those types.</p>
			<div class="annotation">
				<p class="context-flow">[訳者註開始]</p>
				<p class="prefix"><em>訳者註</em></p>
				<p>インスタンス(instance)について。<cite>Oxford Dictionary of ENGLISH Second edition</cite>のinstanceの項を見てみると、nounとして<q>an example or single occurrence of something</q>と載っています。つまり、要素型のインスタンス(an instance of an element type)とは、「要素型という型に当てはめる事ができる、文書中に現れるもの」("a single occurrence of an element type")と言えます。それはつまり<a href="#dt-element">要素(Element)</a>の事です。この仕様書では属性のインスタンスという表現も使われます。これはつまり<a href="#dt-attr">属性指定(Attribute Specification)</a>の事です。</p>
				<p class="context-flow">[訳者註終了]</p>
			</div>
		</li>
	</ul>
</div>
<p>スタンドアローン文書宣言を持つXML宣言の一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">An example XML declaration with a standalone document declaration:</p>
<div class="exampleInner">
<pre>
&lt;?xml version="1.1" standalone='yes'?&gt;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="sec-white-space" id="sec-white-space"></a>2.10 ホワイトスペースの取り扱い<span class="original" lang="en" xml:lang="en"> White Space Handling</span></h3>
<p>XML文書を編集する際、より可読性を高める為に「ホワイトスペース」(スペース、タブ、空行など)を使ってマークアップを分離すると便利になる事が多い。そのようなホワイトスペースは、大抵の場合、ユーザの下に届けられる文書の形態でも含まれる事は意図していない。一方で、ユーザの元に届けられる形態でも保たれるべき「有意な」ホワイトスペースもよくある。例えば、詩やソースコードに含まれるホワイトスペースがそれである。</p>
<p class="original" lang="en" xml:lang="en">In editing XML documents, it is often convenient to use "white space" (spaces, tabs, and blank lines) to set apart the markup for greater readability. Such white space is typically not intended for inclusion in the delivered version of the document. On the other hand, "significant" white space that should be preserved in the delivered version is common, for example in poetry and source code.</p>
<p><a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>は、マークアップでない文字はすべてアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">渡さなければならない(MUST)</em>。<a title="妥当性を検証するプロセッサ" href="#dt-validating">妥当性を検証するXMLプロセッサ</a>は、それらの文字の内、どれが<a title="要素内容" href="#dt-elemcontent">要素内容</a>に現れるホワイトスペースを成すのかという事もアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">伝えなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">An <a title="XML Processor" href="#dt-xml-proc">XML processor</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> always pass all characters in a document that are not markup through to the application. A <a title="Validating Processor" href="#dt-validating">validating XML processor</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> also inform the application which of these characters constitute white space appearing in <a title="Element content" href="#dt-elemcontent">element content</a>.</p>
<p><code>xml:space</code>という名前の特別な<a title="属性" href="#dt-attr">属性</a>を、その要素ではホワイトスペースが保たれなければならないという意図をアプリケーションに伝える為に、要素に付けても良い。妥当な文書では、この属性は──他のすべての属性と同じように──使われる場合には<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="属性リスト宣言" href="#dt-attdecl">宣言</a>されなければならない(MUST)</em>。宣言される場合は、その属性は、"default"か"preserve"の何れかを値に持つ、あるいはその両方を値に持つ<a title="列挙属性値" href="#dt-enumerated">列挙型</a>として<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">定義されなければならない(MUST)</em>。例えば、次のようにである。</p>
<p class="original" lang="en" xml:lang="en">A special <a title="Attribute" href="#dt-attr">attribute</a> named <code>xml:space</code> may be attached to an element to signal an intention that in that element, white space should be preserved by applications. In valid documents, this attribute, like any other, <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be <a title="Attribute-List Declaration" href="#dt-attdecl">declared</a> if it is used. When declared, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be given as an <a title="Enumerated Attribute Values" href="#dt-enumerated">enumerated type</a> whose values are one or both of "default" and "preserve". For example:</p>
<div class="exampleInner">
<pre>
&lt;!ATTLIST poem xml:space (default|preserve) 'preserve'&gt;
&lt;!ATTLIST pre xml:space (preserve) #FIXED 'preserve'&gt;
</pre>
</div>
<p>値"default"は、その要素については、アプリケーションデフォルトのホワイトスペース処理モードが使用可能である事を意味する。値"preserve"は、アプリケーションがすべてのホワイトスペースを保たなければならない意図がある事を示す。この定義の意図は、他の<code>xml:space</code>のインスタンスが上書きしない限り、<code>xml:space</code>属性が指定された要素の内容に含まれる要素すべてに適用されるという事である。この仕様書は、<code>xml:space</code>の値で"default"と"preserve"以外のものについては、その意味を与えない。その他の値が指定される事はエラーである。XMLプロセッサは、そのエラーをアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しても良い(MAY)</em>し、その属性の指定を無視する事で、あるいはエラーを引き起こした値をアプリケーションに報告する事でエラーから<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">回復しても良い(MAY)</em>。アプリケーションは、エラーを引き起こした値を無視しても良いし、拒絶しても良い。</p>
<p class="original" lang="en" xml:lang="en">The value "default" signals that applications' default white-space processing modes are acceptable for this element; the value "preserve" indicates the intent that applications preserve all the white space. This declared intent is considered to apply to all elements within the content of the element where it is specified, unless overridden with another instance of the <code>xml:space</code> attribute. This specification does not give meaning to any value of <code>xml:space</code> other than "default" and "preserve". It is an error for other values to be specified; the XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> report the error or <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> recover by ignoring the attribute specification or by reporting the (erroneous) value to the application. Applications may ignore or reject erroneous values.</p>
<p>あらゆる文書の<a title="ルート要素" href="#dt-root">ルート要素</a>は、そのルート要素がこの属性に値を指定したり、この属性がデフォルト値を持つように定義されたりしていない限りは、アプリケーションがホワイトスペースを取り扱う方法について何ら意図を伝えないものと見なされる。</p>
<p class="original" lang="en" xml:lang="en">The <a title="Root Element" href="#dt-root">root element</a> of any document is considered to have signaled no intentions as regards application space handling, unless it provides a value for this attribute or the attribute is declared with a default value.</p>
</div>

<div class="div2">
<h3><a name="sec-line-ends" id="sec-line-ends"></a>2.11 行末の取り扱い<span class="original" lang="en" xml:lang="en"> End-of-Line Handling</span></h3>
<p>XMLの<a title="テキスト実体" href="#dt-parsedent">解析対象実体</a>はしばしば、編集の簡便の為に複数行に渡って書かれるコンピュータファイルに格納される。これらの行は一般に、CARRIAGE RETURN(#xD)とLINE FEED(#xA)の組み合わせで分けられる。</p>
<p class="original" lang="en" xml:lang="en">XML <a title="Text Entity" href="#dt-parsedent">parsed entities</a> are often stored in computer files which, for editing convenience, are organized into lines. These lines are typically separated by some combination of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).</p>
<p><a title="アプリケーション" href="#dt-app">アプリケーション</a>の仕事を簡単にする為に、<a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>は、あたかも、入力から得られた外部解析対象実体(文書実体も含む)の改行を、解析を始める前に正規化したかのように<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">動作しなければならない(MUST)</em>。この時、次に挙げるものを一つの#xA文字に変換したかのように<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">動作しなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">To simplify the tasks of <a title="Application" href="#dt-app">applications</a>, the <a title="XML Processor" href="#dt-xml-proc">XML processor</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> behave as if it normalized all line breaks in external parsed entities (including the document entity) on input, before parsing, by translating all of the following to a single #xA character:</p>
<ol class="enumar">
	<li>
		<p>#xD #xAという並びの二文字</p>
		<p class="original" lang="en" xml:lang="en">the two-character sequence #xD #xA</p>
	</li>
	<li>
		<p>#xD #x85という並びの二文字</p>
		<p class="original" lang="en" xml:lang="en">the two-character sequence #xD #x85</p>
	</li>
	<li>
		<p>#x85という一つの文字</p>
		<p class="original" lang="en" xml:lang="en">the single character #x85</p>
	</li>
	<li>
		<p>#x2028という一つの文字</p>
		<p class="original" lang="en" xml:lang="en">the single character #x2028</p>
	</li>
	<li>
		<p>#xAや#x85が直後に続かないすべての#xDという文字</p>
		<p class="original" lang="en" xml:lang="en">any #xD character that is not immediately followed by #xA or #x85.</p>
	</li>
</ol>
<p>文字#x85と#x2028は、実体のエンコーディング宣言(が存在するならば、それ)を読み取るまでは、それが改行文字であると認識し変換する事を確信して行う事はできない。それ故、これらの文字をXML宣言やテキスト宣言の中で使う事は致命的エラーである。</p>
<p class="original" lang="en" xml:lang="en">The characters #x85 and #x2028 cannot be reliably recognized and translated until an entity's encoding declaration (if present) has been read. Therefore, it is a fatal error to use them within the XML declaration or text declaration.</p>
</div>

<div class="div2">
<h3><a name="sec-lang-tag" id="sec-lang-tag"></a>2.12 言語識別<span class="original" lang="en" xml:lang="en"> Language Identification</span></h3>
<p>文書を処理する際、その内容がどの自然言語あるいは形式言語で書かれているかを識別すると便利になる事がしばしばある。そこで、<code>xml:lang</code>という名前の特別な<a title="属性" href="#dt-attr">属性</a>を、XML文書の中の要素の内容や属性値で使われている言語を指定する為に、文書中に挿入しても良い。妥当な文書では、この属性は──他のすべての属性と同じように──使われる場合には<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="属性リスト宣言" href="#dt-attdecl">宣言</a>されなければならない(MUST)</em>。この属性の値は、<cite>Tags for the Identification of Languages</cite> <a href="#RFC1766">[IETF RFC 3066]</a>、及びその後継文書で定義される言語識別子である。空の文字列を指定しても良い。</p>
<p class="original" lang="en" xml:lang="en">In document processing, it is often useful to identify the natural or formal language in which the content is written. A special <a title="Attribute" href="#dt-attr">attribute</a> named <code>xml:lang</code> may be inserted in documents to specify the language used in the contents and attribute values of any element in an XML document. In valid documents, this attribute, like any other, <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be <a title="Attribute-List Declaration" href="#dt-attdecl">declared</a> if it is used. The values of the attribute are language identifiers as defined by <a href="#RFC1766">[IETF RFC 3066]</a>, <cite>Tags for the Identification of Languages</cite>, or its successor; in addition, the empty string may be specified.</p>
<p>(生成規則33から38までは削除された。)</p>
<p class="original" lang="en" xml:lang="en">(Productions 33 through 38 have been removed.)</p>
<p><code>xml:lang</code>を使った例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">For example:</p>
<div class="exampleInner">
<pre>
&lt;p xml:lang="en"&gt;The quick brown fox jumps over the lazy dog.&lt;/p&gt;
&lt;p xml:lang="en-GB"&gt;What colour is it?&lt;/p&gt;
&lt;p xml:lang="en-US"&gt;What color is it?&lt;/p&gt;
&lt;sp who="Faust" desc='leise' xml:lang="de"&gt;
&lt;l&gt;Habe nun, ach! Philosophie,&lt;/l&gt;
&lt;l&gt;Juristerei, und Medizin&lt;/l&gt;
&lt;l&gt;und leider auch Theologie&lt;/l&gt;
&lt;l&gt;durchaus studiert mit hei&amp;#xDF;em Bem&amp;#xFC;h'n.&lt;/l&gt;
&lt;/sp&gt;
</pre>
</div>
<p><code>xml:lang</code>で指定された言語は、その属性が指定された要素とその要素の属性値に適用される。加えて、他の<code>xml:lang</code>のインスタンスが上書きしない限り、その属性が指定された要素の内容に含まれるすべての要素にも適用される。特に、要素Bを内包する要素Aの<code>xml:lang</code>の指定を上書きする為に、要素Bで<code>xml:lang</code>に空の値が(他の言語を指定するのではなく)使われる事がある。Bの中では、あたかもBとその祖先で<code>xml:lang</code>など指定されなかったかのように、言語についての情報が無いものと見なされる。アプリケーションは、要素のどの属性値が<code>xml:lang</code>で説明される言語依存の値として取り扱われるのか、また、(もしあれば)要素の内容のどの部分が言語依存のものとして取り扱われるのかを決定する。</p>
<p class="original" lang="en" xml:lang="en">The language specified by <code>xml:lang</code> applies to the element where it is specified (including the values of its attributes), and to all elements in its content unless overridden with another instance of <code>xml:lang</code>. In particular, the empty value of <code>xml:lang</code> is used on an element B to override a specification of <code>xml:lang</code> on an enclosing element A, without specifying another language. Within B, it is considered that there is no language information available, just as if <code>xml:lang</code> had not been specified on B or any of its ancestors. <span>Applications determine which of an element's attribute values and which parts of its character content, if any, are treated as language-dependent values described by <code>xml:lang</code>.</span></p>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p>言語の情報は、外部の転送プロトコル(例えばHTTPやMIMEなど)によって提供される事がある。もしあれば、XMLアプリケーションはその情報を使用しても良いが、<code>xml:lang</code>で提供されるより局所的な情報はそれを上書きするものと見なされる事が望ましい。</p>
	<p class="original" lang="en" xml:lang="en">Language information may also be provided by external transport protocols (e.g. HTTP or MIME). When available, this information may be used by XML applications, but the more local information provided by <code>xml:lang</code> should be considered to override it.</p>
</div>
<p><code>xml:lang</code>の簡単な宣言は、次の形を採るだろう。</p>
<p class="original" lang="en" xml:lang="en">A simple declaration for <code>xml:lang</code> might take the form</p>
<div class="exampleInner">
<pre>
xml:lang CDATA #IMPLIED
</pre>
</div>
<p>しかし、適切ならば、特定のデフォルト値を与えても良い。フランス語で書かれた一連の詩(poem)を、英語で書かれた語義(gloss)と注解(note)と共に、英語を使う学生の為に用意するならば、<code>xml:lang</code>は次のように宣言されるだろう。</p>
<p class="original" lang="en" xml:lang="en">but specific default values may also be given, if appropriate. In a collection of French poems for English students, with glosses and notes in English, the <code>xml:lang</code> attribute might be declared this way:</p>
<div class="exampleInner">
<pre>
&lt;!ATTLIST poem   xml:lang CDATA 'fr'&gt;
&lt;!ATTLIST gloss  xml:lang CDATA 'en'&gt;
&lt;!ATTLIST note   xml:lang CDATA 'en'&gt;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="sec-normalization-checking" id="sec-normalization-checking"></a>2.13 正規化検査<span class="original" lang="en" xml:lang="en"> Normalization Checking</span></h3>
<p><a title="文書実体" href="#dt-docent">文書実体</a>を含むすべてのXML<a title="テキスト実体" href="#dt-parsedent">解析対象実体</a>は、<a href="#sec-CharNorm"><b>B 文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></b></a>に従って、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>されている事が望ましい(SHOULD)</em>。<a href="#sec-CharNorm"><b>B 文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></b></a>の中で参照されているXMLの<em><a name="dt-relconst" id="dt-relconst"></a>関連する構成子</em>の定義は次の通りである。</p>
<p class="original" lang="en" xml:lang="en">All XML <a title="Text Entity" href="#dt-parsedent"> parsed entities</a> (including <a title="Document Entity" href="#dt-docent">document entities</a>) <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be <a title="fully normalized" href="#dt-fullnorm">fully normalized</a> as per the definition of <a href="#sec-CharNorm"><b>B Definitions for Character Normalization</b></a> supplemented by the following definitions of <em>relevant constructs</em> for XML:</p>
<ol class="enumar">
	<li>
		<p>すべての<a title="テキスト実体" href="#dt-parsedent">解析対象実体</a>の<a title="置換テキスト" href="#dt-repltext">置換テキスト</a></p>
		<p class="original" lang="en" xml:lang="en">The <a title="Replacement Text" href="#dt-repltext">replacement text</a> of all <a title="Text Entity" href="#dt-parsedent">parsed entities</a></p>
	</li>
	<li>
		<p>その文脈では、次の何れかの生成規則にマッチする事になるすべてのテキスト</p>
		<p class="original" lang="en" xml:lang="en">All text matching, in context, one of the following productions:</p>
		<ol class="enumla">
			<li>
				<p><a href="#NT-CData"> CData</a></p>
			</li>
			<li>
				<p><a href="#NT-CharData"> CharData</a></p>
			</li>
			<li>
				<p><a href="#NT-content"> content</a></p>
			</li>
			<li>
				<p><a href="#NT-Name"> Name</a></p>
			</li>
			<li>
				<p><a href="#NT-Nmtoken"> Nmtoken</a></p>
			</li>
		</ol>
	</li>
</ol>
<p>しかしながら、たとえ<a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>されていなかったとしても、文書は整形式であり得る。XMLプロセッサは、処理される文書が<a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>された形式になっている事を検証し、アプリケーションに<a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>されていたかどうかを報告する事を、ユーザの選択に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">委ねられるようにする事が望ましい(SHOULD)</em>。検証しないという選択肢は、入力のテキストが<a href="#sec-CharNorm"><b>B 文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></b></a>で定義されるように<a title="保証される" href="#dt-certified">保証</a>されている時にしか<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">採られない事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">However, a document is still well-formed even if it is not <a title="fully normalized" href="#dt-fullnorm">fully normalized</a>. XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> provide a user option to verify that the document being processed is in <a title="fully normalized" href="#dt-fullnorm">fully normalized</a> form, and report to the application whether it is or not. The option to not verify <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be chosen only when the input text is <a title="certified" href="#dt-certified">certified</a>, as defined by <a href="#sec-CharNorm"><b>B Definitions for Character Normalization</b></a>.</p>
<p>完全正規化の検証は、あたかも、まず最初に、実体が<a href="#sec-CharNorm"><b>B 文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></b></a>で定義されるように<a title="インクルードに関して正規化される" href="#dt-inclnorm">インクルードに関して正規化</a>されている事を検証し、その後で、上記の関連する構成子が(文字参照が展開された後で)何れも<a href="#sec-CharNorm"><b>B 文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></b></a>で定義される<a title="合成化文字" href="#dt-compchar">合成化文字</a>から始まっていない事を検証したかのように<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">遂行されなければならない(MUST)</em>。妥当性を検証しないプロセッサは、そのプロセッサが読み込む事が無い外部実体をインクルードした場合に非正規化が起こり得る場合でも、それを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">無視しなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">The verification of full normalization <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be carried out as if by first verifying that the entity is in <a title="include-normalized" href="#dt-inclnorm">include-normalized</a> form as defined by <a href="#sec-CharNorm"><b>B Definitions for Character Normalization</b></a> and by then verifying that none of the relevant constructs listed above begins (after character references are expanded) with a <a title="composing character" href="#dt-compchar">composing character</a> as defined by <a href="#sec-CharNorm"><b>B Definitions for Character Normalization</b></a>. Non-validating processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> ignore possible denormalizations that would be caused by inclusion of external entities that they do not read.</p>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p><a title="合成化文字" href="#dt-compchar">合成化文字</a>は、非ゼロの結合クラスを持つすべてのUnicode文字の集合に、クラスがゼロでありながら特定の極限分解文字列において先頭にならない文字の集合の和集合に含まれる文字である。これらの文字は最初から基底文字に続く事を意図されているものであり、(要素の内容も含めて)関連する構成子が<a title="合成化文字" href="#dt-compchar">合成化文字</a>から始まる事を制限する事がXMLの表現力を落とす事は殆ど無い。</p>
	<p class="original" lang="en" xml:lang="en">The <a title="composing character" href="#dt-compchar">composing character</a> are all Unicode characters of non-zero combining class, plus a small number of class-zero characters that nevertheless take part as a non-initial character in certain Unicode canonical decompositions. Since these characters are meant to follow base characters, restricting relevant constructs (including content) from beginning with a <a title="composing character" href="#dt-compchar">composing character</a> does not meaningfully diminish the expressiveness of XML.</p>
	<div class="annotation">
		<p class="context-flow">[訳者註開始]</p>
		<p class="prefix"><em>訳者註</em></p>
		<p>ここで使った語、合成化文字(Composing Character)は、XML 1.1の仕様書で定義される語です。Unicode用語のComposite Character(日本語ではしばしば合成文字と訳される)とは<em>全くの別物</em>なので注意して下さい。Composing CharacterはむしろUnicode用語のCombining Character(しばしば結合文字と訳される)に近いものです。</p>
		<p class="context-flow">[訳者註終了]</p>
	</div>
</div>
<p>完全正規化の検証中に、プロセッサがその正規化状態を特定できない文字(例えば、プロセッサの実装当時のUnicode <a href="#Unicode">[Unicode]</a>のバージョンよりも新しいバージョンのUnicodeで導入された文字)に遭遇した場合は、プロセッサは、ユーザが選択した場合、それらの文字によって引き起こされるかも知れない非正規化を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">無視しても良い(MAY)</em>。信頼性やセキュリティが極めて重要になる場合、アプリケーションがそれらの非正規化を無視するという選択肢を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">選ぶ事は望ましくない(SHOULD NOT)</em>。</p>
<p class="original" lang="en" xml:lang="en">If, while verifying full normalization, a processor encounters characters for which it cannot determine the normalization properties (i.e., characters introduced in a version of Unicode <a href="#Unicode">[Unicode]</a> later than the one used in the implementation of the processor), then the processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em>, at user option, ignore any possible denormalizations caused by these characters. The option to ignore those denormalizations <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD NOT</em> be chosen by applications when reliability or security are critical.</p>
<p>XMLプロセッサは、入力を<a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>された形式に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">変換してはならない(MUST NOT)</em>。入力にXML 1.1かXML 1.0を用い、出力にXML 1.1を使うXMLアプリケーションは、出力が<a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>されるように<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">する事が望ましい(SHOULD)</em>。但し、内部処理をしている間は<a title="完全に正規化される" href="#dt-fullnorm">完全に正規化</a>された形式にしておく必要は無い。</p>
<p class="original" lang="en" xml:lang="en">XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> transform the input to be in <a title="fully normalized" href="#dt-fullnorm">fully normalized</a> form. XML applications that create XML 1.1 output from either XML 1.1 or XML 1.0 input <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> ensure that the output is <a title="fully normalized" href="#dt-fullnorm">fully normalized</a>; it is not necessary for internal processing forms to be <a title="fully normalized" href="#dt-fullnorm">fully normalized</a>.</p>
<p>このセクションを用意した目的は、XML文書の作成者が適切に文書を正規化する事をXMLプロセッサが確実にさせるよう、XMLプロセッサに強く勧める為である。文書が適切に正規化されれば、XMLアプリケーションは、Unicodeが許す文字列の異なる「綴り」について心配する事無く、同一性比較などのテストをする事ができるようになるだろう。</p>
<p class="original" lang="en" xml:lang="en">The purpose of this section is to strongly encourage XML processors to ensure that the creators of XML documents have properly normalized them, so that XML applications can make tests such as identity comparisons of strings without having to worry about the different possible "spellings" of strings which Unicode allows.</p>
<p>実体が非Unicodeエンコーディングで表されており、かつプロセッサがその実体をUnicodeにコード変換する場合は、プロセッサは正規化するトランスコーダを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使う事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">When entities are in a non-Unicode encoding, if the processor transcodes them to Unicode, it <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> use a normalizing transcoder.</p>
</div>
</div>

<div class="div1">
<h2><a name="sec-logical-struct" id="sec-logical-struct"></a>3 論理構造<span class="original" lang="en" xml:lang="en"> Logical Structures</span></h2>
<p>[<a name="dt-element" id="dt-element" title="要素">定義</a>: <a title="XML文書" href="#dt-xml-doc">XML文書</a>は何れも、一つ以上の<b>要素</b>を含む。要素の境界は<a title="開始タグ" href="#dt-stag">開始タグ</a>と<a title="終了タグ" href="#dt-etag">終了タグ</a>によって定められるが、<a title="空" href="#dt-empty">空</a>要素の場合は、<a title="空要素タグ" href="#dt-eetag">空要素タグ</a>によって定められる。要素は型を持っており、名前で識別される。この名前は「共通識別子」(GI)と呼ばれる事が時々ある。要素は属性指定の組を持つ事もある。] 各属性指定は<a title="属性名" href="#dt-attrname">名前</a>と<a title="属性値" href="#dt-attrval">値</a>を持つ。</p>
<p class="original" lang="en" xml:lang="en">[Definition: Each <a title="XML Document" href="#dt-xml-doc">XML document</a> contains one or more <b>elements</b>, the boundaries of which are either delimited by <a title="Start-Tag" href="#dt-stag">start-tags</a> and <a title="End Tag" href="#dt-etag">end-tags</a>, or, for <a title="Empty" href="#dt-empty">empty</a> elements, by an <a title="empty-element tag" href="#dt-eetag">empty-element tag</a>. Each element has a type, identified by name, sometimes called its "generic identifier" (GI), and may have a set of attribute specifications.] Each attribute specification has a <a title="Attribute Name" href="#dt-attrname">name</a> and a <a title="Attribute Value" href="#dt-attrval">value</a>.</p>
<h5><a name="IDALUFS" id="IDALUFS"></a>要素<span class="original" lang="en" xml:lang="en"> Element</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-element" id="NT-element"></a>[39]   </td>
		<td><code>element</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-EmptyElemTag">EmptyElemTag</a></code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| <a href="#NT-STag">STag</a> <a href="#NT-content">content</a> <a href="#NT-ETag">ETag</a></code></td>
		<td><a href="#GIMatch">[整形式性制約: 要素型のマッチ]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#elementvalid">[妥当性制約: 妥当な要素]</a></td>
	</tr>
</tbody>
</table>
<p>この仕様書は、アプリケーションにおける意味や、使い方、また(構文の域を超えた)要素型や属性の名前については制約を課さない。但し、<code>(('X'|'x')('M'|'m')('L'|'l'))</code>にマッチする文字列から始まる名前はこの仕様書のこのバージョン及び将来のバージョンにおける標準化の為に予約されている。</p>
<p class="original" lang="en" xml:lang="en">This specification does not constrain the application semantics, use, or (beyond syntax) names of the element types and attributes, except that names beginning with a match to <code>(('X'|'x')('M'|'m')('L'|'l'))</code> are reserved for standardization in this or future versions of this specification.</p>
<div class="constraint">
	<p class="prefix"><a name="GIMatch" id="GIMatch"></a><b>整形式性制約: 要素型のマッチ<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: Element Type Match</span></b></p>
	<p>要素の終了タグの<a href="#NT-Name">Name</a>は、その要素の開始タグの要素型に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The <a href="#NT-Name">Name</a> in an element's end-tag <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the element type in the start-tag.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="elementvalid" id="elementvalid"></a><b>妥当性制約: 妥当な要素<span class="original" lang="en" xml:lang="en"> Validity constraint: Element Valid</span></b></p>
	<p>要素は、要素型がマッチする<a href="#NT-Name">Name</a>を持つ、<a href="#NT-elementdecl">elementdecl</a>にマッチする宣言があり、更に次の何れかの条件を満たす時妥当となる。</p>
	<p class="original" lang="en" xml:lang="en">An element is valid if there is a declaration matching <a href="#NT-elementdecl">elementdecl</a> where the <a href="#NT-Name">Name</a> matches the element type, and one of the following holds:</p>
	<ol class="enumar">
		<li>
			<p>宣言が<b>EMPTY</b>にマッチし、要素は何ら<a title="内容" href="#dt-content">内容</a>を持たない(実体参照、コメント、処理命令、ホワイトスペースなどですら含んではならない)。</p>
			<p class="original" lang="en" xml:lang="en">The declaration matches <b>EMPTY</b> and the element has no <a title="Content" href="#dt-content">content</a> (not even entity references, comments, PIs or white space).</p>
		</li>
		<li>
			<p>宣言が<a href="#NT-children">children</a>にマッチし、一連の<a title="親と子" href="#dt-parentchild">子要素</a>が、内容モデルの正規表現から生成される集合(言語)に属する。但し、ホワイトスペース、コメント、処理命令(つまり、生成規則[27] <a href="#NT-Misc">Misc</a>にマッチするマークアップ)が、開始タグと最初の子要素の間、子要素と子要素の間、最後の子要素と終了タグの間に現れても良い。注意してほしいのは、ホワイトスペースのみを含むCDATAセクションや、ホワイトスペースに展開される文字参照を置換テキストに持つ実体への参照は非終端の<a href="#NT-S">S</a>にマッチしない事である。この為、これらは<a href="#NT-Misc">Misc</a>が現れ得る場所に現れる事ができない。しかし、ホワイトスペースに展開される文字参照から成るリテラル値を持つ内部実体への参照は<a href="#NT-S">S</a>にマッチする。これは、その置換テキストが文字参照を展開した後のホワイトスペースになるからである。</p>
			<p class="original" lang="en" xml:lang="en">The declaration matches <a href="#NT-children">children</a> and the sequence of <a title="Parent/Child" href="#dt-parentchild">child elements</a> belongs to the language generated by the regular expression in the content model, with optional white space, comments and PIs (i.e. markup matching production [27] <a href="#NT-Misc">Misc</a>) between the start-tag and the first child element, between child elements, or between the last child element and the end-tag. Note that a CDATA section containing only white space or a reference to an entity whose replacement text is character references expanding to white space do not match the nonterminal <a href="#NT-S">S</a>, and hence cannot appear in these positions; however, a reference to an internal entity with a literal value consisting of character references expanding to white space does match <a href="#NT-S">S</a>, since its replacement text is the white space resulting from expansion of the character references.</p>
		</li>
		<li>
			<p>宣言が<a href="#NT-Mixed">Mixed</a>にマッチし、(すべての実体参照をそれぞれの置換テキストで置き換えた後の)要素の内容が、<a title="文字データ" href="#dt-chardata">文字データ</a>(<a title="CDATAセクション" href="#dt-cdsection">CDATAセクション</a>を含む)、<a title="コメント" href="#dt-comment">コメント</a>、<a title="処理命令" href="#dt-pi">処理命令</a>、要素型が内容モデルに含まれる名前にマッチする<a title="親と子" href="#dt-parentchild">子要素</a>から成る。</p>
			<p class="original" lang="en" xml:lang="en">The declaration matches <a href="#NT-Mixed">Mixed</a>, and the content (after replacing any entity references with their replacement text) consists of <a title="Character Data" href="#dt-chardata">character data</a> <span>(including <a title="CDATA Section" href="#dt-cdsection">CDATA sections</a>)</span>, <a title="Comment" href="#dt-comment">comments</a>, <a title="Processing instruction" href="#dt-pi">PIs</a> and <a title="Parent/Child" href="#dt-parentchild">child elements</a> whose types match names in the content model.</p>
		</li>
		<li>
			<p>宣言が<b>ANY</b>にマッチし、(すべての実体参照をそれぞれの置換テキストで置き換えた後の)要素の内容が、文字データ、<a title="CDATAセクション" href="#dt-cdsection">CDATAセクション</a>、<a title="コメント" href="#dt-comment">コメント</a>、<a title="処理命令" href="#dt-pi">処理命令</a>、既に宣言されている要素型を持つ<a title="親と子" href="#dt-parentchild">子要素</a>から成る。</p>
			<p class="original" lang="en" xml:lang="en">The declaration matches <b>ANY</b>, and the content (after replacing any entity references with their replacement text) consists of character data<span>, <a title="CDATA Section" href="#dt-cdsection">CDATA sections</a>, <a title="Comment" href="#dt-comment">comments</a>, <a title="Processing instruction" href="#dt-pi">PIs</a></span> and <a title="Parent/Child" href="#dt-parentchild">child elements</a> whose types have been declared.</p>
		</li>
	</ol>
</div>

<div class="div2">
<h3><a name="sec-starttags" id="sec-starttags"></a>3.1 開始タグ、終了タグ、空要素タグ<span class="original" lang="en" xml:lang="en"> Start-Tags, End-Tags, and Empty-Element Tags</span></h3>
<p>[<a name="dt-stag" id="dt-stag" title="開始タグ">定義</a>: 空でないXML要素の始まりは、すべて<b>開始タグ</b>で示される。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: The beginning of every non-empty XML element is marked by a <b>start-tag</b>.]</p>
<h5><a name="IDA10FS" id="IDA10FS"></a>開始タグ<span class="original" lang="en" xml:lang="en"> Start-tag</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-STag" id="NT-STag"></a>[40]   </td>
		<td><code>STag</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;' <a href="#NT-Name">Name</a> ( <a href="#NT-S">S</a> <a href="#NT-Attribute">Attribute</a> )* <a href="#NT-S">S</a>? '&gt;'</code></td>
		<td><a href="#uniqattspec">[整形式性制約: 一意な属性指定]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-Attribute" id="NT-Attribute"></a>[41]   </td>
		<td><code>Attribute</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Name">Name</a> <a href="#NT-Eq">Eq</a> <a href="#NT-AttValue">AttValue</a></code></td>
		<td><a href="#ValueType">[妥当性制約: 属性値の型]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#NoExternalRefs">[整形式性制約: 一切無い外部実体参照]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#CleanAttrVals">[整形式性制約: 属性値の中に一切無い&lt;]</a></td>
	</tr>
</tbody>
</table>
<p>開始タグと終了タグの<a href="#NT-Name">Name</a>は、その要素の<b>型</b>を与える。 [<a name="dt-attr" id="dt-attr" title="属性">定義</a>: <a href="#NT-Name">Name</a>と<a href="#NT-AttValue">AttValue</a>の組は、要素の<b>属性指定</b>と呼ばれる。] [<a name="dt-attrname" id="dt-attrname" title="属性名">定義</a>: 属性指定の<a href="#NT-Name">Name</a>は<b>属性名</b>と呼ばれる。] [<a name="dt-attrval" id="dt-attrval" title="属性値">定義</a>: <a href="#NT-AttValue">AttValue</a>の内容(区切り子<code>'</code>あるいは<code>"</code>で挟まれたテキスト)は<b>属性値</b>と呼ばれる。] 開始タグや空要素タグの属性指定の順番は有意でない事に注意してほしい。</p>
<p class="original" lang="en" xml:lang="en">The <a href="#NT-Name">Name</a> in the start- and end-tags gives the element's <b>type</b>. [Definition: The <a href="#NT-Name">Name</a>-<a href="#NT-AttValue">AttValue</a> pairs are referred to as the <b>attribute specifications</b> of the element], [Definition: with the <a href="#NT-Name">Name</a> in each pair referred to as the <b>attribute name</b>] and [Definition: the content of the <a href="#NT-AttValue">AttValue</a> (the text between the <code>'</code> or <code>"</code> delimiters) as the <b>attribute value</b>.] Note that the order of attribute specifications in a start-tag or empty-element tag is not significant.</p>
<div class="constraint">
	<p class="prefix"><a name="uniqattspec" id="uniqattspec"></a><b>整形式性制約: 一意な属性指定<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: Unique Att Spec</span></b></p>
	<p>すべての属性名は、同じ開始タグあるいは同じ空要素タグの中で二回以上<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">An attribute name <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear more than once in the same start-tag or empty-element tag.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="ValueType" id="ValueType"></a><b>妥当性制約: 属性値の型<span class="original" lang="en" xml:lang="en"> Validity constraint: Attribute Value Type</span></b></p>
	<p>属性は<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されていなければならない(MUST)</em>。そして、その値は宣言された型に当てはまるもので<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">なければならない(MUST)</em>。属性型の詳細は<a href="#attdecls"><b>3.3 属性リスト宣言<span class="original" lang="en" xml:lang="en"> Attribute-List Declarations</span></b></a>で確認して欲しい。</p>
	<p class="original" lang="en" xml:lang="en">The attribute <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> have been declared; the value <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be of the type declared for it. (For attribute types, see <a href="#attdecls"><b>3.3 Attribute-List Declarations</b></a>.)</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="NoExternalRefs" id="NoExternalRefs"></a><b>整形式性制約: 一切無い外部実体参照<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: No External Entity References</span></b></p>
	<p>属性値は、直接的にも間接的にも、外部実体への実体参照を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含んではならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Attribute values <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> contain direct or indirect entity references to external entities.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="CleanAttrVals" id="CleanAttrVals"></a><b>整形式性制約: 属性値の中に一切無い&lt;<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: No <code>&lt;</code> in Attribute Values</span></b></p>
	<p>属性値の中で直接的あるいは間接的に参照されるすべての実体の<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>は、&lt;を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含んではならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The <a title="Replacement Text" href="#dt-repltext">replacement text</a> of any entity referred to directly or indirectly in an attribute value <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> contain a <code>&lt;</code>.</p>
</div>
<p>開始タグの一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">An example of a start-tag:</p>
<div class="exampleInner">
<pre>
&lt;termdef id="dt-dog" term="dog"&gt;
</pre>
</div>
<p>[<a name="dt-etag" id="dt-etag" title="終了タグ">定義</a>: 開始タグで始まる要素は、すべて、開始タグで与えられる要素型に対応する名前を持つ<b>終了タグ</b>で<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">示されなければならない(MUST)</em>。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: The end of every element that begins with a start-tag <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be marked by an <b>end-tag</b> containing a name that echoes the element's type as given in the start-tag:]</p>
<h5><a name="IDAZIIS" id="IDAZIIS"></a>終了タグ<span class="original" lang="en" xml:lang="en"> End-tag</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-ETag" id="NT-ETag"></a>[42]   </td>
		<td><code>ETag</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;/' <a href="#NT-Name">Name</a> <a href="#NT-S">S</a>? '&gt;'</code></td>
	</tr>
</tbody>
</table>
<p>終了タグの一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">An example of an end-tag:</p>
<div class="exampleInner">
<pre>
&lt;/termdef&gt;
</pre>
</div>
<p>[<a name="dt-content" id="dt-content" title="内容">定義</a>: 開始タグと終了タグに挟まれた<a title="テキスト" href="#dt-text">テキスト</a>は、要素の<b>内容</b>と呼ばれる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: The <a title="Text" href="#dt-text">text</a> between the start-tag and end-tag is called the element's <b>content</b>:]</p>
<h5><a name="IDAHKIS" id="IDAHKIS"></a>要素の内容<span class="original" lang="en" xml:lang="en"> Content of Elements</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-content" id="NT-content"></a>[43]   </td>
		<td><code>content</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-CharData">CharData</a>? ( ( <a href="#NT-element">element</a> | <a href="#NT-Reference">Reference</a> | <a href="#NT-CDSect">CDSect</a> | <a href="#NT-PI">PI</a> | <a href="#NT-Comment">Comment</a> ) <a href="#NT-CharData">CharData</a>? )*</code></td>
	</tr>
</tbody>
</table>
<p>[<a name="dt-empty" id="dt-empty" title="空">定義</a>: <a href="#NT-content">content</a>を持たない要素は<b>空</b>だと言われる。] 空である要素は、終了タグが開始タグの直後に続く事か、空要素タグを使う事で表現される。 [<a name="dt-eetag" id="dt-eetag" title="空要素タグ">定義</a>: <b>空要素タグ</b>は、次の特別な形を採る。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: An element with no <a href="#NT-content">content</a> is said to be <b>empty</b>.] The representation of an empty element is either a start-tag immediately followed by an end-tag, or an empty-element tag. [Definition: An <b>empty-element tag</b> takes a special form:]</p>
<h5><a name="IDAMMIS" id="IDAMMIS"></a>空要素のタグ<span class="original" lang="en" xml:lang="en"> Tags for Empty Elements</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EmptyElemTag" id="NT-EmptyElemTag"></a>[44]   </td>
		<td><code>EmptyElemTag</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;' <a href="#NT-Name">Name</a> ( <a href="#NT-S">S</a> <a href="#NT-Attribute">Attribute</a> )* <a href="#NT-S">S</a>? '/&gt;'</code></td>
		<td><a href="#uniqattspec">[整形式性制約: 一意な属性指定]</a></td>
	</tr>
</tbody>
</table>
<p>空要素タグは、要素が内容を一切持たないのであれば、その要素がキーワード<b>EMPTY</b>を使って宣言されたかどうかに拘わらず、あらゆる要素に使っても良い。しかし、<a title="相互運用性の為に" href="#dt-interop">相互運用性の為に</a>、空要素タグはEMPTYと宣言された要素<em>だけ</em>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使われる事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">Empty-element tags may be used for any element which has no content, whether or not it is declared using the keyword <b>EMPTY</b>. <a title="For interoperability" href="#dt-interop">For interoperability</a>, the empty-element tag <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be used, and <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> only be used, for elements which are declared EMPTY.</p>
<p>空要素の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of empty elements:</p>
<div class="exampleInner">
<pre>
&lt;IMG align="left"
src="http://www.w3.org/Icons/WWW/w3c_home" /&gt;
&lt;br&gt;&lt;/br&gt;
&lt;br/&gt;</pre>
</div>
</div>

<div class="div2">
<h3><a name="elemdecls" id="elemdecls"></a>3.2 要素型宣言<span class="original" lang="en" xml:lang="en"> Element Type Declarations</span></h3>
<p><a title="妥当性" href="#dt-valid">妥当性</a>を検証する目的で、<a title="XML文書" href="#dt-xml-doc">XML文書</a>の<a title="要素" href="#dt-element">要素</a>の構造に、要素型宣言や属性リスト宣言を使って制約を課す事がある。要素型宣言は要素の<a title="内容" href="#dt-content">内容</a>に制約を課す。</p>
<p class="original" lang="en" xml:lang="en">The <a title="Element" href="#dt-element">element</a> structure of an <a title="XML Document" href="#dt-xml-doc">XML document</a> may, for <a title="Validity" href="#dt-valid">validation</a> purposes, be constrained using element type and attribute-list declarations. An element type declaration constrains the element's <a title="Content" href="#dt-content">content</a>.</p>
<p>要素型宣言はしばしば、どの要素型がその要素の<a title="親と子" href="#dt-parentchild">子</a>として現れ得るかを制限する。ある宣言が、宣言の無い要素型について言及した場合、XMLプロセッサは、ユーザが選択した場合、警告を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">出しても良い(MAY)</em>が、これはエラーではない。</p>
<p class="original" lang="en" xml:lang="en">Element type declarations often constrain which element types can appear as <a title="Parent/Child" href="#dt-parentchild">children</a> of the element. At user option, an XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> issue a warning when a declaration mentions an element type for which no declaration is provided, but this is not an error.</p>
<p>[<a name="dt-eldecl" id="dt-eldecl" title="要素型宣言">定義</a>: <b>要素型宣言</b>は次の形を採る。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: An <b>element type declaration</b> takes the form:]</p>
<h5><a name="IDAYPIS" id="IDAYPIS"></a>要素型宣言<span class="original" lang="en" xml:lang="en"> Element Type Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-elementdecl" id="NT-elementdecl"></a>[45]   </td>
		<td><code>elementdecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!ELEMENT' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a href="#NT-S">S</a> <a href="#NT-contentspec">contentspec</a> <a href="#NT-S">S</a>? '&gt;'</code></td>
		<td><a href="#EDUnique">[妥当性制約: 一意な要素型宣言]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-contentspec" id="NT-contentspec"></a>[46]   </td>
		<td><code>contentspec</code></td>
		<td>   ::=   </td>
		<td><code>'EMPTY' | 'ANY' | <a href="#NT-Mixed">Mixed</a> | <a href="#NT-children">children</a></code></td>
	</tr>
</tbody>
</table>
<p>ここで、<a href="#NT-Name">Name</a>は、宣言される要素型を与える。</p>
<p class="original" lang="en" xml:lang="en">where the <a href="#NT-Name">Name</a> gives the element type being declared.</p>
<div class="constraint">
	<p class="prefix"><a name="EDUnique" id="EDUnique"></a><b>妥当性制約: 一意な要素型宣言<span class="original" lang="en" xml:lang="en"> Validity constraint: Unique Element Type Declaration</span></b></p>
	<p>すべての要素型は、二回以上<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されてはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">An element type <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> be declared more than once.</p>
</div>
<p>要素型宣言の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of element type declarations:</p>
<div class="exampleInner">
<pre>
&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT p (#PCDATA|emph)* &gt;
&lt;!ELEMENT %name.para; %content.para; &gt;
&lt;!ELEMENT container ANY&gt;
</pre>
</div>

<div class="div3">
<h4><a name="sec-element-content" id="sec-element-content"></a>3.2.1 要素内容<span class="original" lang="en" xml:lang="en"> Element Content</span></h4>
<p>[<a name="dt-elemcontent" id="dt-elemcontent" title="要素内容">定義</a>: ある型の要素が<a title="親と子" href="#dt-parentchild">子</a>要素だけを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まなければならない(MUST)</em>時、その要素<a title="開始タグ" href="#dt-stag">型</a>は<b>要素内容</b>を持つ。但し、要素内容を持つ型の要素でも、子要素をホワイトスペース(非終端<a href="#NT-S">S</a>にマッチする文字列)で分ける事があっても良い。] [<a name="dt-content-model" id="dt-content-model" title="内容モデル">定義</a>: この場合、<b>内容モデル</b>が制約に追加される。内容モデルは、子要素として許される要素の型と、それらが現れ得る順番を支配する簡単な文法である。] この文法は、内容小片(<a href="#NT-cp">cp</a>)を基礎とする。内容小片は、次のように、名前、内容小片の選択リスト、あるいは内容小片の順序リストから成る。</p>
<p class="original" lang="en" xml:lang="en">[Definition: An element <a title="Start-Tag" href="#dt-stag">type</a> has <b>element content</b> when elements of that type <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> contain only <a title="Parent/Child" href="#dt-parentchild">child</a> elements (no character data), optionally separated by white space (characters matching the nonterminal <a href="#NT-S">S</a>).] [Definition: In this case, the constraint includes a <b>content model</b>, a simple grammar governing the allowed types of the child elements and the order in which they are allowed to appear.] The grammar is built on content particles (<a href="#NT-cp">cp</a>s), which consist of names, choice lists of content particles, or sequence lists of content particles:</p>
<h5><a name="IDATTIS" id="IDATTIS"></a>要素内容モデル<span class="original" lang="en" xml:lang="en"> Element-content Models</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-children" id="NT-children"></a>[47]   </td>
		<td><code>children</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-choice">choice</a> | <a href="#NT-seq">seq</a> ) ( '?' | '*' | '+' )?</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-cp" id="NT-cp"></a>[48]   </td>
		<td><code>cp</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-Name">Name</a> | <a href="#NT-choice">choice</a> | <a href="#NT-seq">seq</a> ) ( '?' | '*' | '+' )?</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-choice" id="NT-choice"></a>[49]   </td>
		<td><code>choice</code></td>
		<td>   ::=   </td>
		<td><code>'(' <a href="#NT-S">S</a>? <a href="#NT-cp">cp</a> ( <a href="#NT-S">S</a>? '|' <a href="#NT-S">S</a>? <a href="#NT-cp">cp</a> )+ <a href="#NT-S">S</a>? ')'</code></td>
		<td><a href="#vc-PEinGroup">[妥当性制約: グループとパラメータ実体の適切なネスト]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-seq" id="NT-seq"></a>[50]   </td>
		<td><code>seq</code></td>
		<td>   ::=   </td>
		<td><code>'(' <a href="#NT-S">S</a>? <a href="#NT-cp">cp</a> ( <a href="#NT-S">S</a>? ',' <a href="#NT-S">S</a>? <a href="#NT-cp">cp</a> )* <a href="#NT-S">S</a>? ')'</code></td>
		<td><a href="#vc-PEinGroup">[妥当性制約: グループとパラメータ実体の適切なネスト]</a></td>
	</tr>
</tbody>
</table>
<p>ここで、それぞれの<a href="#NT-Name">Name</a>は<a title="親と子" href="#dt-parentchild">子</a>として現れ得る要素の型である。選択リストに含まれる内容小片は何れも、その選択リストが文法の中で現れる場所に対応する<a title="要素内容" href="#dt-elemcontent">要素内容</a>の中の場所に現れて良い。一方、順序リストに含まれる内容小片はそれぞれ、そのリストで与えられる順番通りに<a title="要素内容" href="#dt-elemcontent">要素内容</a>の中に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れなければならない(MUST)</em>。名前やリストの後ろに任意に付ける事ができる文字は、その要素や内容小片が1回以上(<code>+</code>)、0回以上(<code>*</code>)、0回または1回(<code>?</code>)現れ得るかどうかを支配する。そのような演算子が無い場合は、その要素や内容小片がただ1回だけ<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れなければならない(MUST)</em>を意味する。この構文と意味は、この仕様書に登場する生成規則で使われているものと同じである。</p>
<p class="original" lang="en" xml:lang="en">where each <a href="#NT-Name">Name</a> is the type of an element which may appear as a <a title="Parent/Child" href="#dt-parentchild">child</a>. Any content particle in a choice list may appear in the <a title="Element content" href="#dt-elemcontent">element content</a> at the location where the choice list appears in the grammar; content particles occurring in a sequence list <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> each appear in the <a title="Element content" href="#dt-elemcontent">element content</a> in the order given in the list. The optional character following a name or list governs whether the element or the content particles in the list may occur one or more (<code>+</code>), zero or more (<code>*</code>), or zero or one times (<code>?</code>). The absence of such an operator means that the element or content particle <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> appear exactly once. This syntax and meaning are identical to those used in the productions in this specification.</p>
<p>順序、選択、繰り返し演算子に従って内容モデルを完全に辿る事ができ、なおかつ内容に含まれる要素が内容モデルに含まれる要素型にマッチする時にのみ、その要素の内容は内容モデルにマッチする。<a title="互換性の為に" href="#dt-compat">互換性の為に</a>、ある要素が内容モデルに現れる二つ以上の要素型に対して、何れにもマッチする事を内容モデルが許した場合はエラーとする。更なる情報は<a href="#determinism"><b>D 決定的内容モデル<span class="original" lang="en" xml:lang="en"> Deterministic Content Models</span></b></a>で確認してほしい。</p>
<p class="original" lang="en" xml:lang="en">The content of an element matches a content model if and only if it is possible to trace out a path through the content model, obeying the sequence, choice, and repetition operators and matching each element in the content against an element type in the content model. <a title="For Compatibility" href="#dt-compat">For compatibility</a>, it is an error if the content model allows an element to match more than one occurrence of an element type in the content model. For more information, see <a href="#determinism"><b>D Deterministic Content Models</b></a>.</p>
<div class="constraint">
	<p class="prefix"><a name="vc-PEinGroup" id="vc-PEinGroup"></a><b>妥当性制約: グループとパラメータ実体の適切なネスト<span class="original" lang="en" xml:lang="en"> Validity constraint: Proper Group/PE Nesting</span></b></p>
	<p>パラメータ実体の<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>は、括弧で囲まれたグループに関して適切に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">ネストされなければならない(MUST)</em>。それはつまり、<a href="#NT-choice">choice</a>、<a href="#NT-seq">seq</a>、あるいは<a href="#NT-Mixed">Mixed</a>構成子の開き括弧か閉じ括弧の何れかが<a title="パラメータ実体参照" href="#dt-PERef">パラメータ実体</a>の置換テキストに含まれる場合、両方とも同じ置換テキストの中に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まれなければならない(MUST)</em>という事である。</p>
	<p class="original" lang="en" xml:lang="en">Parameter-entity <a title="Replacement Text" href="#dt-repltext">replacement text</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be properly nested with parenthesized groups. That is to say, if either of the opening or closing parentheses in a <a href="#NT-choice">choice</a>, <a href="#NT-seq">seq</a>, or <a href="#NT-Mixed">Mixed</a> construct is contained in the replacement text for a <a title="Parameter-entity reference" href="#dt-PERef">parameter entity</a>, both <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be contained in the same replacement text.</p>
	<p><a title="相互運用性の為に" href="#dt-interop">相互運用性の為に</a>、パラメータ実体参照が<a href="#NT-choice">choice</a>、<a href="#NT-seq">seq</a>、あるいは<a href="#NT-Mixed">Mixed</a>構成子の中に現れる場合は、その置換テキストは最低一つの非空白文字を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含む事が望ましく(SHOULD)</em>、また、置換テキストの最初の非空白文字も最後の非空白文字も、接続子(<code>|</code>や<code>,</code>)では<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">ない事が望ましい(SHOULD)</em>。</p>
	<p class="original" lang="en" xml:lang="en"><a title="For interoperability" href="#dt-interop">For interoperability</a>, if a parameter-entity reference appears in a <a href="#NT-choice">choice</a>, <a href="#NT-seq">seq</a>, or <a href="#NT-Mixed">Mixed</a> construct, its replacement text <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> contain at least one non-blank character, and neither the first nor last non-blank character of the replacement text <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be a connector (<code>|</code> or <code>,</code>).</p>
</div>
<p>要素内容モデルの例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of element-content models:</p>
<div class="exampleInner">
<pre>
&lt;!ELEMENT spec (front, body, back?)&gt;
&lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
&lt;!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="sec-mixed-content" id="sec-mixed-content"></a>3.2.2 混合内容<span class="original" lang="en" xml:lang="en"> Mixed Content</span></h4>
<p>[<a name="dt-mixed" id="dt-mixed" title="混合内容">定義</a>: ある型の要素が文字データを含んで良い時、その要素<a title="開始タグ" href="#dt-stag">型</a>は<b>混合内容</b>を持つ。混合内容を持つ型の要素の内容には、随所に<a title="親と子" href="#dt-parentchild">子</a>要素を挿入しても良い。] この場合、子要素の型は制約を受けるが、その順番や出現回数は制約を受けない。</p>
<p class="original" lang="en" xml:lang="en">[Definition: An element <a title="Start-Tag" href="#dt-stag">type</a> has <b>mixed content</b> when elements of that type may contain character data, optionally interspersed with <a title="Parent/Child" href="#dt-parentchild">child</a> elements.] In this case, the types of the child elements may be constrained, but not their order or their number of occurrences:</p>
<h5><a name="IDAC2IS" id="IDAC2IS"></a>混合内容宣言<span class="original" lang="en" xml:lang="en"> Mixed-content Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Mixed" id="NT-Mixed"></a>[51]   </td>
		<td><code>Mixed</code></td>
		<td>   ::=   </td>
		<td><code>'(' <a href="#NT-S">S</a>? '#PCDATA' ( <a href="#NT-S">S</a>? '|' <a href="#NT-S">S</a>? <a href="#NT-Name">Name</a> )* <a href="#NT-S">S</a>? ')*'</code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| '(' <a href="#NT-S">S</a>? '#PCDATA' <a href="#NT-S">S</a>? ')'</code></td>
		<td><a href="#vc-PEinGroup">[妥当性制約: グループとパラメータ実体の適切なネスト]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#vc-MixedChildrenUnique">[妥当性制約: 一切無い重複する型]</a></td>
	</tr>
</tbody>
</table>
<p>ここで、<a href="#NT-Name">Name</a>は子として現れ得る要素の型を与える。キーワード<b>#PCDATA</b>は、歴史的な経緯で用語"parsed character data"(「解析対象文字データ」)から採られたものである。</p>
<p class="original" lang="en" xml:lang="en">where the <a href="#NT-Name">Name</a>s give the types of elements that may appear as children. The keyword <b>#PCDATA</b> derives historically from the term "parsed character data."</p>
<div class="constraint">
	<p class="prefix"><a name="vc-MixedChildrenUnique" id="vc-MixedChildrenUnique"></a><b>妥当性制約: 一切無い重複する型<span class="original" lang="en" xml:lang="en"> Validity constraint: No Duplicate Types</span></b></p>
	<p>一つの混合内容宣言において、同じ名前が二回以上<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The same name <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear more than once in a single mixed-content declaration.</p>
</div>
<p>混合内容宣言の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of mixed content declarations:</p>
<div class="exampleInner">
<pre>
&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
&lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* &gt;
&lt;!ELEMENT b (#PCDATA)&gt;
</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="attdecls" id="attdecls"></a>3.3 属性リスト宣言<span class="original" lang="en" xml:lang="en"> Attribute-List Declarations</span></h3>
<p><a title="属性" href="#dt-attr">属性</a>は、名前と値の組を<a title="要素" href="#dt-element">要素</a>に関連付ける為に使われる。属性指定は<a title="開始タグ" href="#dt-stag">開始タグ</a>や<a title="空要素タグ" href="#dt-eetag">空要素タグ</a>の外に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。この為、属性指定を認識する為の生成規則はすべて<a href="#sec-starttags"><b>3.1 開始タグ、終了タグ、空要素タグ<span class="original" lang="en" xml:lang="en"> Start-Tags, End-Tags, and Empty-Element Tags</span></b></a>にある。一方、属性リスト宣言は次の目的の為に使われる事がある。</p>
<p class="original" lang="en" xml:lang="en"><a title="Attribute" href="#dt-attr">Attributes</a> are used to associate name-value pairs with <a title="Element" href="#dt-element">elements</a>. Attribute specifications <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear outside of <a title="Start-Tag" href="#dt-stag">start-tags</a> and <a title="empty-element tag" href="#dt-eetag">empty-element tags</a>; thus, the productions used to recognize them appear in <a href="#sec-starttags"><b>3.1 Start-Tags, End-Tags, and Empty-Element Tags</b></a>. Attribute-list declarations may be used:</p>
<ul>
	<li>
		<p>与えられた要素型に関連する属性の組を定義する為。</p>
		<p class="original" lang="en" xml:lang="en">To define the set of attributes pertaining to a given element type.</p>
	</li>
	<li>
		<p>それらの属性に対する型の制約を確立する為。</p>
		<p class="original" lang="en" xml:lang="en">To establish type constraints for these attributes.</p>
	</li>
	<li>
		<p>属性に<a title="属性デフォルト" href="#dt-default">デフォルト値</a>を提供する為。</p>
		<p class="original" lang="en" xml:lang="en">To provide <a title="Attribute Default" href="#dt-default">default values</a> for attributes.</p>
	</li>
</ul>
<p>[<a name="dt-attdecl" id="dt-attdecl" title="属性リスト宣言">定義</a>: <b>属性リスト宣言</b>は、与えられた要素型に関連付けられたそれぞれの属性の名前、データ型、そして(もしあれば)デフォルト値を指定する。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Attribute-list declarations</b> specify the name, data type, and default value (if any) of each attribute associated with a given element type:]</p>
<h5><a name="IDAUAJS" id="IDAUAJS"></a>属性リスト宣言<span class="original" lang="en" xml:lang="en"> Attribute-list Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-AttlistDecl" id="NT-AttlistDecl"></a>[52]   </td>
		<td><code>AttlistDecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!ATTLIST' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a href="#NT-AttDef">AttDef</a>* <a href="#NT-S">S</a>? '&gt;'</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-AttDef" id="NT-AttDef"></a>[53]   </td>
		<td><code>AttDef</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a href="#NT-S">S</a> <a href="#NT-AttType">AttType</a> <a href="#NT-S">S</a> <a href="#NT-DefaultDecl">DefaultDecl</a></code></td>
	</tr>
</tbody>
</table>
<p><a href="#NT-AttlistDecl">AttlistDecl</a>規則の<a href="#NT-Name">Name</a>は、要素の型である。ユーザが選択した場合、XMLプロセッサは、それ自身が宣言されていない要素に対して属性が宣言された場合に警告を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">出しても良い(MAY)</em>が、これはエラーではない。<a href="#NT-AttDef">AttDef</a>規則の<a href="#NT-Name">Name</a>は属性の名前である。</p>
<p class="original" lang="en" xml:lang="en">The <a href="#NT-Name">Name</a> in the <a href="#NT-AttlistDecl">AttlistDecl</a> rule is the type of an element. At user option, an XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> issue a warning if attributes are declared for an element type not itself declared, but this is not an error. The <a href="#NT-Name">Name</a> in the <a href="#NT-AttDef">AttDef</a> rule is the name of the attribute.</p>
<p>一つの要素型に対して二つ以上の<a href="#NT-AttlistDecl">AttlistDecl</a>が与えられた場合、それらの内容はすべて混ぜ合わされる。ある要素型の同じ属性に対して二つ以上の定義が与えられた場合、最初に現れたものが関連付けられ、その後に現れた宣言はすべて無視される。<a title="相互運用性の為に" href="#dt-interop">相互運用性の為に</a>、DTDの作成者は、一つの要素型に対して多くとも一つの属性リスト宣言しか書かず、一つの属性リスト宣言の中では一つの属性に対して多くとも一つの属性定義しか用意しないようにし、それぞれの属性リスト宣言には少なくとも一つの属性定義を与えるようにしても良い。また、相互運用性の為に、XMLプロセッサは、ユーザが選択した場合、一つの要素型に対して二つ以上の属性リスト宣言が与えられた場合や、一つの属性に対して二つ以上の定義が与えられた場合、警告を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">出しても良い(MAY)</em>が、これはエラーではない。</p>
<p class="original" lang="en" xml:lang="en">When more than one <a href="#NT-AttlistDecl">AttlistDecl</a> is provided for a given element type, the contents of all those provided are merged. When more than one definition is provided for the same attribute of a given element type, the first declaration is binding and later declarations are ignored. <a title="For interoperability" href="#dt-interop">For interoperability,</a> writers of DTDs may choose to provide at most one attribute-list declaration for a given element type, at most one attribute definition for a given attribute name in an attribute-list declaration, and at least one attribute definition in each attribute-list declaration. For interoperability, an XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> at user option issue a warning when more than one attribute-list declaration is provided for a given element type, or more than one attribute definition is provided for a given attribute, but this is not an error.</p>

<div class="div3">
<h4><a name="sec-attribute-types" id="sec-attribute-types"></a>3.3.1 属性型<span class="original" lang="en" xml:lang="en"> Attribute Types</span></h4>
<p>XML属性型には、文字列型、トークン化対象型、列挙型の三つの種類がある。文字列型は任意のリテラル文字列を値に持つ一方、トークン化対象型はより多くの制約を受ける。文法に註記されている妥当性制約は、<a href="#AVNormalize"><b>3.3.3 属性値の正規化<span class="original" lang="en" xml:lang="en"> Attribute-Value Normalization</span></b></a>で説明されるように属性値が正規化された後で適用される。</p>
<p class="original" lang="en" xml:lang="en">XML attribute types are of three kinds: a string type, a set of tokenized types, and enumerated types. The string type may take any literal string as a value; the tokenized types are more constrained. The validity constraints noted in the grammar are applied after the attribute value has been normalized as described in <a href="#AVNormalize"><b>3.3.3 Attribute-Value Normalization</b></a>.</p>
<h5><a name="IDAVEJS" id="IDAVEJS"></a>属性型<span class="original" lang="en" xml:lang="en"> Attribute Types</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-AttType" id="NT-AttType"></a>[54]   </td>
		<td><code>AttType</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-StringType">StringType</a> | <a href="#NT-TokenizedType">TokenizedType</a> | <a href="#NT-EnumeratedType">EnumeratedType</a></code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-StringType" id="NT-StringType"></a>[55]   </td>
		<td><code>StringType</code></td>
		<td>   ::=   </td>
		<td><code>'CDATA'</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-TokenizedType" id="NT-TokenizedType"></a>[56]   </td>
		<td><code>TokenizedType</code></td>
		<td>   ::=   </td>
		<td><code>'ID'</code></td>
		<td><a href="#id">[妥当性制約: ID]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#one-id-per-el">[妥当性制約: 一つの要素型に一つのID]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#id-default">[妥当性制約: IDの属性デフォルト]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'IDREF'</code></td>
		<td><a href="#idref">[妥当性制約: IDREF]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'IDREFS'</code></td>
		<td><a href="#idref">[妥当性制約: IDREF]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'ENTITY'</code></td>
		<td><a href="#entname">[妥当性制約: 実体名]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'ENTITIES'</code></td>
		<td><a href="#entname">[妥当性制約: 実体名]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'NMTOKEN'</code></td>
		<td><a href="#nmtok">[妥当性制約: 名前トークン]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'NMTOKENS'</code></td>
		<td><a href="#nmtok">[妥当性制約: 名前トークン]</a></td>
	</tr>
</tbody>
</table>
<div class="constraint">
	<p class="prefix"><a name="id" id="id"></a><b>妥当性制約: ID<span class="original" lang="en" xml:lang="en"> Validity constraint: ID</span></b></p>
	<p>型<b>ID</b>の値は<a href="#NT-Name">Name</a>生成規則に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。ある名前がXML文書の中でこの型として二回以上<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。つまり、ID値はその値を持つ要素を一意に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">識別しなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Values of type <b>ID</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the <a href="#NT-Name">Name</a> production. A name <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear more than once in an XML document as a value of this type; i.e., ID values <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> uniquely identify the elements which bear them.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="one-id-per-el" id="one-id-per-el"></a><b>妥当性制約: 一つの要素型に一つのID<span class="original" lang="en" xml:lang="en"> Validity constraint: One ID per Element Type</span></b></p>
	<p>一つの要素型が二つ以上のID属性を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">持ってはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">An element type <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> have more than one ID attribute specified.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="id-default" id="id-default"></a><b>妥当性制約: IDの属性デフォルト<span class="original" lang="en" xml:lang="en"> Validity constraint: ID Attribute Default</span></b></p>
	<p>ID属性は<b>#IMPLIED</b>か<b>#REQUIRED</b>と宣言されたデフォルトを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">持たなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">An ID attribute <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> have a declared default of <b>#IMPLIED</b> or <b>#REQUIRED</b>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="idref" id="idref"></a><b>妥当性制約: IDREF<span class="original" lang="en" xml:lang="en"> Validity constraint: IDREF</span></b></p>
	<p>型<b>IDREF</b>の値は<a href="#NT-Name">Name</a>生成規則に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならず(MUST)</em>、型<b>IDREFS</b>の値は<a href="#NT-Names">Names</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。それぞれの<a href="#NT-Name">Name</a>は、そのXML文書に含まれるある要素のID属性の値に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。つまり、<b>IDREF</b>値はあるID属性の値に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Values of type <b>IDREF</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the <a href="#NT-Name">Name</a> production, and values of type <b>IDREFS</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match <a href="#NT-Names">Names</a>; each <a href="#NT-Name">Name</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the value of an ID attribute on some element in the XML document; i.e. <b>IDREF</b> values <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the value of some ID attribute.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="entname" id="entname"></a><b>妥当性制約: 実体名<span class="original" lang="en" xml:lang="en"> Validity constraint: Entity Name</span></b></p>
	<p>型<b>ENTITY</b>の値は<a href="#NT-Name">Name</a>生成規則に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならず(MUST)</em>、型<b>ENTITIES</b>の値は<a href="#NT-Names">Names</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。それぞれの<a href="#NT-Name">Name</a>は、<a title="文書型宣言" href="#dt-doctype">DTD</a>で定義された<a title="解析対象外実体" href="#dt-unparsed">解析対象外実体</a>の名前に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Values of type <b>ENTITY</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the <a href="#NT-Name">Name</a> production, values of type <b>ENTITIES</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match <a href="#NT-Names">Names</a>; each <a href="#NT-Name">Name</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the name of an <a title="Unparsed Entity" href="#dt-unparsed">unparsed entity</a> declared in the <a title="Document Type Declaration" href="#dt-doctype">DTD</a>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="nmtok" id="nmtok"></a><b>妥当性制約: 名前トークン<span class="original" lang="en" xml:lang="en"> Validity constraint: Name Token</span></b></p>
	<p>型<b>NMTOKEN</b>の値は<a href="#NT-Nmtoken">Nmtoken</a>生成規則に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならず(MUST)</em>、型<b>NMTOKENS</b>の値は<a href="#NT-Nmtokens">Nmtokens</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Values of type <b>NMTOKEN</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the <a href="#NT-Nmtoken">Nmtoken</a> production; values of type <b>NMTOKENS</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match <a href="#NT-Nmtokens">Nmtokens</a>.</p>
</div>
<p>[<a name="dt-enumerated" id="dt-enumerated" title="列挙属性値">定義</a>: <b>列挙属性</b>は、許される値のリストを宣言に持つ。] 列挙属性は、それらの値の中の一つを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">持たなければならない(MUST)</em>。列挙属性型には、次のように二種類ある。</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Enumerated attributes</b> have a list of allowed values in their declaration]. <span>They <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> take one of those values. </span>There are two kinds of enumerated attribute types:</p>
<h5><a name="IDAANJS" id="IDAANJS"></a>列挙属性型<span class="original" lang="en" xml:lang="en"> Enumerated Attribute Types</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EnumeratedType" id="NT-EnumeratedType"></a>[57]   </td>
		<td><code>EnumeratedType</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-NotationType">NotationType</a> | <a href="#NT-Enumeration">Enumeration</a></code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-NotationType" id="NT-NotationType"></a>[58]   </td>
		<td><code>NotationType</code></td>
		<td>   ::=   </td>
		<td><code>'NOTATION' <a href="#NT-S">S</a> '(' <a href="#NT-S">S</a>? <a href="#NT-Name">Name</a> ( <a href="#NT-S">S</a>? '|' <a href="#NT-S">S</a>? <a href="#NT-Name">Name</a> )* <a href="#NT-S">S</a>? ')'</code></td>
		<td><a href="#notatn">[妥当性制約: 記法属性]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#OneNotationPer">[妥当性制約: 一つの要素型に一つの記法]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#NoNotationEmpty">[妥当性制約: 空要素に一切無い記法]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#NoDuplicateTokens">[妥当性制約: 一切無い重複するトークン]</a></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Enumeration" id="NT-Enumeration"></a>[59]   </td>
		<td><code>Enumeration</code></td>
		<td>   ::=   </td>
		<td><code>'(' <a href="#NT-S">S</a>? <a href="#NT-Nmtoken">Nmtoken</a> ( <a href="#NT-S">S</a>? '|' <a href="#NT-S">S</a>? <a href="#NT-Nmtoken">Nmtoken</a> )* <a href="#NT-S">S</a>? ')'</code></td>
		<td><a href="#enum">[妥当性制約: 列挙]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#NoDuplicateTokens">[妥当性制約: 一切無い重複するトークン]</a></td>
	</tr>
</tbody>
</table>
<p><b>NOTATION</b>属性は、その属性が付けられた要素を解釈する際に使えるようにする為、<a title="記法" href="#dt-notation">記法</a>を識別する。記法は、関連付けられたシステム識別子と公開識別子の両方、あるいは片方と共にDTDの中で宣言される。</p>
<p class="original" lang="en" xml:lang="en">A <b>NOTATION</b> attribute identifies a <a title="Notation" href="#dt-notation">notation</a>, declared in the DTD with associated system and/or public identifiers, to be used in interpreting the element to which the attribute is attached.</p>
<div class="constraint">
	<p class="prefix"><a name="notatn" id="notatn"></a><b>妥当性制約: 記法属性<span class="original" lang="en" xml:lang="en"> Validity constraint: Notation Attributes</span></b></p>
	<p>この型の値は、その宣言に含まれる<a href="#Notations"><cite>記法</cite></a>名の内の一つに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。その宣言が採り得る記法名はすべて<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されていなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Values of this type <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match one of the <a href="#Notations"><cite>notation</cite></a> names included in the declaration; all notation names in the declaration <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be declared.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="OneNotationPer" id="OneNotationPer"></a><b>妥当性制約: 一つの要素型に一つの記法<span class="original" lang="en" xml:lang="en"> Validity constraint: One Notation Per Element Type</span></b></p>
	<p>一つの要素型が二つ以上の<b>NOTATION</b>属性を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">持ってはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">An element type <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> have more than one <b>NOTATION</b> attribute specified.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="NoNotationEmpty" id="NoNotationEmpty"></a><b>妥当性制約: 空要素に一切無い記法<span class="original" lang="en" xml:lang="en"> Validity constraint: No Notation on Empty Element</span></b></p>
	<p><a title="互換性の為に" href="#dt-compat">互換性の為に</a>、型<b>NOTATION</b>の属性は<b>EMPTY</b>と宣言された属性に対して<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されてはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en"><a title="For Compatibility" href="#dt-compat">For compatibility</a>, an attribute of type <b>NOTATION</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> be declared on an element declared <b>EMPTY</b>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="NoDuplicateTokens" id="NoDuplicateTokens"></a><b>妥当性制約: 一切無い重複するトークン<span class="original" lang="en" xml:lang="en"> Validity constraint: No Duplicate Tokens</span></b></p>
	<p><a href="#NT-NotationType">NotationType</a>属性宣言のすべての記法名や、<a href="#NT-Enumeration">Enumeration</a>属性宣言のすべての<a href="#NT-Nmtoken">NmToken</a>は、一つの宣言の中では互いに別個のもので<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">なければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The notation names in a single <a href="#NT-NotationType">NotationType</a> attribute declaration, as well as the <a href="#NT-Nmtoken">NmToken</a>s in a single <a href="#NT-Enumeration">Enumeration</a> attribute declaration, <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> all be distinct.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="enum" id="enum"></a><b>妥当性制約: 列挙<span class="original" lang="en" xml:lang="en"> Validity constraint: Enumeration</span></b></p>
	<p>この型の値は、その宣言に含まれる<a href="#NT-Nmtoken">Nmtoken</a>トークンの内の一つに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Values of this type <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match one of the <a href="#NT-Nmtoken">Nmtoken</a> tokens in the declaration.</p>
</div>
<p><a title="相互運用性の為に" href="#dt-interop">相互運用性の為に</a>、一つの要素型が持つ複数の列挙属性型の間でも、同じ<a href="#NT-Nmtoken">Nmtoken</a>が二回以上<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れる事は望ましくない(SHOULD NOT)</em>。</p>
<p class="original" lang="en" xml:lang="en"><a title="For interoperability" href="#dt-interop">For interoperability,</a> the same <a href="#NT-Nmtoken">Nmtoken</a> <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD NOT</em> occur more than once in the enumerated attribute types of a single element type.</p>
</div>

<div class="div3">
<h4><a name="sec-attr-defaults" id="sec-attr-defaults"></a>3.3.2 属性デフォルト<span class="original" lang="en" xml:lang="en"> Attribute Defaults</span></h4>
<p><a title="属性リスト宣言" href="#dt-attdecl">属性宣言</a>は、その属性の<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">存在が必須である(REQUIRED)</em>かどうかについて情報を提供する。もし必須でなければ、宣言された属性が文書中に無かった時にXMLプロセッサがどう対応すべきかについて情報を提供する。</p>
<p class="original" lang="en" xml:lang="en">An <a title="Attribute-List Declaration" href="#dt-attdecl">attribute declaration</a> provides information on whether the attribute's presence is <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em>, and if not, how an XML processor is to react if a declared attribute is absent in a document.</p>
<h5><a name="IDAGUJS" id="IDAGUJS"></a>属性デフォルト<span class="original" lang="en" xml:lang="en"> Attribute Defaults</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-DefaultDecl" id="NT-DefaultDecl"></a>[60]   </td>
		<td><code>DefaultDecl</code></td>
		<td>   ::=   </td>
		<td><code>'#REQUIRED' | '#IMPLIED'</code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| ( ( '#FIXED' <a href="#NT-S">S</a> )? <a href="#NT-AttValue">AttValue</a> )</code></td>
		<td><a href="#RequiredAttr">[妥当性制約: 必須属性]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#defattrvalid">[妥当性制約: 構文的に正しい属性デフォルト値]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#CleanAttrVals">[整形式性制約: 属性値の中に一切無い&lt;]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#FixedAttr">[妥当性制約: 固定属性デフォルト]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#NoExternalRefs">[整形式性制約: 一切無い外部実体参照]</a></td>
	</tr>
</tbody>
</table>
<p>属性宣言では、<b>#REQUIRED</b>は、その属性が常に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">提供されなければならない(MUST)</em>事を意味し、<b>#IMPLIED</b>は、デフォルト値が提供されない事を意味する。 [<a name="dt-default" id="dt-default" title="属性デフォルト">定義</a>: もし宣言が<b>#REQUIRED</b>でも<b>#IMPLIED</b>でもなければ、<a href="#NT-AttValue">AttValue</a>値は宣言された<b>デフォルト</b>値を持つ。<b>#FIXED</b>キーワードは、その属性が常にデフォルト値を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">持たなければならない(MUST)</em>事を示す。XMLプロセッサは、デフォルト値宣言を読み取ってある属性について、その属性の指定が無い要素を見つけた場合は、その属性が宣言されたデフォルト値を持つものとしてアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しなければならない(MUST)</em>。]</p>
<p class="original" lang="en" xml:lang="en">In an attribute declaration, <b>#REQUIRED</b> means that the attribute <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> always be provided, <b>#IMPLIED</b> that no default value is provided. [Definition: If the declaration is neither <b>#REQUIRED</b> nor <b>#IMPLIED</b>, then the <a href="#NT-AttValue">AttValue</a> value contains the declared <b>default</b> value; the <b>#FIXED</b> keyword states that the attribute <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> always have the default value. When an XML processor encounters an element without a specification for an attribute for which it has read a default value declaration, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> report the attribute with the declared default value to the application.]</p>
<div class="constraint">
	<p class="prefix"><a name="RequiredAttr" id="RequiredAttr"></a><b>妥当性制約: 必須属性<span class="original" lang="en" xml:lang="en"> Validity constraint: Required Attribute</span></b></p>
	<p>もしデフォルト宣言がキーワード<b>#REQUIRED</b>であれば、属性リスト宣言でその属性が宣言された要素型の要素すべてに対してその属性が<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">指定されなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">If the default declaration is the keyword <b>#REQUIRED</b>, then the attribute <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be specified for all elements of the type in the attribute-list declaration.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="defattrvalid" id="defattrvalid"></a><b>妥当性制約: 構文的に正しい属性デフォルト値<span class="original" lang="en" xml:lang="en"> Validity constraint: Attribute Default Value Syntactically Correct</span></b></p>
	<p>宣言されたデフォルト値は、その属性型の構文上の制約を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">満たさなければならない(MUST)</em>。つまり、次の何れかを満たさなければならない。</p>
	<p class="original" lang="en" xml:lang="en">The declared default value <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> meet the syntactic constraints of the declared attribute type. That is, the default value of an attribute:</p>
	<ul>
		<li>
			<p>型IDREFや型ENTITYの属性のデフォルト値は、<a href="#NT-Name">Name</a>生成規則にマッチしなければならない。</p>
			<p class="original" lang="en" xml:lang="en">of type IDREF or ENTITY must match the <a href="#NT-Name">Name</a> production;</p>
		</li>
		<li>
			<p>型IDREFSや型ENTITIESの属性のデフォルト値は、<a href="#NT-Names">Names</a>生成規則にマッチしなければならない。</p>
			<p class="original" lang="en" xml:lang="en">of type IDREFS or ENTITIES must match the <a href="#NT-Names">Names</a> production;</p>
		</li>
		<li>
			<p>型NMTOKENの属性のデフォルト値は、<a href="#NT-Nmtoken">Nmtoken</a>生成規則にマッチしなければならない。</p>
			<p class="original" lang="en" xml:lang="en">of type NMTOKEN must match the <a href="#NT-Nmtoken">Nmtoken</a> production;</p>
		</li>
		<li>
			<p>型NMTOKENSの属性のデフォルト値は、<a href="#NT-Nmtokens">Nmtokens</a>生成規則にマッチしなければならない。</p>
			<p class="original" lang="en" xml:lang="en">of type NMTOKENS must match the <a href="#NT-Nmtokens">Nmtokens</a> production;</p>
		</li>
		<li>
			<p><a href="#NT-EnumeratedType">列挙型</a>(<a href="#NT-NotationType">NOTATION</a>型や<a href="#NT-Enumeration">列挙</a>)の属性のデフォルト値は、列挙された値の内の一つにマッチしなければならない。</p>
			<p class="original" lang="en" xml:lang="en">of an <a href="#NT-EnumeratedType">enumerated type</a> (either a <a href="#NT-NotationType">NOTATION</a> type or an <a href="#NT-Enumeration">enumeration</a>) must match one of the enumerated values.</p>
		</li>
	</ul>
	<p>ここでは、その型の構文的な制約だけが必要である事に注意してほしい。他の制約(例えば、型ENTITYの属性では、その値は宣言された解析対象外実体の名前でなければならない、など)は、その属性の指定を持たない要素が実際に現れた時にのみ、妥当性を検証するパーサによって報告されるだろう。</p>
	<p class="original" lang="en" xml:lang="en">Note that only the syntactic constraints of the type are required here; other constraints (e.g. that the value be the name of a declared unparsed entity, for an attribute of type ENTITY) will be reported by a validating parser only if an element without a specification for this attribute actually occurs.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="FixedAttr" id="FixedAttr"></a><b>妥当性制約: 固定属性デフォルト<span class="original" lang="en" xml:lang="en"> Validity constraint: Fixed Attribute Default</span></b></p>
	<p>ある属性が<b>#FIXED</b>キーワードと共に宣言されたデフォルト値を持つ場合は、その属性のインスタンスはそのデフォルト値に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">If an attribute has a default value declared with the <b>#FIXED</b> keyword, instances of that attribute <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the default value.</p>
</div>
<p>属性リスト宣言の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of attribute-list declarations:</p>
<div class="exampleInner">
<pre>
&lt;!ATTLIST termdef
id      ID      #REQUIRED
name    CDATA   #IMPLIED&gt;
&lt;!ATTLIST list
type    (bullets|ordered|glossary)  "ordered"&gt;
&lt;!ATTLIST form
method  CDATA   #FIXED "POST"&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="AVNormalize" id="AVNormalize"></a>3.3.3 属性値正規化<span class="original" lang="en" xml:lang="en"> Attribute-Value Normalization</span></h4>
<p>ある属性の値をアプリケーションに渡したり、妥当性を検査したりする前に、XMLプロセッサは、以下に示されるアルゴリズムを適用する事で、属性値を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">正規化しなければならない(MUST)</em>。アプリケーションに渡される値がこのアルゴリズムによって生成されるものと同じになる他の手段を用いても良い。</p>
<p class="original" lang="en" xml:lang="en">Before the value of an attribute is passed to the application or checked for validity, the XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> normalize the attribute value by applying the algorithm below, or by using some other method such that the value passed to the application is the same as that produced by the algorithm.</p>
<ol class="enumar">
	<li>
		<p>このアルゴリズムの残りの部分が正規化されたテキストに対して操作を行えるようにする為、<a href="#sec-line-ends"><b>2.11 行末の取り扱い<span class="original" lang="en" xml:lang="en"> End-of-Line Handling</span></b></a>で説明されているように、入力の改行はすべて#xAに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">正規化されていなければならない(MUST)</em>。</p>
		<p class="original" lang="en" xml:lang="en">All line breaks <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> have been normalized on input to #xA as described in <a href="#sec-line-ends"><b>2.11 End-of-Line Handling</b></a>, so the rest of this algorithm operates on text normalized in this way.</p>
	</li>
	<li>
		<p>空の文字列から成る正規化済み値を準備する。</p>
		<p class="original" lang="en" xml:lang="en">Begin with a normalized value consisting of the empty string.</p>
	</li>
	<li>
		<p>未正規化値の最初から最後まで、文字、実体参照、文字参照それぞれについて、次の事を行う。</p>
		<p class="original" lang="en" xml:lang="en">For each character, entity reference, or character reference in the unnormalized attribute value, beginning with the first and continuing to the last, do the following:</p>
		<ul>
			<li>
				<p>文字参照について、参照された文字を正規化済み値に追加する。</p>
				<p class="original" lang="en" xml:lang="en">For a character reference, append the referenced character to the normalized value.</p>
			</li>
			<li>
				<p>実体参照について、このアルゴリズムのステップ3をその実体の置換テキストに再帰的に適用する。</p>
				<p class="original" lang="en" xml:lang="en">For an entity reference, recursively apply step 3 of this algorithm to the replacement text of the entity.</p>
			</li>
			<li>
				<p>ホワイトスペース文字(#x20、#xD、#xA、#x9)について、スペース文字(#x20)を正規化済み値に追加する。</p>
				<p class="original" lang="en" xml:lang="en">For a white space character (#x20, #xD, #xA, #x9), append a space character (#x20) to the normalized value.</p>
			</li>
			<li>
				<p>その他の文字について、その文字をそのまま正規化済み値に追加する。</p>
				<p class="original" lang="en" xml:lang="en">For another character, append the character to the normalized value.</p>
			</li>
		</ul>
	</li>
</ol>
<p>属性型がCDATAでなければ、XMLプロセッサは更に正規化済み値に対して、先頭や末尾のスペース文字(#x20)列を取り除き、他のスペース文字(#x20)列を一つのスペース文字(#x20)で置き換える処理を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">If the attribute type is not CDATA, then the XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by a single space (#x20) character.</p>
<p>未正規化値が、スペース(#x20)以外のホワイトスペース文字への文字参照を含む場合、正規化済み値は参照された文字そのもの(#xDや#xA、#x9)を含む事に注意してほしい。これは、未正規化値が(参照でない)ホワイトスペース文字を含む場合と対照を成す。その場合、ホワイトスペース文字はスペース文字(#x20)に置き換えられる。また、未正規化値が、置換テキストがホワイトスペース文字を含む実体参照を含む場合とも対照を成す。この場合は、再帰的に処理されて、ホワイトスペース文字は正規化済み値のスペース文字(#x20)に置き換えられる。</p>
<p class="original" lang="en" xml:lang="en">Note that if the unnormalized attribute value contains a character reference to a white space character other than space (#x20), the normalized value contains the referenced character itself (#xD, #xA or #x9). This contrasts with the case where the unnormalized value contains a white space character (not a reference), which is replaced with a space character (#x20) in the normalized value and also contrasts with the case where the unnormalized value contains an entity reference whose replacement text contains a white space character; being recursively processed, the white space character is replaced with a space character (#x20) in the normalized value.</p>
<p>妥当性を検証しないプロセッサでは、宣言が読み取られなかった属性はすべて<b>CDATA</b>と宣言されたかの如く<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">扱われる事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">All attributes for which no declaration has been read <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be treated by a non-validating processor as if declared <b>CDATA</b>.</p>
<p><a title="属性値" href="#dt-attrval">属性値</a>が、宣言が読み取られなかった実体への<a title="実体参照" href="#dt-entref">参照</a>を含んだ場合はエラーとなる。</p>
<p class="original" lang="en" xml:lang="en">It is an error if an <a title="Attribute Value" href="#dt-attrval">attribute value</a> contains a <a title="Entity Reference" href="#dt-entref">reference</a> to an entity for which no declaration has been read.</p>
<p>次に挙げるのは属性正規化の例である。ここでは次の宣言を既に与えられたものとする。</p>
<p class="original" lang="en" xml:lang="en">Following are examples of attribute normalization. Given the following declarations:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY d "&amp;#xD;"&gt;
&lt;!ENTITY a "&amp;#xA;"&gt;
&lt;!ENTITY da "&amp;#xD;&amp;#xA;"&gt;
</pre>
</div>
<p>下の表の左の列に書かれた属性指定は、属性<code>a</code>が<b>NMTOKENS</b>と宣言されているならば真ん中の列の一連の文字のように、<code>a</code>が<b>CDATA</b>と宣言されていれば右の列の一連の文字のように正規化される事だろう。</p>
<p class="original" lang="en" xml:lang="en">the attribute specifications in the left column below would be normalized to the character sequences of the middle column if the attribute <code>a</code> is declared <b>NMTOKENS</b> and to those of the right columns if <code>a</code> is declared <b>CDATA</b>.</p>
<table border="1" frame="border" summary="属性正規化の要約">
<thead>
	<tr>
		<th>属性指定<span class="original" lang="en" xml:lang="en"> Attribute specification</span></th><th>aがNMTOKENSの時<span class="original" lang="en" xml:lang="en"> a is NMTOKENS</span></th><th>aがCDATAの時<span class="original" lang="en" xml:lang="en"> a is CDATA</span></th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>
<div class="exampleInner">
<pre>
a="
xyz"
</pre>
</div>
		</td>
		<td>
<div class="exampleInner">
<pre>
x y z
</pre>
</div>
		</td>
		<td>
<div class="exampleInner">
<pre>
#x20 #x20 x y z
</pre>
</div>
		</td>
	</tr>
	<tr>
		<td>
<div class="exampleInner">
<pre>
a="&amp;d;&amp;d;A&amp;a;&amp;#x20;&amp;a;B&amp;da;"
</pre>
</div>
		</td>
		<td>
<div class="exampleInner">
<pre>
A #x20 B
</pre>
</div>
</td>
		<td>
<div class="exampleInner">
<pre>
#x20 #x20 A #x20 #x20 #x20 B #x20 #x20
</pre>
</div>
		</td>
	</tr>
	<tr>
		<td>
<div class="exampleInner">
<pre>
a=
"&amp;#xd;&amp;#xd;A&amp;#xa;&amp;#xa;B&amp;#xd;&amp;#xa;"
</pre>
</div>
		</td>
		<td>
<div class="exampleInner">
<pre>
#xD #xD A #xA #xA B #xD #xA
</pre>
</div>
		</td>
		<td>
<div class="exampleInner">
<pre>
#xD #xD A #xA #xA B #xD #xA
</pre>
</div>
		</td>
	</tr>
</tbody>
</table>
<p>最後の例は、<code>a</code>が型<b>NMTOKENS</b>となるよう宣言された場合には妥当でない事に注意してほしい(整形式ではある)。</p>
<p class="original" lang="en" xml:lang="en">Note that the last example is invalid (but well-formed) if <code>a</code> is declared to be of type <b>NMTOKENS</b>.</p>
</div>
</div>

<div class="div2">
<h3><a name="sec-condition-sect" id="sec-condition-sect"></a>3.4 条件付きセクション<span class="original" lang="en" xml:lang="en"> Conditional Sections</span></h3>
<p>[<a name="dt-cond-section" id="dt-cond-section" title="conditional section">Definition</a>: <b>条件付きセクション</b>は、条件を支配するキーワードによってDTDの論理構造に取り込まれたり除外されたりする<a title="文書型宣言" href="#dt-doctype">文書型宣言の外部サブセット</a>の一部、あるいは外部パラメータ実体の一部である。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Conditional sections</b> are portions of the <a title="Document Type Declaration" href="#dt-doctype">document type declaration external subset</a> or of external parameter entities which are included in, or excluded from, the logical structure of the DTD based on the keyword which governs them.]</p>
<h5><a name="IDA1AKS" id="IDA1AKS"></a>条件付きセクション<span class="original" lang="en" xml:lang="en"> Conditional Section</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-conditionalSect" id="NT-conditionalSect"></a>[61]   </td>
		<td><code>conditionalSect</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-includeSect">includeSect</a> | <a href="#NT-ignoreSect">ignoreSect</a></code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-includeSect" id="NT-includeSect"></a>[62]   </td>
		<td><code>includeSect</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;![' <a href="#NT-S">S</a>? 'INCLUDE' <a href="#NT-S">S</a>? '[' <a href="#NT-extSubsetDecl">extSubsetDecl</a> ']]&gt;'</code></td>
		<td><a href="#condsec-nesting">[妥当性制約: 条件付きセクションとパラメータ実体の適切なネスト]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-ignoreSect" id="NT-ignoreSect"></a>[63]   </td>
		<td><code>ignoreSect</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;![' <a href="#NT-S">S</a>? 'IGNORE' <a href="#NT-S">S</a>? '[' <a href="#NT-ignoreSectContents">ignoreSectContents</a>* ']]&gt;'</code></td>
		<td><a href="#condsec-nesting">[妥当性制約: 条件付きセクションとパラメータ実体の適切なネスト]</a></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-ignoreSectContents" id="NT-ignoreSectContents"></a>[64]   </td>
		<td><code>ignoreSectContents</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Ignore">Ignore</a> ( '&lt;![' <a href="#NT-ignoreSectContents">ignoreSectContents</a> ']]&gt;' <a href="#NT-Ignore">Ignore</a> )*</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-Ignore" id="NT-Ignore"></a>[65]   </td>
		<td><code>Ignore</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-Char">Char</a>* - ( <a href="#NT-Char">Char</a>* ( '&lt;![' | ']]&gt;' ) <a href="#NT-Char">Char</a>* )</code></td>
	</tr>
</tbody>
</table>
<div class="constraint">
	<p class="prefix"><a name="condsec-nesting" id="condsec-nesting"></a><b>妥当性制約: 条件付きセクションとパラメータ実体の適切なネスト<span class="original" lang="en" xml:lang="en"> Validity constraint: Proper Conditional Section/PE Nesting</span></b></p>
	<p>条件付きセクションの"<code>&lt;![</code>"や"<code>[</code>"、"<code>]]&gt;</code>"などがパラメータ実体参照の置換テキストに含まれる場合、それらのすべてが同じ置換テキストに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まれなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">If any of the "<code>&lt;![</code>", "<code>[</code>", or "<code>]]&gt;</code>" of a conditional section is contained in the replacement text for a parameter-entity reference, all of them <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be contained in the same replacement text.</p>
</div>
<p>内部及び外部DTDサブセットと同様、条件付きセクションは一つ以上の完全な宣言、コメント、処理命令、ネストされた条件付きセクションを含んで良く、それらの間にホワイトスペースを混ぜても良い。</p>
<p class="original" lang="en" xml:lang="en">Like the internal and external DTD subsets, a conditional section may contain one or more complete declarations, comments, processing instructions, or nested conditional sections, intermingled with white space.</p>
<p>条件付きセクションのキーワードが<b>INCLUDE</b>であれば、その条件付きセクションの内容はDTDの一部として<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">処理されなければならない(MUST)</em>。条件付きセクションのキーワードが<b>IGNORE</b>であれば、その条件付きセクションの内容はDTDの一部として<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">処理されてはならない(MUST NOT)</em>。キーワードに<b>INCLUDE</b>を持つ条件付きセクションが、キーワードに<b>IGNORE</b>を持つ、より大きな条件付きセクションの中に現れた場合は、外側及び内側の条件付きセクションは両方とも<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">無視されなければならない(MUST)</em>。無視される条件付きセクションの内容は、キーワードに続く"<code>[</code>"の直後から、対応する条件付きセクションの終了が見つかる手前までのすべての文字(但し条件付きセクションの開始"<code>&lt;![</code>"と終了"<code>]]&gt;</code>"は例外)を無視しながら<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">解析されなければならない(MUST)</em>。この過程では、パラメータ実体参照は<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">認識されてはならない(MUST NOT)</em>。</p>
<p class="original" lang="en" xml:lang="en">If the keyword of the conditional section is <b>INCLUDE</b>, then the contents of the conditional section <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be processed as part of the DTD. If the keyword of the conditional section is <b>IGNORE</b>, then the contents of the conditional section <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> <span><em class="rfc2119" title="Keyword in RFC 2119 context">NOT</em> be processed as</span> part of the DTD. If a conditional section with a keyword of <b>INCLUDE</b> occurs within a larger conditional section with a keyword of <b>IGNORE</b>, both the outer and the inner conditional sections <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be ignored. The contents of an ignored conditional section <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be parsed by ignoring all characters after the "<code>[</code>" following the keyword, except conditional section starts "<code>&lt;![</code>" and ends "<code>]]&gt;</code>", until the matching conditional section end is found. Parameter entity references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> be recognized in this process.</p>
<p>条件付きセクションのキーワードがパラメータ実体参照ならば、そのパラメータ実体は、プロセッサがその条件付きセクションを取り込むか無視するかを決定する前に、そのパラメータ実体の内容で<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">置き換えられなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">If the keyword of the conditional section is a parameter-entity reference, the parameter entity <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be replaced by its content before the processor decides whether to include or ignore the conditional section.</p>
<p>条件付きセクションの一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">An example:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY % draft 'INCLUDE' &gt;
&lt;!ENTITY % final 'IGNORE' &gt;
&lt;![%draft;[
&lt;!ELEMENT book (comments*, title, body, supplements?)&gt;
]]&gt;
&lt;![%final;[
&lt;!ELEMENT book (title, body, supplements?)&gt;
]]&gt;
</pre>
</div>
</div>
</div>

<div class="div1">
<h2><a name="sec-physical-struct" id="sec-physical-struct"></a>4 物理構造<span class="original" lang="en" xml:lang="en"> Physical Structures</span></h2>
<p>[<a name="dt-entity" id="dt-entity" title="実体">定義</a>: XML文書は、一つあるいは多数の記録単位で構成される。これらは<b>実体</b>と呼ばれる。すべての実体は<b>内容</b>を持ち、また、<a title="文書実体" href="#dt-docent">文書実体</a>や<a title="文書型宣言" href="#dt-doctype">外部DTDサブセット</a>以外の実体はすべて実体<b>名</b>で識別される。] それぞれのXML文書は、<a title="文書実体" href="#dt-docent">文書実体</a>と呼ばれる実体を一つずつ持つ。文書実体は<a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>の開始点となり、文書のすべてを内包する事もある。</p>
<p class="original" lang="en" xml:lang="en">[Definition: An XML document may consist of one or many storage units. These are called <b>entities</b>; they all have <b>content</b> and are all (except for the <a title="Document Entity" href="#dt-docent">document entity</a> and the <a title="Document Type Declaration" href="#dt-doctype">external DTD subset</a>) identified by entity <b>name</b>.] Each XML document has one entity called the <a title="Document Entity" href="#dt-docent">document entity</a>, which serves as the starting point for the <a title="XML Processor" href="#dt-xml-proc">XML processor</a> and may contain the whole document.</p>
<p>実体は解析対象となる事もあるし、ならない事もある。 [<a name="dt-parsedent" id="dt-parsedent" title="テキスト実体">定義</a>: <b>解析対象実体</b>の内容は<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>と呼ばれる。この<a title="テキスト" href="#dt-text">テキスト</a>が実際に文書を構成する部分となる。]</p>
<p class="original" lang="en" xml:lang="en">Entities may be either parsed or unparsed. [Definition: The contents of a <b>parsed entity</b> are referred to as its <a title="Replacement Text" href="#dt-repltext">replacement text</a>; this <a title="Text" href="#dt-text">text</a> is considered an integral part of the document.]</p>
<p>[<a name="dt-unparsed" id="dt-unparsed" title="解析対象外実体">定義</a>: <b>解析対象外実体</b>は、内容が<a title="テキスト" href="#dt-text">テキスト</a>である事もない事もあるリソースである。その内容がテキストの場合、それはXMLではない事もある。解析対象外実体はそれぞれ関連付けられた<a title="記法" href="#dt-notation">記法</a>を一つ持つ。記法は名前で識別される。XMLプロセッサが解析対象外実体と記法をアプリケーションから利用可能にする事は要件とするが、XMLではそれ以上の制約、つまり解析対象外実体の内容についての制約は課さない。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: An <b>unparsed entity</b> is a resource whose contents may or may not be <a title="Text" href="#dt-text">text</a>, and if text, may be other than XML. Each unparsed entity has an associated <a title="Notation" href="#dt-notation">notation</a>, identified by name. Beyond a requirement that an XML processor make the identifiers for the entity and notation available to the application, XML places no constraints on the contents of unparsed entities.]</p>
<p>解析対象実体は、実体参照を使い、名前で呼び出される。解析対象外実体も名前で呼び出されるが、その名前は<b>ENTITY</b>属性や<b>ENTITIES</b>属性の値で与えられる。</p>
<p class="original" lang="en" xml:lang="en">Parsed entities are invoked by name using entity references; unparsed entities by name, given in the value of <b>ENTITY</b> or <b>ENTITIES</b> attributes.</p>
<p>[<a name="gen-entity" id="gen-entity" title="一般実体">定義</a>: <b>一般実体</b>は、文書の内容で使う為の実体である。この仕様書では、曖昧でなければ、一般実体が単に<em>実体</em>と呼ばれる事がある。] [<a name="dt-PE" id="dt-PE" title="パラメータ実体">定義</a>: <b>パラメータ実体</b>は、DTDで使う為の解析対象実体である。] これら二種類の実体は、参照にも異なる形式を使い、認識されるのも異なる文脈である。更に、これらは異なる名前空間を占める。即ち、同じ名前を持つ一般実体とパラメータ実体は、全く異なる二つの実体である。</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>General entities</b> are entities for use within the document content. In this specification, general entities are sometimes referred to with the unqualified term <em>entity</em> when this leads to no ambiguity.] [Definition: <b>Parameter entities</b> are parsed entities for use within the DTD.] These two types of entities use different forms of reference and are recognized in different contexts. Furthermore, they occupy different namespaces; a parameter entity and a general entity with the same name are two distinct entities.</p>

<div class="div2">
<h3><a name="sec-references" id="sec-references"></a>4.1 文字参照と実体参照<span class="original" lang="en" xml:lang="en"> Character and Entity References</span></h3>
<p>[<a name="dt-charref" id="dt-charref" title="文字参照">定義</a>: <b>文字参照</b>は、ISO/IEC 10646文字セットに含まれる特定の文字を参照する。例えば、利用可能な入力デバイスでは直接入力できない文字を参照する。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A <b>character reference</b> refers to a specific character in the ISO/IEC 10646 character set, for example one not directly accessible from available input devices.]</p>
<h5><a name="IDAOKKS" id="IDAOKKS"></a>文字参照<span class="original" lang="en" xml:lang="en"> Character Reference</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-CharRef" id="NT-CharRef"></a>[66]   </td>
		<td><code>CharRef</code></td>
		<td>   ::=   </td>
		<td><code>'&amp;#' [0-9]+ ';'</code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| '&amp;#x' [0-9a-fA-F]+ ';'</code></td>
		<td><a href="#wf-Legalchar">[整形式性制約: 使用が認められた文字]</a></td>
	</tr>
</tbody>
</table>
<div class="constraint">
	<p class="prefix"><a name="wf-Legalchar" id="wf-Legalchar"></a><b>整形式性制約: 使用が認められた文字<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: Legal Character</span></b></p>
	<p>文字参照を使って参照される文字は、生成規則<a href="#NT-Char">Char</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Characters referred to using character references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the production for <a href="#NT-Char">Char</a>.</p>
</div>
<p>文字参照が"<code>&amp;#x</code>"から始まれば、終わりの<code>;</code>までの数字と文字は、ISO/IEC 10646のコード点の16進数表記を与える。ただの"<code>&amp;#</code>"から始まれば、終わりの<code>;</code>までの数字は、その文字のコード点の10進数表記を与える。</p>
<p class="original" lang="en" xml:lang="en">If the character reference begins with "<code>&amp;#x</code>", the digits and letters up to the terminating <code>;</code> provide a hexadecimal representation of the character's code point in ISO/IEC 10646. If it begins just with "<code>&amp;#</code>", the digits up to the terminating <code>;</code> provide a decimal representation of the character's code point.</p>
<p>[<a name="dt-entref" id="dt-entref" title="実体参照">定義</a>: <b>実体参照</b>は、名前の付いた実体の内容を参照する。] [<a name="dt-GERef" id="dt-GERef" title="一般実体参照">定義</a>: 解析対象一般実体への参照は、アンパサンド(<code>&amp;</code>)とセミコロン(<code>;</code>)を区切り子に使う。] [<a name="dt-PERef" id="dt-PERef" title="パラメータ実体参照">定義</a>: <b>パラメータ実体参照</b>はパーセント符号(<code>%</code>)とセミコロン(<code>;</code>)を区切り子に使う。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: An <b>entity reference</b> refers to the content of a named entity.] [Definition: References to parsed general entities use ampersand (<code>&amp;</code>) and semicolon (<code>;</code>) as delimiters.] [Definition: <b>Parameter-entity references</b> use percent-sign (<code>%</code>) and semicolon (<code>;</code>) as delimiters.]</p>
<h5><a name="IDA1MKS" id="IDA1MKS"></a>実体参照<span class="original" lang="en" xml:lang="en"> Entity Reference</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-Reference" id="NT-Reference"></a>[67]   </td>
		<td><code>Reference</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-EntityRef">EntityRef</a> | <a href="#NT-CharRef">CharRef</a></code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EntityRef" id="NT-EntityRef"></a>[68]   </td>
		<td><code>EntityRef</code></td>
		<td>   ::=   </td>
		<td><code>'&amp;' <a href="#NT-Name">Name</a> ';'</code></td>
		<td><a href="#wf-entdeclared">[整形式性制約: 宣言された実体]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#vc-entdeclared">[妥当性制約: 宣言された実体]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#textent">[整形式性制約: 解析対象実体]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#norecursion">[整形式性制約: 一切無い再帰]</a></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-PEReference" id="NT-PEReference"></a>[69]   </td>
		<td><code>PEReference</code></td>
		<td>   ::=   </td>
		<td><code>'%' <a href="#NT-Name">Name</a> ';'</code></td>
		<td><a href="#vc-entdeclared">[妥当性制約: 宣言された実体]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#norecursion">[整形式性制約: 一切無い再帰]</a></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td></td>
		<td><a href="#indtd">[整形式性制約: DTDの中]</a></td>
	</tr>
</tbody>
</table>
<div class="constraint">
	<p class="prefix"><a name="wf-entdeclared" id="wf-entdeclared"></a><b>整形式性制約: 宣言された実体<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: Entity Declared</span></b></p>
	<p>一切のDTDを持たない文書や、パラメータ実体参照を一切含まない内部DTDサブセットしか持たない文書、あるいは"<code>standalone='yes'</code>"を持つ文書においては、外部サブセットやパラメータ実体の外に現れる実体参照については、その実体参照の<a href="#NT-Name">Name</a>は、外部サブセットやパラメータ実体の外の<a href="#sec-entity-decl"><cite>実体宣言</cite></a>の内の一つの名前に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="マッチする" href="#dt-match">マッチ</a>しなければならない(MUST)</em>。但し、<code>amp</code>、<code>lt</code>、<code>gt</code>、<code>apos</code>、<code>quot</code>は例外で、これらの実体を整形式の文書が宣言する必要は無い。一般実体の宣言は、属性リスト宣言のデフォルト値に現れるその実体への参照すべてに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">先行しなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with "<code>standalone='yes'</code>", for an entity reference that does not occur within the external subset or a parameter entity, the <a href="#NT-Name">Name</a> given in the entity reference <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> <a title="match" href="#dt-match">match</a> that in an <a href="#sec-entity-decl"><cite>entity declaration</cite></a> that does not occur within the external subset or a parameter entity, except that well-formed documents need not declare any of the following entities: <code>amp</code>, <code>lt</code>, <code>gt</code>, <code>apos</code>, <code>quot</code>. The declaration of a general entity <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> precede any reference to it which appears in a default value in an attribute-list declaration.</p>
	<p>妥当性を検証しないプロセッサは、パラメータ実体の中や外部サブセットの中に現れる実体宣言を読み取ったり処理したりするようには<a href="#include-if-valid"><cite>強制されない</cite></a>事に注意してほしい。つまり、妥当性を検証しないプロセッサでは、そのような文書──パラメータ実体参照や外部サブセットを持つ文書においては、<a href="#sec-rmd"><cite>standalone='yes'</cite></a>である時にのみ、実体が宣言されなければならないという規則が整形式制約となる。</p>
	<p class="original" lang="en" xml:lang="en">Note that non-validating processors are <a href="#include-if-valid"><cite>not obligated to</cite></a> to read and process entity declarations occurring in parameter entities or in the external subset; for such documents, the rule that an entity must be declared is a well-formedness constraint only if <a href="#sec-rmd"><cite>standalone='yes'</cite></a>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="vc-entdeclared" id="vc-entdeclared"></a><b>妥当性制約: 宣言された実体<span class="original" lang="en" xml:lang="en"> Validity constraint: Entity Declared</span></b></p>
	<p>外部サブセットやパラメータ実体参照を持ち、かつ"<code>standalone='no'</code>"である文書では、その実体参照の<a href="#NT-Name">Name</a>は、<a href="#sec-entity-decl"><cite>実体宣言</cite></a>の内の一つの名前に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="マッチする" href="#dt-match">マッチ</a>しなければならない(MUST)</em>。相互運用性の為に、妥当な文書は、<code>amp</code>、<code>lt</code>、<code>gt</code>、<code>apos</code>、<code>quot</code>の実体を<a href="#sec-predefined-ent"><b>4.6 定義済み実体<span class="original" lang="en" xml:lang="en"> Predefined Entities</span></b></a>で指定される形式で<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言する事が望ましい(SHOULD)</em>。パラメータ実体の宣言は、それへの参照すべてに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">先行しなければならない(MUST)</em>。同様に、一般実体の宣言は、その一般実体への直接的あるいは間接的な参照を持つデフォルト値を含有する属性リスト宣言すべてに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">先行しなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">In a document with an external subset or parameter entity references with "<code>standalone='no'</code>", the <a href="#NT-Name">Name</a> given in the entity reference <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> <a title="match" href="#dt-match">match</a> that in an <a href="#sec-entity-decl"><cite>entity declaration</cite></a>. For interoperability, valid documents <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> declare the entities <code>amp</code>, <code>lt</code>, <code>gt</code>, <code>apos</code>, <code>quot</code>, in the form specified in <a href="#sec-predefined-ent"><b>4.6 Predefined Entities</b></a>. The declaration of a parameter entity <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> precede any reference to it. Similarly, the declaration of a general entity <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> precede any attribute-list declaration containing a default value with a direct or indirect reference to that general entity.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="textent" id="textent"></a><b>整形式性制約: 解析対象実体<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: Parsed Entity</span></b></p>
	<p>実体参照は、<a title="解析対象外実体" href="#dt-unparsed">解析対象外実体</a>の名前を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含んではならない(MUST NOT)</em>。解析対象外実体は、型<b>ENTITY</b>や<b>ENTITIES</b>となるよう宣言された<a title="属性値" href="#dt-attrval">属性値</a>からのみ参照できる。</p>
	<p class="original" lang="en" xml:lang="en">An entity reference <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> contain the name of an <a title="Unparsed Entity" href="#dt-unparsed">unparsed entity</a>. Unparsed entities may be referred to only in <a title="Attribute Value" href="#dt-attrval">attribute values</a> declared to be of type <b>ENTITY</b> or <b>ENTITIES</b>.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="norecursion" id="norecursion"></a><b>整形式性制約: 一切無い再帰<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: No Recursion</span></b></p>
	<p>解析対象実体は、直接的にも間接的にも、自分自身への再帰的な参照を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含んではならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">A parsed entity <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> contain a recursive reference to itself, either directly or indirectly.</p>
</div>
<div class="constraint">
	<p class="prefix"><a name="indtd" id="indtd"></a><b>整形式性制約: DTDの中<span class="original" lang="en" xml:lang="en"> Well-formedness constraint: In DTD</span></b></p>
	<p>パラメータ実体参照は、<a title="文書型宣言" href="#dt-doctype">DTD</a>の外に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">Parameter-entity references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear outside the <a title="Document Type Declaration" href="#dt-doctype">DTD</a>.</p>
</div>
<p>文字参照と実体参照の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of character and entity references:</p>
<div class="exampleInner">
<pre>
Type &lt;key&gt;less-than&lt;/key&gt; (&amp;#x3C;) to save options.
This document was prepared on &amp;docdate; and
is classified &amp;security-level;.
</pre>
</div>
<p>パラメータ実体参照の一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">Example of a parameter-entity reference:</p>
<div class="exampleInner">
<pre>
&lt;!-- declare the parameter entity "ISOLat2"... --&gt;
&lt;!ENTITY % ISOLat2
SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" &gt;
&lt;!-- ... now reference it. --&gt;
%ISOLat2;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="sec-entity-decl" id="sec-entity-decl"></a>4.2 実体宣言<span class="original" lang="en" xml:lang="en"> Entity Declarations</span></h3>
<p>[<a name="dt-entdecl" id="dt-entdecl" title="実体宣言">定義</a>: 実体は次のように宣言される。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: Entities are declared thus:]</p>
<h5><a name="IDABVKS" id="IDABVKS"></a>実体宣言<span class="original" lang="en" xml:lang="en"> Entity Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EntityDecl" id="NT-EntityDecl"></a>[70]   </td>
		<td><code>EntityDecl</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-GEDecl">GEDecl</a> | <a href="#NT-PEDecl">PEDecl</a></code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-GEDecl" id="NT-GEDecl"></a>[71]   </td>
		<td><code>GEDecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!ENTITY' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a href="#NT-S">S</a> <a href="#NT-EntityDef">EntityDef</a> <a href="#NT-S">S</a>? '&gt;'</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-PEDecl" id="NT-PEDecl"></a>[72]   </td>
		<td><code>PEDecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!ENTITY' <a href="#NT-S">S</a> '%' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a href="#NT-S">S</a> <a href="#NT-PEDef">PEDef</a> <a href="#NT-S">S</a>? '&gt;'</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-EntityDef" id="NT-EntityDef"></a>[73]   </td>
		<td><code>EntityDef</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-EntityValue">EntityValue</a> | ( <a href="#NT-ExternalID">ExternalID</a> <a href="#NT-NDataDecl">NDataDecl</a>? )</code></td>
	</tr>
	<tr valign="baseline">
		<td><a name="NT-PEDef" id="NT-PEDef"></a>[74]   </td>
		<td><code>PEDef</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-EntityValue">EntityValue</a> | <a href="#NT-ExternalID">ExternalID</a></code></td>
	</tr>
</tbody>
</table>
<p><a href="#NT-Name">Name</a>は、<a title="実体参照" href="#dt-entref">実体参照</a>でその実体を識別する為の名前である。解析対象外実体の場合は、<b>ENTITY</b>属性や<b>ENTITIES</b>属性の値でその実体を識別する為の名前である。もし同じ名前の実体が二回以上宣言された場合は、最初に見つかった宣言がその実体に結び付けられる。ユーザが選択した場合、XMLプロセッサは、実体が複数回宣言された場合に警告を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">出しても良い(MAY)</em>。</p>
<p class="original" lang="en" xml:lang="en">The <a href="#NT-Name">Name</a> identifies the entity in an <a title="Entity Reference" href="#dt-entref">entity reference</a> or, in the case of an unparsed entity, in the value of an <b>ENTITY</b> or <b>ENTITIES</b> attribute. If the same entity is declared more than once, the first declaration encountered is binding; at user option, an XML processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> issue a warning if entities are declared multiple times.</p>

<div class="div3">
<h4><a name="sec-internal-ent" id="sec-internal-ent"></a>4.2.1 内部実体<span class="original" lang="en" xml:lang="en"> Internal Entities</span></h4>
<p>[<a name="dt-internent" id="dt-internent" title="内部実体置換テキスト">定義</a>: 実体の定義が<a href="#NT-EntityValue">EntityValue</a>である時、定義された実体は<b>内部実体</b>と呼ばれる。内部実体の定義では他の物理的な記録オブジェクトは使わず、実体の内容はその宣言の中で与えられる。] <a title="リテラル実体値" href="#dt-litentval">リテラル実体値</a>での実体参照や文字参照の処理では、正しい<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>を生成しなければならない事がある事に注意してほしい。詳しくは<a href="#intern-replacement"><b>4.5 実体の置換テキストの構築<span class="original" lang="en" xml:lang="en"> Construction of Entity Replacement Text</span></b></a>を参照する事。</p>
<p class="original" lang="en" xml:lang="en">[Definition: If the entity definition is an <a href="#NT-EntityValue">EntityValue</a>, the defined entity is called an <b>internal entity</b>. There is no separate physical storage object, and the content of the entity is given in the declaration.] Note that some processing of entity and character references in the <a title="Literal Entity Value" href="#dt-litentval">literal entity value</a> may be required to produce the correct <a title="Replacement Text" href="#dt-repltext">replacement text</a>: see <a href="#intern-replacement"><b>4.5 Construction of Entity Replacement Text</b></a>.</p>
<p>内部実体は<a title="テキスト実体" href="#dt-parsedent">解析対象実体</a>である。</p>
<p class="original" lang="en" xml:lang="en">An internal entity is a <a title="Text Entity" href="#dt-parsedent">parsed entity</a>.</p>
<p>内部実体宣言の一例を挙げる。</p>
<p class="original" lang="en" xml:lang="en">Example of an internal entity declaration:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY Pub-Status "This is a pre-release of the
specification."&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="sec-external-ent" id="sec-external-ent"></a>4.2.2 外部実体<span class="original" lang="en" xml:lang="en"> External Entities</span></h4>
<p>[<a name="dt-extent" id="dt-extent" title="外部実体">定義</a>: 実体が内部実体でなければ、<b>外部実体</b>である。外部実体は次のように宣言される。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: If the entity is not internal, it is an <b>external entity</b>, declared as follows:]</p>
<h5><a name="IDAX1KS" id="IDAX1KS"></a>外部実体宣言<span class="original" lang="en" xml:lang="en"> External Entity Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-ExternalID" id="NT-ExternalID"></a>[75]   </td>
		<td><code>ExternalID</code></td>
		<td>   ::=   </td>
		<td><code>'SYSTEM' <a href="#NT-S">S</a> <a href="#NT-SystemLiteral">SystemLiteral</a></code></td>
	</tr>
	<tr valign="baseline">
		<td></td>
		<td></td>
		<td></td>
		<td><code>| 'PUBLIC' <a href="#NT-S">S</a> <a href="#NT-PubidLiteral">PubidLiteral</a> <a href="#NT-S">S</a> <a href="#NT-SystemLiteral">SystemLiteral</a></code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-NDataDecl" id="NT-NDataDecl"></a>[76]   </td>
		<td><code>NDataDecl</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-S">S</a> 'NDATA' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a></code></td>
		<td><a href="#not-declared">[妥当性制約: 宣言された記法]</a></td>
	</tr>
</tbody>
</table>
<p><a href="#NT-NDataDecl">NDataDecl</a>が存在すれば、これは一般<a title="解析対象外実体" href="#dt-unparsed">解析対象外実体</a>となる。さもなくば解析対象実体となる。</p>
<p class="original" lang="en" xml:lang="en">If the <a href="#NT-NDataDecl">NDataDecl</a> is present, this is a general <a title="Unparsed Entity" href="#dt-unparsed">unparsed entity</a>; otherwise it is a parsed entity.</p>
<div class="constraint">
	<p class="prefix"><a name="not-declared" id="not-declared"></a><b>妥当性制約: 宣言された記法<span class="original" lang="en" xml:lang="en"> Validity constraint: Notation Declared</span></b></p>
	<p><a href="#NT-Name">Name</a>は、宣言された<a title="記法" href="#dt-notation">記法</a>の内の一つの名前に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチしなければならない(MUST)</em>。</p>
	<p class="original" lang="en" xml:lang="en">The <a href="#NT-Name">Name</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> match the declared name of a <a title="Notation" href="#dt-notation">notation</a>.</p>
</div>
<p>[<a name="dt-sysid" id="dt-sysid" title="システム識別子">定義</a>: <a href="#NT-SystemLiteral">SystemLiteral</a>は、実体の<b>システム識別子</b>と呼ばれる。これは、<a href="#rfc3986">[IETF RFC 3986]</a>で定義されるURI参照に変換される事を意図されている。XMLプロセッサがその実体の置換テキストを構築する際の入力を取得する為、そのURI参照が指すものを得る処理に使えるようにである。] (文字<code>#</code>から始まる)断片識別子がシステム識別子に紛れ込む事はエラーである。この仕様書の範囲外の情報(例えば、特定のDTDで定義される特別なXML要素型や、特定のアプリケーション仕様書で定義される処理命令など)が提供されない限り、相対URIは、その実体宣言が現れたリソースの場所に対するものとする。これは、宣言を開始する'&lt;'が宣言の開始であると解析された時点で、その'&lt;'を含む外部実体のURIが基底URIになるよう定義される。このように、URIは<a title="文書実体" href="#dt-docent">文書実体</a>に対して相対的になる事もあるし、<a title="文書型宣言" href="#dt-doctype">外部DTDサブセット</a>を含む実体に対して、あるいは他の<a title="外部実体" href="#dt-extent">外部パラメータ実体</a>に対して相対的になる事もあり得る。URIで識別されるリソースを入手する試みは、パーサレベルで(例えば、実体解決機構で)リダイレクトされるかも知れないし、更に下層で(プロトコルレベルで、例えばHTTPの<code>Location:</code>ヘッダを使って)リダイレクトされるかも知れない。この仕様書の範囲外の追加情報がそのリソース中に無ければ、そのリソースの基底URIは常に、返された実際のリソースのURIである。言葉を換えれば、すべてのリダイレクションが発生した後で入手したリソースのURIが基底URIとなるという事である。</p>
<p class="original" lang="en" xml:lang="en">[Definition: The <a href="#NT-SystemLiteral">SystemLiteral</a> is called the entity's <b>system identifier</b>. It is meant to be converted to a URI reference (as defined in <a href="#rfc3986">[IETF RFC 3986]</a>), as part of the process of dereferencing it to obtain input for the XML processor to construct the entity's replacement text.] It is an error for a fragment identifier (beginning with a <code>#</code> character) to be part of a system identifier. Unless otherwise provided by information outside the scope of this specification (e.g. a special XML element type defined by a particular DTD, or a processing instruction defined by a particular application specification), relative URIs are relative to the location of the resource within which the entity declaration occurs. This is defined to be the external entity containing the '&lt;' which starts the declaration, at the point when it is parsed as a declaration. A URI might thus be relative to the <a title="Document Entity" href="#dt-docent">document entity</a>, to the entity containing the <a title="Document Type Declaration" href="#dt-doctype">external DTD subset</a>, or to some other <a title="External Entity" href="#dt-extent">external parameter entity</a>. Attempts to retrieve the resource identified by a URI may be redirected at the parser level (for example, in an entity resolver) or below (at the protocol level, for example, via an HTTP <code>Location:</code> header). In the absence of additional information outside the scope of this specification within the resource, the base URI of a resource is always the URI of the actual resource returned. In other words, it is the URI of the resource retrieved after all redirection has occurred.</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>ここでは、便宜の為か相対URI(Relative URI)という用語が使われていますが、これは<a href="#rfc3986">[IETF RFC 3986]</a>に従うなら相対参照(Relative Reference)と呼ぶべきものです。相対参照はURIのサブセットではありません。URIを参照する方法(<q>a method of referencing URIs</q>)です。詳しくは、<a href="#rfc3986">[IETF RFC 3986]</a>の<cite>1.2.3. Hierarchical Identifiers</cite>や<cite>4.2. Relative Reference</cite>を参照して下さい。</p>
	<p>また、<q><var>A</var>に対して相対的になる</q>という表現もありますが、これはつまり「<var>A</var>のURIが基底URI(Base URI)になる」という事です。基底URIについての話もありますが、これには<a href="#rfc3986">[IETF RFC 3986]</a>の<cite>5.1. Establishing a Base URI</cite>が参考になるでしょう。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<p>システム識別子(とその他のURI参照として使われる事を意図されたXML文字列)は、<a href="#rfc3986">[IETF RFC 3986]</a>に拠れば、参照されたリソースを入手する為URIを使う前にエスケープされなければならない文字を含む事がある。エスケープされなければならない文字は、#x0から#x1Fまでと#x7Fの制御文字(これらの殆どはXMLでは現れ得ない)、スペース(#x20)、区切り子'&lt;'(#x3C)、'&gt;'(#x3E)、'"'(#x22)、<em>思慮に欠ける</em>文字'{'(#x7B)、'}'(#x7D)、'|'(#x7C)、'\'(#x5C)、'^'(#x5E)、'`'(#x60)、そして#x7Fより大きなコード点を持つすべての文字である。エスケーピングは必ずしも完全に可逆的な処理という訳ではないので、どうしても必要になった時にのみ、一連の処理の中のできるだけ遅い段階で<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">為されなければならない(MUST)</em>。特に、相対URIを絶対URIに変換する処理や、URI参照の指すものを入手しなければならないルーチンあるいはソフトウェアコンポーネントにURI参照を渡す処理は、何れもエスケーピングの<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">きっかけにならない事が望ましい(SHOULD)</em>。本当にエスケープする時は、次のように<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">なされなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">System identifiers (and other XML strings meant to be used as URI references) may contain characters that, according to <a href="#rfc3986">[IETF RFC 3986]</a>, must be escaped before a URI can be used to retrieve the referenced resource. The characters to be escaped are the control characters #x0 to #x1F and #x7F (most of which cannot appear in XML), space #x20, the delimiters '&lt;' #x3C, '&gt;' #x3E and '"' #x22, the <em>unwise</em> characters '{' #x7B, '}' #x7D, '|' #x7C, '\' #x5C, '^' #x5E and '`' #x60, as well as all characters above #x7F. Since escaping is not always a fully reversible process, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be performed only when absolutely necessary and as late as possible in a processing chain. In particular, neither the process of converting a relative URI to an absolute one nor the process of passing a URI reference to a process or software component responsible for dereferencing it <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> trigger escaping. When escaping does occur, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be performed as follows:</p>
<ol class="enumar">
	<li>
		<p>エスケープされる文字が、それぞれUTF-8 <a href="#Unicode">[Unicode]</a>を使って、1バイト以上のバイト列で表される。</p>
		<p class="original" lang="en" xml:lang="en">Each character to be escaped is represented in UTF-8 <a href="#Unicode">[Unicode]</a> as one or more bytes.</p>
	</li>
	<li>
		<p>結果となるバイト列が、URIエスケーピング機構を使ってエスケープされる(つまり、<code>%</code><var>HH</var>形式に変換される。ここでHHはそのバイト値の16進数表記である)。</p>
		<p class="original" lang="en" xml:lang="en">The resulting bytes are escaped with the URI escaping mechanism (that is, converted to <code>%</code><var>HH</var>, where HH is the hexadecimal notation of the byte value).</p>
	</li>
	<li>
		<p>元の文字が結果となる文字列で置き換えられる。</p>
		<p class="original" lang="en" xml:lang="en">The original character is replaced by the resulting character sequence.</p>
	</li>
</ol>
<p>[<a name="dt-pubid" id="dt-pubid" title="公開識別子">定義</a>: システム識別子に加えて、外部識別子は<b>公開識別子</b>をも持つ事がある。] 実体の内容を取得しようとするXMLプロセッサは、代替URI参照を生成する為に、この仕様書の範囲外の追加情報に加えて、公開識別子やシステム識別子を使っても良いし、それらの如何なる組み合わせを使っても良い。そうする事ができないのであれば、プロセッサはシステムリテラルで指定されたURI参照を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使わなければならない(MUST)</em>。マッチングを試みる前に、公開識別子のホワイトスペースはすべて一つのスペース文字(#x20)に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">正規化されなければならず(MUST)</em>、また先頭と末尾のホワイトスペースは<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">除去されなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">[Definition: In addition to a system identifier, an external identifier may include a <b>public identifier</b>.] An XML processor attempting to retrieve the entity's content may use any combination of the public and system identifiers as well as additional information outside the scope of this specification to try to generate an alternative URI reference. If the processor is unable to do so, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> use the URI reference specified in the system literal. Before a match is attempted, all strings of white space in the public identifier <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be normalized to single space characters (#x20), and leading and trailing white space <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be removed.</p>
<p>外部実体宣言の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of external entity declarations:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY open-hatch
SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY open-hatch
PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
"http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY hatch-pic
SYSTEM "../grafix/OpenHatch.gif"
NDATA gif &gt;
</pre>
</div>
</div>
</div>

<div class="div2">
<h3><a name="TextEntities" id="TextEntities"></a>4.3 解析対象実体<span class="original" lang="en" xml:lang="en"> Parsed Entities</span></h3>

<div class="div3">
<h4><a name="sec-TextDecl" id="sec-TextDecl"></a>4.3.1 テキスト宣言<span class="original" lang="en" xml:lang="en"> The Text Declaration</span></h4>
<p>外部解析対象実体は、それぞれが<b>テキスト宣言</b>から<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">始まる事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">External parsed entities <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> each begin with a <b>text declaration</b>.</p>
<h5><a name="IDAGDLS" id="IDAGDLS"></a>テキスト宣言<span class="original" lang="en" xml:lang="en"> Text Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-TextDecl" id="NT-TextDecl"></a>[77]   </td>
		<td><code>TextDecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;?xml' <a href="#NT-VersionInfo">VersionInfo</a>? <a href="#NT-EncodingDecl">EncodingDecl</a> <a href="#NT-S">S</a>? '?&gt;'</code></td>
	</tr>
</tbody>
</table>
<p>テキスト宣言は、解析対象実体への参照を使うのではなく、直接<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">書かれなければならない(MUST)</em>。テキスト宣言は、外部解析対象実体の始まり以外には、あらゆる場所に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">現れてはならない(MUST NOT)</em>。外部解析対象実体のテキスト宣言は、その<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>の一部とは見なされない。</p>
<p class="original" lang="en" xml:lang="en">The text declaration <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be provided literally, not by reference to a parsed entity. The text declaration <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> appear at any position other than the beginning of an external parsed entity. The text declaration in an external parsed entity is not considered part of its <a title="Replacement Text" href="#dt-repltext">replacement text</a>.</p>
</div>

<div class="div3">
<h4><a name="wf-entities" id="wf-entities"></a>4.3.2 整形式の解析対象実体<span class="original" lang="en" xml:lang="en"> Well-Formed Parsed Entities</span></h4>
<p>文書は、それが生成規則<a href="#NT-document">document</a>にマッチする時整形式となる。外部一般解析対象実体は、それが生成規則<a href="#NT-extParsedEnt">extParsedEnt</a>にマッチする時整形式となる。外部パラメータ実体は、定義上、すべてが整形式である。</p>
<p class="original" lang="en" xml:lang="en">The document entity is well-formed if it matches the production labeled <a href="#NT-document">document</a>. An external general parsed entity is well-formed if it matches the production labeled <a href="#NT-extParsedEnt">extParsedEnt</a>. All external parameter entities are well-formed by definition.</p>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p>整形式である必要があるのは、文書中で直接的あるいは間接的に参照される解析対象実体だけである。</p>
	<p class="original" lang="en" xml:lang="en">Only parsed entities that are referenced directly or indirectly within the document are required to be well-formed.</p>
</div>
<h5><a name="IDAKFLS" id="IDAKFLS"></a>整形式の外部解析対象実体<span class="original" lang="en" xml:lang="en"> Well-Formed External Parsed Entity</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-extParsedEnt" id="NT-extParsedEnt"></a>[78]   </td>
		<td><code>extParsedEnt</code></td>
		<td>   ::=   </td>
		<td><code>( <a href="#NT-TextDecl">TextDecl</a>? <a href="#NT-content">content</a> ) - ( <a href="#NT-Char">Char</a>* <a href="#NT-RestrictedChar">RestrictedChar</a> <a href="#NT-Char">Char</a>* )</code></td>
	</tr>
</tbody>
</table>
<p>内部一般解析対象実体は、その置換テキストが生成規則<a href="#NT-content">content</a>にマッチする時整形式となる。内部パラメータ実体は、定義上、すべてが整形式である。</p>
<p class="original" lang="en" xml:lang="en">An internal general parsed entity is well-formed if its replacement text matches the production labeled <a href="#NT-content">content</a>. All internal parameter entities are well-formed by definition.</p>
<p>一般実体が整形式性を持つ事によって、XML文書の論理構造と物理構造は適切にネストされる事となる。つまり、<a title="開始タグ" href="#dt-stag">開始タグ</a>、<a title="終了タグ" href="#dt-etag">終了タグ</a>、<a title="空" href="#dt-empty">空要素タグ</a>、<a title="要素" href="#dt-element">要素</a>、<a title="コメント" href="#dt-comment">コメント</a>、<a title="処理命令" href="#dt-pi">処理命令</a>、<a title="文字参照" href="#dt-charref">文字参照</a>、そして<a title="実体参照" href="#dt-entref">実体参照</a>は、ある実体で始まり、別の実体で終わるという事が一切できない。</p>
<p class="original" lang="en" xml:lang="en">A consequence of well-formedness in general entities is that the logical and physical structures in an XML document are properly nested; no <a title="Start-Tag" href="#dt-stag">start-tag</a>, <a title="End Tag" href="#dt-etag">end-tag</a>, <a title="Empty" href="#dt-empty">empty-element tag</a>, <a title="Element" href="#dt-element">element</a>, <a title="Comment" href="#dt-comment">comment</a>, <a title="Processing instruction" href="#dt-pi">processing instruction</a>, <a title="Character Reference" href="#dt-charref">character reference</a>, or <a title="Entity Reference" href="#dt-entref">entity reference</a> can begin in one entity and end in another.</p>
</div>

<div class="div3">
<h4><a name="charencoding" id="charencoding"></a>4.3.3 実体で使われる文字エンコーディング<span class="original" lang="en" xml:lang="en"> Character Encoding in Entities</span></h4>
<p>一つのXML文書で使われる外部解析対象実体は、それぞれ異なるエンコーディングを文字に対して用いても良い。すべてのXMLプロセッサは、UTF-8エンコーディングやUTF-16エンコーディングで表された実体を、両方とも<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">読み取れなければならない(MUST)</em>。この仕様書で使われる用語"UTF-8"と"UTF-16"は、異なる名前を持つ文字エンコーディングを指したりはしない。たとえそのエンコーディング方法やその名前がどんなにUTF-8やUTF-16に似ていてもである。</p>
<p class="original" lang="en" xml:lang="en">Each external parsed entity in an XML document may use a different encoding for its characters. All XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be able to read entities in both the UTF-8 and UTF-16 encodings. The terms "UTF-8" and "UTF-16" in this specification do not apply to character encodings with any other labels, even if the encodings or labels are very similar to UTF-8 or UTF-16.</p>
<p>UTF-16でエンコードされた実体は、ISO/IEC 10646 <a href="#ISO10646">[ISO/IEC 10646]</a>やUnicode <a href="#Unicode">[Unicode]</a>で説明されているバイトオーダーマーク(Byte Order Mark、BOM。ZERO WIDTH NO-BREAK SPACE文字(#xFEFF)の事)から<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">始まらなければならない(MUST)</em>。UTF-8でエンコードされた実体は、バイトオーダーマークから<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">始まっても良い(MAY)</em>。バイトオーダーマークはエンコーディングのシグネチャであり、そのXML文書のマークアップの一部でも文字データの一部でもない。XMLプロセッサは、この文字を、UTF-8でエンコードされた文書とUTF-16でエンコードされた文書を区別する為に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使えなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">Entities encoded in UTF-16 <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> and entities encoded in UTF-8 <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> begin with the Byte Order Mark described in ISO/IEC 10646 <a href="#ISO10646">[ISO/IEC 10646]</a> or Unicode <a href="#Unicode">[Unicode]</a> (the ZERO WIDTH NO-BREAK SPACE character, #xFEFF). This is an encoding signature, not part of either the markup or the character data of the XML document. XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be able to use this character to differentiate between UTF-8 and UTF-16 encoded documents.</p>
<p>XMLプロセッサに絶対に要求されるのはUTF-8エンコーディングやUTF-16エンコーディングで表された実体を読み取れる事だけではあるが、他にも沢山のエンコーディングが世界各地で使われている事が知られており、XMLプロセッサがそれらのエンコーディングで表された実体をも読み取れる事が望まれるかも知れない。外部の文字エンコーディング情報(MIMEヘッダなど)が無いのであれば、UTF-8とUTF-16以外のエンコーディングで記録された解析対象実体は、エンコーディング宣言を含むテキスト宣言(<a href="#sec-TextDecl"><b>4.3.1 テキスト宣言<span class="original" lang="en" xml:lang="en"> The Text Declaration</span></b></a>参照)から<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">始まらなければならない(MUST)</em>。エンコーディング宣言は次の通りである。</p>
<p class="original" lang="en" xml:lang="en">Although an XML processor is required to read only entities in the UTF-8 and UTF-16 encodings, it is recognized that other encodings are used around the world, and it may be desired for XML processors to read entities that use them. In the absence of external character encoding information (such as MIME headers), parsed entities which are stored in an encoding other than UTF-8 or UTF-16 <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> begin with a text declaration (see <a href="#sec-TextDecl"><b>4.3.1 The Text Declaration</b></a>) containing an encoding declaration:</p>
<h5><a name="IDABKLS" id="IDABKLS"></a>エンコーディング宣言<span class="original" lang="en" xml:lang="en"> Encoding Declaration</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EncodingDecl" id="NT-EncodingDecl"></a>[80]   </td>
		<td><code>EncodingDecl</code></td>
		<td>   ::=   </td>
		<td><code><a href="#NT-S">S</a> 'encoding' <a href="#NT-Eq">Eq</a> ( '"' <a href="#NT-EncName">EncName</a> '"' | "'" <a href="#NT-EncName">EncName</a> "'" )</code></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-EncName" id="NT-EncName"></a>[81]   </td>
		<td><code>EncName</code></td>
		<td>   ::=   </td>
		<td><code>[A-Za-z] ( [A-Za-z0-9._] | '-' )*</code></td>
		<td><i>/* ラテン文字しか含まないエンコーディング名<span class="original" lang="en" xml:lang="en"> Encoding name contains only Latin characters</span> */</i></td>
	</tr>
</tbody>
</table>
<p><a title="文書実体" href="#dt-docent">文書実体</a>では、エンコーディング宣言は<a title="XML宣言" href="#dt-xmldecl">XML宣言</a>の一部である。<a href="#NT-EncName">EncName</a>は、使われているエンコーディングの名前である。</p>
<p class="original" lang="en" xml:lang="en">In the <a title="Document Entity" href="#dt-docent">document entity</a>, the encoding declaration is part of the <a title="XML Declaration" href="#dt-xmldecl">XML declaration</a>. The <a href="#NT-EncName">EncName</a> is the name of the encoding used.</p>
<p>エンコーディング宣言では、値"<code>UTF-8</code>"、"<code>UTF-16</code>"、"<code>ISO-10646-UCS-2</code>"、及び"<code>ISO-10646-UCS-4</code>"は、UnicodeとISO/IEC 10646の様々なエンコーディングやトランスフォーメーションに対して<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使われる事が望ましい(SHOULD)</em>。値"<code>ISO-8859-1</code>"、"<code>ISO-8859-2</code>"、……、"<code>ISO-8859-</code><var>n</var>"(ここで<var>n</var>はパート番号)は、ISO 8859のパートに対して<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使われる事が望ましい(SHOULD)</em>。そして、値"<code>ISO-2022-JP</code>"、"<code>Shift_JIS</code>"、及び"<code>EUC-JP</code>"は、JIS X-0208-1997の様々なエンコードされた形式に対して<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使われる事が望ましい(SHOULD)</em>。また、Internet Assigned Numbers Authority <a href="#IANA">[IANA-CHARSETS]</a>によって(<em>charset</em>として)登録された文字エンコーディングが、その登録名を使って<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">参照される事が推奨される(RECOMMENDED)</em>(ただリストされただけのものは薦められない)。他のエンコーディングは、"x-"接頭辞で始まる名前を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使う事が望ましい(SHOULD)</em>。XMLプロセッサは、文字エンコーディング名を、ケース間の差を無視しながら<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">マッチさせる事が望ましい(SHOULD)</em>。また、XMLプロセッサは、IANA登録名を、その名前でIANAに登録されたエンコーディングとして<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">解釈する事が望ましく(SHOULD)</em>、そうしないのであればそれを不明なエンコーディングとして<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">扱う事が望ましい(SHOULD)</em>(プロセッサは、勿論、IANAに登録されたエンコーディングをすべてサポートする必要は無い)。</p>
<p class="original" lang="en" xml:lang="en">In an encoding declaration, the values "<code>UTF-8</code>", "<code>UTF-16</code>", "<code>ISO-10646-UCS-2</code>", and "<code>ISO-10646-UCS-4</code>" <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be used for the various encodings and transformations of Unicode / ISO/IEC 10646, the values "<code>ISO-8859-1</code>", "<code>ISO-8859-2</code>", ... "<code>ISO-8859-</code><var>n</var>" (where <var>n</var> is the part number) <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be used for the parts of ISO 8859, and the values "<code>ISO-2022-JP</code>", "<code>Shift_JIS</code>", and "<code>EUC-JP</code>" <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be used for the various encoded forms of JIS X-0208-1997. It is <em class="rfc2119" title="Keyword in RFC 2119 context">RECOMMENDED</em> that character encodings registered (as <em>charset</em>s) with the Internet Assigned Numbers Authority <a href="#IANA">[IANA-CHARSETS]</a>, other than those just listed, be referred to using their registered names; other encodings <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> use names starting with an "x-" prefix. XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> match character encoding names in a case-insensitive way and <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> either interpret an IANA-registered name as the encoding registered at IANA for that name or treat it as unknown (processors are, of course, not required to support all IANA-registered encodings).</p>
<p>外部の転送プロトコル(例えばHTTPやMIME)によって提供される情報が無いのであれば、エンコーディング宣言を含む実体がその宣言で言及したエンコーディング以外のエンコーディングで表されてXMLプロセッサに渡される事や、バイトオーダーマークから始まるのでもなくエンコーディング宣言から始まるのでもない実体がUTF-8以外のエンコーディングを使う事は<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>である。但し、ASCIIはUTF-8のサブセットなので、通常のASCII実体は厳密にエンコーディング宣言を必要とする訳ではない事に注意してほしい。</p>
<p class="original" lang="en" xml:lang="en">In the absence of information provided by an external transport protocol (e.g. HTTP or MIME), it is a <a title="Fatal Error" href="#dt-fatal">fatal error</a> for an entity including an encoding declaration to be presented to the XML processor in an encoding other than that named in the declaration, or for an entity which begins with neither a Byte Order Mark nor an encoding declaration to use an encoding other than UTF-8. Note that since ASCII is a subset of UTF-8, ordinary ASCII entities do not strictly need an encoding declaration.</p>
<p><a href="#NT-TextDecl">TextDecl</a>が外部実体の始まり以外の場所に現れる事は<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>である。</p>
<p class="original" lang="en" xml:lang="en">It is a <a title="Fatal Error" href="#dt-fatal">fatal error</a> for a <a href="#NT-TextDecl">TextDecl</a> to occur other than at the beginning of an external entity.</p>
<p>XMLプロセッサが処理する事ができないエンコーディングで表された実体に出くわした場合、それは<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>である。XML実体がある特定のエンコーディングで表されていると(デフォルトやエンコーディング宣言、またはより上層のプロトコルによって)決定されたにも拘わらず、そのエンコーディングで許されないバイト列を含んでいた場合、それは<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>である。特に、UTF-8でエンコードされた実体が、Unicode <a href="#Unicode">[Unicode]</a>で定義される不正なコード単位列を含んでいた場合、それは致命的エラーである。エンコーディングがより上層のプロトコルで決定されていなければ、XML実体がエンコーディング宣言を持たず、かつその内容がUTF-8やUTF-16として許されるものでなければ、これも<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>である。</p>
<p class="original" lang="en" xml:lang="en">It is a <a title="Fatal Error" href="#dt-fatal">fatal error</a> when an XML processor encounters an entity with an encoding that it is unable to process. It is a <a title="Fatal Error" href="#dt-fatal">fatal error</a> if an XML entity is determined (via default, encoding declaration, or higher-level protocol) to be in a certain encoding but contains byte sequences that are not legal in that encoding. Specifically, it is a fatal error if an entity encoded in UTF-8 contains any irregular code unit sequences, as defined in Unicode <a href="#Unicode">[Unicode]</a>. Unless an encoding is determined by a higher-level protocol, it is also a <a title="Fatal Error" href="#dt-fatal">fatal error</a> if an XML entity contains no encoding declaration and its content is not legal UTF-8 or UTF-16.</p>
<p>エンコーディング宣言を含むテキスト宣言の例を幾つか挙げる。</p>
<p class="original" lang="en" xml:lang="en">Examples of text declarations containing encoding declarations:</p>
<div class="exampleInner">
<pre>
&lt;?xml encoding='UTF-8'?&gt;
&lt;?xml encoding='EUC-JP'?&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="sec-version-info" id="sec-version-info"></a>4.3.4 実体のバージョン情報<span class="original" lang="en" xml:lang="en"> Version Information in Entities</span></h4>
<p><a title="文書実体" href="#dt-docent">文書実体</a>を含めて、実体はそれぞれが別々にXML 1.0あるいはXML 1.1として宣言される事ができる。文書実体に現れるバージョン宣言が、その文書全体としてのバージョンを決定する。XML 1.1文書は、XML 1.0外部実体を呼び出しても良い。従って、バージョン宣言だけが違う、内容の重複した外部実体、特にDTDの外部サブセットを用意する必要は無い。しかしながら、そのような場合でもXML 1.1の規則が文書全体に適用される。</p>
<p class="original" lang="en" xml:lang="en">Each entity, including the <a title="Document Entity" href="#dt-docent">document entity</a>, can be separately declared as XML 1.0 or XML 1.1. The version declaration appearing in the document entity determines the version of the document as a whole. An XML 1.1 document may invoke XML 1.0 external entities, so that otherwise duplicated versions of external entities, particularly DTD external subsets, need not be maintained. However, in such a case the rules of XML 1.1 are applied to the entire document.</p>
<p>文書実体を含めて、実体にバージョン番号の記述が無ければ、その実体はあたかもバージョン1.0という記述を持つかの如く扱われる。</p>
<p class="original" lang="en" xml:lang="en">If an entity (including the document entity) is not labeled with a version number, it is treated as if labeled as version 1.0.</p>
</div>
</div>

<div class="div2">
<h3><a name="entproc" id="entproc"></a>4.4 XMLプロセッサによる実体と参照の扱い<span class="original" lang="en" xml:lang="en"> XML Processor Treatment of Entities and References</span></h3>
<p>以下に挙げる表は、文字参照、実体参照、及び解析対象外実体の呼び出しが現れ得る文脈と、それぞれの場合において<a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">要求される(REQUIRED)</em>動作を要約したものである。最左端の列のラベルは認識される文脈を説明する。認識される文脈の種類は次の通り。</p>
<p class="original" lang="en" xml:lang="en">The table below summarizes the contexts in which character references, entity references, and invocations of unparsed entities might appear and the <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em> behavior of an <a title="XML Processor" href="#dt-xml-proc">XML processor</a> in each case. The labels in the leftmost column describe the recognition context:</p>
<dl>
	<dt class="label">内容の中での参照<span class="original" lang="en" xml:lang="en"> Reference in Content</span></dt>
	<dd>
		<p>要素の<a title="開始タグ" href="#dt-stag">開始タグ</a>の後から<a title="終了タグ" href="#dt-etag">終了タグ</a>の手前までに現れる参照として。非終端<a href="#NT-content">content</a>に対応する。</p>
		<p class="original" lang="en" xml:lang="en">as a reference anywhere after the <a title="Start-Tag" href="#dt-stag">start-tag</a> and before the <a title="End Tag" href="#dt-etag">end-tag</a> of an element; corresponds to the nonterminal <a href="#NT-content">content</a>.</p>
	</dd>
	<dt class="label">属性値の中での参照<span class="original" lang="en" xml:lang="en"> Reference in Attribute Value</span></dt>
	<dd>
		<p><a title="開始タグ" href="#dt-stag">開始タグ</a>の属性の値の中、あるいは<a title="属性リスト宣言" href="#dt-attdecl">属性宣言</a>のデフォルト値の中に現れる参照として。非終端<a href="#NT-AttValue">AttValue</a>に対応する。</p>
		<p class="original" lang="en" xml:lang="en">as a reference within either the value of an attribute in a <a title="Start-Tag" href="#dt-stag">start-tag</a>, or a default value in an <a title="Attribute-List Declaration" href="#dt-attdecl">attribute declaration</a>; corresponds to the nonterminal <a href="#NT-AttValue">AttValue</a>.</p>
	</dd>
	<dt class="label">属性値としての名前<span class="original" lang="en" xml:lang="en"> Occurs as Attribute Value</span></dt>
	<dd>
		<p>型<b>ENTITY</b>として宣言された属性の値に現れる<a href="#NT-Name">Name</a>として、あるいは型<b>ENTITIES</b>として宣言された属性の値に含まれるスペースで区切られたトークンの一つ(<a href="#NT-Name">Name</a>)として。参照としてではない。</p>
		<p class="original" lang="en" xml:lang="en">as a <a href="#NT-Name">Name</a>, not a reference, appearing either as the value of an attribute which has been declared as type <b>ENTITY</b>, or as one of the space-separated tokens in the value of an attribute which has been declared as type <b>ENTITIES</b>.</p>
	</dd>
	<dt class="label">実体値の中での参照<span class="original" lang="en" xml:lang="en"> Reference in Entity Value</span></dt>
	<dd>
		<p>パラメータ実体や内部実体の実体宣言の中の<a title="リテラル実体値" href="#dt-litentval">リテラル実体値</a>に現れる参照として。非終端<a href="#NT-EntityValue">EntityValue</a>に対応する。</p>
		<p class="original" lang="en" xml:lang="en">as a reference within a parameter or internal entity's <a title="Literal Entity Value" href="#dt-litentval">literal entity value</a> in the entity's declaration; corresponds to the nonterminal <a href="#NT-EntityValue">EntityValue</a>.</p>
	</dd>
	<dt class="label">DTDの中での参照<span class="original" lang="en" xml:lang="en"> Reference in DTD</span></dt>
	<dd>
		<p><a title="文書型宣言" href="#dt-doctype">DTD</a>の内部サブセット、あるいは外部サブセットの中に現れる参照として。但し、<a href="#NT-EntityValue">EntityValue</a>、<a href="#NT-AttValue">AttValue</a>、<a href="#NT-PI">PI</a>、<a href="#NT-Comment">Comment</a>、<a href="#NT-SystemLiteral">SystemLiteral</a>、<a href="#NT-PubidLiteral">PubidLiteral</a>、及び無視される条件付きセクション(<a href="#sec-condition-sect"><b>3.4 条件付きセクション<span class="original" lang="en" xml:lang="en"> Conditional Sections</span></b></a>参照)の内容の外に限る。</p>
		<p class="original" lang="en" xml:lang="en">as a reference within either the internal or external subsets of the <a title="Document Type Declaration" href="#dt-doctype">DTD</a>, but outside of an <a href="#NT-EntityValue">EntityValue</a>, <a href="#NT-AttValue">AttValue</a>, <a href="#NT-PI">PI</a>, <a href="#NT-Comment">Comment</a>, <a href="#NT-SystemLiteral">SystemLiteral</a>, <a href="#NT-PubidLiteral">PubidLiteral</a>, or the contents of an ignored conditional section (see <a href="#sec-condition-sect"><b>3.4 Conditional Sections</b></a>).</p>
	</dd>
</dl>
<table border="1" frame="border" cellpadding="7" summary="実体の種類と参照の行列">
<tbody align="center">
	<tr>
		<td rowspan="2"></td>
		<td colspan="4" align="center" valign="bottom">実体の種類</td>
		<td rowspan="2" align="center">文字参照</td>
	</tr>
	<tr align="center" valign="bottom">
		<td>パラメータ実体</td>
		<td>内部一般実体</td>
		<td>外部解析対象一般実体</td>
		<td>解析対象外実体</td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">内容の中での参照</td>
		<td><a href="#not-recognized"><cite>認識されない</cite></a></td>
		<td><a href="#included"><cite>インクルードされる</cite></a></td>
		<td><a href="#include-if-valid"><cite>妥当性を検証する場合インクルードされる</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#included"><cite>インクルードされる</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">属性値の中での参照</td>
		<td><a href="#not-recognized"><cite>認識されない</cite></a></td>
		<td><a href="#inliteral"><cite>リテラルの中でインクルードされる</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#included"><cite>インクルードされる</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">属性値としての名前</td>
		<td><a href="#not-recognized"><cite>認識されない</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#notify"><cite>通知する</cite></a></td>
		<td><a href="#not-recognized"><cite>認識されない</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">実体値の中での参照</td>
		<td><a href="#inliteral"><cite>リテラルの中でインクルードされる</cite></a></td>
		<td><a href="#bypass"><cite>バイパスされる</cite></a></td>
		<td><a href="#bypass"><cite>バイパスされる</cite></a></td>
		<td><a href="#error"><cite>エラー</cite></a></td>
		<td><a href="#included"><cite>インクルードされる</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">DTDの中での参照</td>
		<td><a href="#as-PE"><cite>パラメータ実体としてインクルードされる</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
		<td><a href="#forbidden"><cite>許されない</cite></a></td>
	</tr>
</tbody>
</table>
<table class="original" lang="en" xml:lang="en" border="1" frame="border" cellpadding="7" summary="Entity type/reference matrix">
<tbody align="center">
	<tr>
		<td rowspan="2"></td>
		<td colspan="4" align="center" valign="bottom">Entity Type</td>
		<td rowspan="2" align="center">Character</td>
	</tr>
	<tr align="center" valign="bottom">
		<td>Parameter</td>
		<td>Internal General</td>
		<td>External Parsed General</td>
		<td>Unparsed</td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">Reference in Content</td>
		<td><a href="#not-recognized"><cite>Not recognized</cite></a></td>
		<td><a href="#included"><cite>Included</cite></a></td>
		<td><a href="#include-if-valid"><cite>Included if validating</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#included"><cite>Included</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">Reference in Attribute Value</td>
		<td><a href="#not-recognized"><cite>Not recognized</cite></a></td>
		<td><a href="#inliteral"><cite>Included in literal</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#included"><cite>Included</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">Occurs as Attribute Value</td>
		<td><a href="#not-recognized"><cite>Not recognized</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#notify"><cite>Notify</cite></a></td>
		<td><a href="#not-recognized"><cite>Not recognized</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">Reference in EntityValue</td>
		<td><a href="#inliteral"><cite>Included in literal</cite></a></td>
		<td><a href="#bypass"><cite>Bypassed</cite></a></td>
		<td><a href="#bypass"><cite>Bypassed</cite></a></td>
		<td><a href="#error"><cite>Error</cite></a></td>
		<td><a href="#included"><cite>Included</cite></a></td>
	</tr>
	<tr align="center" valign="middle">
		<td align="right">Reference in DTD</td>
		<td><a href="#as-PE"><cite>Included as PE</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
		<td><a href="#forbidden"><cite>Forbidden</cite></a></td>
	</tr>
</tbody>
</table>

<div class="div3">
<h4><a name="not-recognized" id="not-recognized"></a>4.4.1 認識されない<span class="original" lang="en" xml:lang="en"> Not Recognized</span></h4>
<p>DTDの外では、文字<code>%</code>は何ら特別な意味を持たない。従って、DTDの中ではパラメータ実体参照になるであろうものでも、<a href="#NT-content">content</a>の中ではマークアップとして認識されない。同様に、解析対象外実体の名前も、適切に宣言された属性の値に現れた時を除き認識されない。</p>
<p class="original" lang="en" xml:lang="en">Outside the DTD, the <code>%</code> character has no special significance; thus, what would be parameter entity references in the DTD are not recognized as markup in <a href="#NT-content">content</a>. Similarly, the names of unparsed entities are not recognized except when they appear in the value of an appropriately declared attribute.</p>
</div>

<div class="div3">
<h4><a name="included" id="included"></a>4.4.2 インクルードされる<span class="original" lang="en" xml:lang="en"> Included</span></h4>
<p>[<a name="dt-include" id="dt-include" title="インクルードする">定義</a>: 実体は、その<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>が入手されて処理された時、その参照そのものがあった場所に入れ替わって<b>インクルード</b>される。あたかも、文書中でその参照が認識された場所にあったものがその置換テキストであるかのようにである。] 置換テキストは、<a title="文字データ" href="#dt-chardata">文字データ</a>と<a title="マークアップ" href="#dt-markup">マークアップ</a>の両方を含んで良い(但しパラメータ実体はマークアップを含む事はできない)。マークアップは、いつも通りに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">認識されなければならない(MUST)</em>(例えば、文字列"<code>AT&amp;amp;T;</code>"は"<code>AT&amp;T;</code>"に展開される。ここで、後者の文字列に残ったアンパサンドは実体参照の区切り子とは認識されない)。文字参照は、参照によって指し示された文字が処理された時、その参照そのものがあった場所に<b>インクルード</b>される。</p>
<p class="original" lang="en" xml:lang="en">[Definition: An entity is <b>included</b> when its <a title="Replacement Text" href="#dt-repltext">replacement text</a> is retrieved and processed, in place of the reference itself, as though it were part of the document at the location the reference was recognized.] The replacement text may contain both <a title="Character Data" href="#dt-chardata">character data</a> and (except for parameter entities) <a title="Markup" href="#dt-markup">markup</a>, which <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be recognized in the usual way. (The string "<code>AT&amp;amp;T;</code>" expands to "<code>AT&amp;T;</code>" and the remaining ampersand is not recognized as an entity-reference delimiter.) A character reference is <b>included</b> when the indicated character is processed in place of the reference itself.</p>
</div>

<div class="div3">
<h4><a name="include-if-valid" id="include-if-valid"></a>4.4.3 妥当性を検証する場合インクルードされる<span class="original" lang="en" xml:lang="en"> Included If Validating</span></h4>
<p>XMLプロセッサが解析対象実体への参照を認識した時、文書の<a title="妥当性" href="#dt-valid">妥当性を検証する</a>のであれば、プロセッサはその置換テキストを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="インクルードする" href="#dt-include">インクルード</a>しなければならない(MUST)</em>。その実体が外部実体であり、プロセッサがそのXML文書の妥当性を検証しようとしていない場合、プロセッサはその実体の置換テキストを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">インクルードしても良い(MAY)</em>が、必ずしもそうする必要は無い。妥当性を検証しないプロセッサが置換テキストをインクルードしない時には、プロセッサは、実体が参照されている事を認識はしたが、読み取りはしなかった事をアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">知らせなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">When an XML processor recognizes a reference to a parsed entity, in order to <a title="Validity" href="#dt-valid">validate</a> the document, the processor <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> <a title="Include" href="#dt-include">include</a> its replacement text. If the entity is external, and the processor is not attempting to validate the XML document, the processor <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em>, but need not, include the entity's replacement text. If a non-validating processor does not include the replacement text, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> inform the application that it recognized, but did not read, the entity.</p>
<p>この規則は、主に文書を書く際のモジュール分けを助ける為に考えられた、SGML及びXML実体機構の自動インクルージョンが、必ずしも他のアプリケーション(特に文書のブラウジング)に対しては適切ではないという認識に基づいている。例えば、ブラウザは、外部解析対象実体参照を見つけた時、視覚的な情報を以て実体の存在を知らせるに留め、ユーザが要求するまでは、ディスプレイに表示する為に実体の内容を入手する事はしないだろう。</p>
<p class="original" lang="en" xml:lang="en">This rule is based on the recognition that the automatic inclusion provided by the SGML and XML entity mechanism, primarily designed to support modularity in authoring, is not necessarily appropriate for other applications, in particular document browsing. Browsers, for example, when encountering an external parsed entity reference, might choose to provide a visual indication of the entity's presence and retrieve it for display only on demand.</p>
</div>

<div class="div3">
<h4><a name="forbidden" id="forbidden"></a>4.4.4 許されない<span class="original" lang="en" xml:lang="en"> Forbidden</span></h4>
<p>次の事は許されない。もしあれば<a title="致命的エラー" href="#dt-fatal">致命的エラー</a>となる。</p>
<p class="original" lang="en" xml:lang="en">The following are forbidden, and constitute <a title="Fatal Error" href="#dt-fatal">fatal errors</a>:</p>
<ul>
	<li>
		<p><a title="解析対象外実体" href="#dt-unparsed">解析対象外実体</a>への参照の出現。但し、実体宣言の<a href="#NT-EntityValue">EntityValue</a>の中に現れた場合を除く。</p>
		<p class="original" lang="en" xml:lang="en">the appearance of a reference to an <a title="Unparsed Entity" href="#dt-unparsed">unparsed entity</a>, except in the <a href="#NT-EntityValue">EntityValue</a> in an entity declaration.</p>
	</li>
	<li>
		<p>DTDの中での文字参照や一般実体参照の出現。但し、<a href="#NT-EntityValue">EntityValue</a>の中と<a href="#NT-AttValue">AttValue</a>の中に現れた場合を除く。</p>
		<p class="original" lang="en" xml:lang="en">the appearance of any character or general-entity reference in the DTD except within an <a href="#NT-EntityValue">EntityValue</a> or <a href="#NT-AttValue">AttValue</a>.</p>
	</li>
	<li>
		<p>属性値の中での外部実体への参照。</p>
		<p class="original" lang="en" xml:lang="en">a reference to an external entity in an attribute value.</p>
	</li>
</ul>
</div>

<div class="div3">
<h4><a name="inliteral" id="inliteral"></a>4.4.5 リテラルの中でインクルードされる<span class="original" lang="en" xml:lang="en"> Included in Literal</span></h4>
<p><a title="実体参照" href="#dt-entref">実体参照</a>が属性値の中に現れた時、あるいはパラメータ実体参照がリテラル実体値の中に現れた時、その<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>は、あたかも文書中でその参照が認識された場所にあったものがそれであるかのように、参照そのものと入れ替わって<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">処理されなければならない(MUST)</em>。但し、置換テキストに含まれる単引用符や二重引用符は例外で、それらは常にただの文字として<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">扱われなければならず(MUST)</em>、リテラルを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">終わらせてはならない(MUST NOT)</em>。例えば、次の例は整形式である。</p>
<p class="original" lang="en" xml:lang="en">When an <a title="Entity Reference" href="#dt-entref">entity reference</a> appears in an attribute value, or a parameter entity reference appears in a literal entity value, its <a title="Replacement Text" href="#dt-repltext">replacement text</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be processed in place of the reference itself as though it were part of the document at the location the reference was recognized, except that a single or double quote character in the replacement text <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> always be treated as a normal data character and <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> terminate the literal. For example, this is well-formed:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY % YN '"Yes"' &gt;
&lt;!ENTITY WhatHeSaid "He said %YN;" &gt;
</pre>
</div>
<p>しかし次の例は整形式ではない。</p>
<p class="original" lang="en" xml:lang="en">while this is not:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY EndAttr "27'" &gt;
&lt;element attribute='a-&amp;EndAttr;&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a name="notify" id="notify"></a>4.4.6 通知する<span class="original" lang="en" xml:lang="en"> Notify</span></h4>
<p><a title="解析対象外実体" href="#dt-unparsed">解析対象外実体</a>の名前が、型<b>ENTITY</b>あるいは型<b>ENTITIES</b>として宣言された属性の値に含まれるトークンとして現れた場合、妥当性を検証するプロセッサは、その実体と関連付けられた<a title="記法" href="#dt-notation">記法</a>の両方について、<a title="システム識別子" href="#dt-sysid">システム識別子</a>と、もしあれば<a title="公開識別子" href="#dt-pubid">公開識別子</a>をアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">知らせなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">When the name of an <a title="Unparsed Entity" href="#dt-unparsed">unparsed entity</a> appears as a token in the value of an attribute of declared type <b>ENTITY</b> or <b>ENTITIES</b>, a validating processor <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> inform the application of the <a title="System Identifier" href="#dt-sysid">system</a> and <a title="Public identifier" href="#dt-pubid">public</a> (if any) identifiers for both the entity and its associated <a title="Notation" href="#dt-notation">notation</a>.</p>
</div>

<div class="div3">
<h4><a name="bypass" id="bypass"></a>4.4.7 バイパスされる<span class="original" lang="en" xml:lang="en"> Bypassed</span></h4>
<p>一般実体参照が実体宣言の<a href="#NT-EntityValue">EntityValue</a>に現れた場合、その参照はバイパスされ、そのままの状態に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">されておかなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">When a general entity reference appears in the <a href="#NT-EntityValue">EntityValue</a> in an entity declaration, it <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be bypassed and left as is.</p>
</div>

<div class="div3">
<h4><a name="as-PE" id="as-PE"></a>4.4.8 パラメータ実体としてインクルードされる<span class="original" lang="en" xml:lang="en"> Included as PE</span></h4>
<p>外部解析対象実体と同様に、パラメータ実体は<a href="#include-if-valid"><cite>妥当性を検証する場合にのみインクルード</cite></a>される必要がある。パラメータ実体参照がDTDの中で認識されてインクルードされる時、その<a title="置換テキスト" href="#dt-repltext">置換テキスト</a>は、先頭と末尾にスペース文字(#x20)を一つずつ<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">付け加えられなければならない(MUST)</em>。この意図は、パラメータ実体の置換テキストに、DTDで必要になるだけの数の文法トークンを持たせるよう制約を課す事である。この動作は、実体値の中に現れるパラメータ実体参照には<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">適用されてはならない(MUST NOT)</em>。それらについては<a href="#inliteral"><b>4.4.5 リテラルの中でインクルードされる<span class="original" lang="en" xml:lang="en"> Included in Literal</span></b></a>で説明されている。</p>
<p class="original" lang="en" xml:lang="en">Just as with external parsed entities, parameter entities need only be <a href="#include-if-valid"><cite>included if validating</cite></a>. When a parameter-entity reference is recognized in the DTD and included, its <a title="Replacement Text" href="#dt-repltext">replacement text</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be enlarged by the attachment of one leading and one following space (#x20) character; the intent is to constrain the replacement text of parameter entities to contain an integral number of grammatical tokens in the DTD. This behavior <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> apply to parameter entity references within entity values; these are described in <a href="#inliteral"><b>4.4.5 Included in Literal</b></a>.</p>
</div>

<div class="div3">
<h4><a name="error" id="error"></a>4.4.9 エラー<span class="original" lang="en" xml:lang="en"> Error</span></h4>
<p>実体宣言の<a href="#NT-EntityValue">EntityValue</a>の中に解析対象外実体への参照が現れる事は<a title="エラー" href="#dt-error">エラー</a>である。</p>
<p class="original" lang="en" xml:lang="en">It is an <a title="Error" href="#dt-error">error</a> for a reference to an unparsed entity to appear in the <a href="#NT-EntityValue">EntityValue</a> in an entity declaration.</p>
</div>
</div>

<div class="div2">
<h3><a name="intern-replacement" id="intern-replacement"></a>4.5 実体の置換テキストの構築<span class="original" lang="en" xml:lang="en"> Construction of Entity Replacement Text</span></h3>
<p>実体の扱いについて取り扱う際、二種類の実体値を区別すると便利である。 [<a name="dt-litentval" id="dt-litentval" title="リテラル実体値">定義</a>: 内部実体について、<b>リテラル実体値</b>は、実体宣言の中に実際に存在する、引用符で挟まれた文字列である。これは非終端<a href="#NT-EntityValue">EntityValue</a>に対応する。] [<a name="dt-extlitentval" id="dt-extlitentval" title="リテラル実体値">定義</a>: 外部実体について、<b>リテラル実体値</b>は、その実体に含まれるテキストそのものである。] [<a name="dt-repltext" id="dt-repltext" title="置換テキスト">定義</a>: 内部実体について、<b>置換テキスト</b>は、文字参照とパラメータ実体参照を置換した後における、その実体の内容である。] [<a name="dt-extrepltext" id="dt-extrepltext" title="置換テキスト">定義</a>: 外部実体について、<b>置換テキスト</b>は、テキスト宣言が存在すればそれを取り去った後における、その実体の内容である。但しテキスト宣言を取り去る場合でも、その周囲のホワイトスペースはそのまま置換テキストに残る。また、文字参照やパラメータ実体参照も置換されない。]</p>
<p class="original" lang="en" xml:lang="en">In discussing the treatment of entities, it is useful to distinguish two forms of the entity's value. [Definition: For an internal entity, the <b>literal entity value</b> is the quoted string actually present in the entity declaration, corresponding to the non-terminal <a href="#NT-EntityValue">EntityValue</a>.] [Definition: For an external entity, the <b>literal entity value</b> is the exact text contained in the entity.] [Definition: For an internal entity, the <b>replacement text</b> is the content of the entity, after replacement of character references and parameter-entity references.] [Definition: For an external entity, the <b>replacement text</b> is the content of the entity, after stripping the text declaration (leaving any surrounding white space) if there is one but without any replacement of character references or parameter-entity references.]</p>
<p>内部実体宣言で与えられるリテラル実体値(<a href="#NT-EntityValue">EntityValue</a>)は、文字参照、パラメータ実体参照、一般実体参照を含んでも良い。そのような参照は、全体がそのリテラル実体値の中に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まれなければならない(MUST)</em>。<a title="インクルードされる" href="#dt-include">インクルード</a>された(あるいは<a title="" href="#inliteral">リテラルの中でインクルード</a>された)実際の置換テキストは、上で説明されているように、参照されたパラメータ実体の<em>置換テキスト</em>を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まなければならない(MUST)</em>し、リテラル実体値中の文字参照の代わりに、参照された文字を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">含まなければならない(MUST)</em>。しかし、一般実体参照は、そのまま、つまり展開されないままに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">しておかれなければならない(MUST)</em>。例えば、次の宣言を与えられたものとする。</p>
<p class="original" lang="en" xml:lang="en">The literal entity value as given in an internal entity declaration (<a href="#NT-EntityValue">EntityValue</a>) may contain character, parameter-entity, and general-entity references. Such references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be contained entirely within the literal entity value. The actual replacement text that is <a title="Include" href="#dt-include">included</a> (or <a title="" href="#inliteral">included in literal</a>) as described above <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> contain the <em>replacement text</em> of any parameter entities referred to, and <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> contain the character referred to, in place of any character references in the literal entity value; however, general-entity references <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be left as-is, unexpanded. For example, given the following declarations:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY % pub "&amp;#xc9;ditions Gallimard" &gt;
&lt;!ENTITY rights "All rights reserved" &gt;
&lt;!ENTITY book "La Peste: Albert Camus,
&amp;#xA9; 1947 %pub;. &amp;rights;" &gt;
</pre>
</div>
<p>この時、実体"<code>book</code>"の置換テキストは次のようになる。</p>
<p class="original" lang="en" xml:lang="en">then the replacement text for the entity "<code>book</code>" is:</p>
<div class="exampleInner">
<pre>
La Peste: Albert Camus,
© 1947 Éditions Gallimard. &amp;rights;
</pre>
</div>
<p>もし参照"<code>&amp;book;</code>"が文書の内容や属性値の中に現れるなら、一般実体参照"<code>&amp;rights;</code>"も展開されるだろう。</p>
<p class="original" lang="en" xml:lang="en">The general-entity reference "<code>&amp;rights;</code>" would be expanded should the reference "<code>&amp;book;</code>" appear in the document's content or an attribute value.</p>
<p>これらの簡単な規則が複雑な相互作用をする事もある。難しい例を用いた詳しい説明は、<a href="#sec-entexpand"><b>C 実体参照と文字参照の展開<span class="original" lang="en" xml:lang="en"> Expansion of Entity and Character References</span></b></a>で見られる。</p>
<p class="original" lang="en" xml:lang="en">These simple rules may have complex interactions; for a detailed discussion of a difficult example, see <a href="#sec-entexpand"><b>C Expansion of Entity and Character References</b></a>.</p>
</div>

<div class="div2">
<h3><a name="sec-predefined-ent" id="sec-predefined-ent"></a>4.6 定義済み実体<span class="original" lang="en" xml:lang="en"> Predefined Entities</span></h3>
<p>[<a name="dt-escape" id="dt-escape" title="エスケープする">定義</a>: 実体参照や文字参照は、左山括弧、アンパサンド、及びその他の区切り子を<b>エスケープ</b>する為に使われる事がある。一般実体のセット(<code>amp</code>、<code>lt</code>、<code>gt</code>、<code>apos</code>、<code>quot</code>)がこの目的の為に定められている。数値文字参照も使われる事がある。文字参照は認識された時直ちに展開され、文字データとして<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">扱われなければならない(MUST)</em>。この為、数値文字参照"<code>&amp;#60;</code>"と"<code>&amp;#38;</code>"は、文字データの中で現れた時、<code>&lt;</code>と<code>&amp;</code>をエスケープする為に使われる事ができる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: Entity and character references may both be used to <b>escape</b> the left angle bracket, ampersand, and other delimiters. A set of general entities (<code>amp</code>, <code>lt</code>, <code>gt</code>, <code>apos</code>, <code>quot</code>) is specified for this purpose. Numeric character references may also be used; they are expanded immediately when recognized and <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be treated as character data, so the numeric character references "<code>&amp;#60;</code>" and "<code>&amp;#38;</code>" may be used to escape <code>&lt;</code> and <code>&amp;</code> when they occur in character data.]</p>
<p>すべてのXMLプロセッサは、これらの実体が宣言されているかいないかに拘わらず、それらを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">認識しなければならない(MUST)</em>。<a title="相互運用性の為に" href="#dt-interop">相互運用性の為に</a>、妥当なXML文書は、他の実体と同じように、これらの実体も使う前に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言する事が望ましい(SHOULD)</em>。実体<code>lt</code>や<code>amp</code>が宣言される場合、置換テキストが、エスケープされているそれぞれの文字(左山括弧かアンパサンド)への文字参照となる内部実体として<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されなければならない(MUST)</em>。これらの実体への参照をしても整形式であるようにする為に、二重のエスケーピングは<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">必須である(REQUIRED)</em>。実体<code>gt</code>、<code>apos</code>、及び<code>quot</code>が宣言される場合、置換テキストがエスケープされている一つの文字となる内部実体として<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されなければならない(MUST)</em>(置換テキストが、その文字への文字参照となる内部実体として宣言されても良い。ここでの二重エスケーピングは<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">任意である(OPTIONAL)</em>が、やったとしても無害である)。これらの実体の宣言の例を次に挙げる。</p>
<p class="original" lang="en" xml:lang="en">All XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> recognize these entities whether they are declared or not. <a title="For interoperability" href="#dt-interop">For interoperability</a>, valid XML documents <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> declare these entities, like any others, before using them. If the entities <code>lt</code> or <code>amp</code> are declared, they <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be declared as internal entities whose replacement text is a character reference to the respective character (less-than sign or ampersand) being escaped; the double escaping is <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em> for these entities so that references to them produce a well-formed result. If the entities <code>gt</code>, <code>apos</code>, or <code>quot</code> are declared, they <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be declared as internal entities whose replacement text is the single character being escaped (or a character reference to that character; the double escaping here is <em class="rfc2119" title="Keyword in RFC 2119 context">OPTIONAL</em> but harmless). For example:</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY lt     "&amp;#38;#60;"&gt;
&lt;!ENTITY gt     "&amp;#62;"&gt;
&lt;!ENTITY amp    "&amp;#38;#38;"&gt;
&lt;!ENTITY apos   "&amp;#39;"&gt;
&lt;!ENTITY quot   "&amp;#34;"&gt;
</pre>
</div>
</div>

<div class="div2">
<h3><a name="Notations" id="Notations"></a>4.7 記法宣言<span class="original" lang="en" xml:lang="en"> Notation Declarations</span></h3>
<p>[<a name="dt-notation" id="dt-notation" title="記法">定義</a>: <b>記法</b>は、<a title="解析対象外実体" href="#dt-unparsed">解析対象外実体</a>のフォーマットや、記法属性を持つ要素のフォーマット、あるいは<a title="処理命令" href="#dt-pi">処理命令</a>が与えられるアプリケーションを、名前で識別する。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Notations</b> identify by name the format of <a title="Unparsed Entity" href="#dt-unparsed">unparsed entities</a>, the format of elements which bear a notation attribute, or the application to which a <a title="Processing instruction" href="#dt-pi">processing instruction</a> is addressed.]</p>
<p>[<a name="dt-notdecl" id="dt-notdecl" title="記法宣言">定義</a>: <b>記法宣言</b>は、実体宣言や属性リスト宣言、属性指定で使う為の、記法の名前を提供する。また、その記法のデータを処理する事のできるヘルパーアプリケーションの位置をXMLプロセッサやそのクライアントアプリケーションに伝える、外部識別子も提供する。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Notation declarations</b> provide a name for the notation, for use in entity and attribute-list declarations and in attribute specifications, and an external identifier for the notation which may allow an XML processor or its client application to locate a helper application capable of processing data in the given notation.]</p>
<h5><a name="IDANRMS" id="IDANRMS"></a>記法宣言<span class="original" lang="en" xml:lang="en"> Notation Declarations</span></h5>
<table class="scrap" summary="スクラップ">
<tbody>
	<tr valign="baseline">
		<td><a name="NT-NotationDecl" id="NT-NotationDecl"></a>[82]   </td>
		<td><code>NotationDecl</code></td>
		<td>   ::=   </td>
		<td><code>'&lt;!NOTATION' <a href="#NT-S">S</a> <a href="#NT-Name">Name</a> <a href="#NT-S">S</a> ( <a href="#NT-ExternalID">ExternalID</a> | <a href="#NT-PublicID">PublicID</a> ) <a href="#NT-S">S</a>? '&gt;'</code></td>
		<td><a href="#UniqueNotationName">[妥当性制約: 一意な記法名]</a></td>
	</tr>
</tbody>
<tbody>
	<tr valign="baseline">
		<td><a name="NT-PublicID" id="NT-PublicID"></a>[83]   </td>
		<td><code>PublicID</code></td>
		<td>   ::=   </td>
		<td><code>'PUBLIC' <a href="#NT-S">S</a> <a href="#NT-PubidLiteral">PubidLiteral</a></code></td>
	</tr>
</tbody>
</table>
<div class="constraint">
	<p class="prefix"><a name="UniqueNotationName" id="UniqueNotationName"></a><b>妥当性制約: 一意な記法名<span class="original" lang="en" xml:lang="en"> Validity constraint: Unique Notation Name</span></b></p>
	<p>与えられる<a href="#NT-Name">Name</a>は、二つ以上の記法宣言で<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">宣言されてはならない(MUST NOT)</em>。</p>
	<p class="original" lang="en" xml:lang="en">A given <a href="#NT-Name">Name</a> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> be declared in more than one notation declaration.</p>
</div>
<p>XMLプロセッサは、宣言され、属性値や属性定義、実体宣言で参照されたすべての記法について、その名前と外部識別子をアプリケーションに<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">提供しなければならない(MUST)</em>。それに加えて、外部識別子を、<a title="システム識別子" href="#dt-sysid">システム識別子</a>やファイル名、あるいは指定された記法のデータを処理する為のプロセッサをアプリケーションが呼び出す為に必要なその他の情報に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">解決しても良い(MAY)</em>。しかしながら、XMLプロセッサやアプリケーションが動作しているシステムでは入手不能なアプリケーションを指定する記法を、XML文書が宣言したり参照したりしても、エラーにはならない。</p>
<p class="original" lang="en" xml:lang="en">XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> provide applications with the name and external identifier(s) of any notation declared and referred to in an attribute value, attribute definition, or entity declaration. They <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> additionally resolve the external identifier into the <a title="System Identifier" href="#dt-sysid">system identifier</a>, file name, or other information needed to allow the application to call a processor for data in the notation described. (It is not an error, however, for XML documents to declare and refer to notations for which notation-specific applications are not available on the system where the XML processor or application is running.)</p>
</div>

<div class="div2">
<h3><a name="sec-doc-entity" id="sec-doc-entity"></a>4.8 文書実体<span class="original" lang="en" xml:lang="en"> Document Entity</span></h3>
<p>[<a name="dt-docent" id="dt-docent" title="文書実体">定義</a>: <b>文書実体</b>は、実体ツリーのルートや、<a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>の開始点になる。] この仕様書では、文書実体がXMLプロセッサによってどのように探し出されるべきかについては指定しない。他の実体と違って、文書実体には名前が無く、プロセッサの入力ストリームに現れる時も一切の識別情報を持たずに現れるであろう。</p>
<p class="original" lang="en" xml:lang="en">[Definition: The <b>document entity</b> serves as the root of the entity tree and a starting-point for an <a title="XML Processor" href="#dt-xml-proc">XML processor</a>.] This specification does not specify how the document entity is to be located by an XML processor; unlike other entities, the document entity has no name and might well appear on a processor input stream without any identification at all.</p>
</div>
</div>

<div class="div1">
<h2><a name="sec-conformance" id="sec-conformance"></a>5 適合性<span class="original" lang="en" xml:lang="en"> Conformance</span></h2>

<div class="div2">
<h3><a name="proc-types" id="proc-types"></a>5.1 妥当性を検証するプロセッサとしないプロセッサ<span class="original" lang="en" xml:lang="en"> Validating and Non-Validating Processors</span></h3>
<p>仕様に適合する<a title="XMLプロセッサ" href="#dt-xml-proc">XMLプロセッサ</a>は、妥当性を検証するものと妥当性を検証しないものの二種類に分類される。</p>
<p class="original" lang="en" xml:lang="en">Conforming <a title="XML Processor" href="#dt-xml-proc">XML processors</a> fall into two classes: validating and non-validating.</p>
<p>妥当性を検証するプロセッサとしないプロセッサは何れも、<a title="文書実体" href="#dt-docent">文書実体</a>やそれ以外に読み取った<a title="テキスト実体" href="#dt-parsedent">解析対象実体</a>の内容で、この仕様書の整形式性制約の違反を見つけた場合、その違反を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">Validating and non-validating processors alike <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> report violations of this specification's well-formedness constraints in the content of the <a title="Document Entity" href="#dt-docent">document entity</a> and any other <a title="Text Entity" href="#dt-parsedent">parsed entities</a> that they read.</p>
<p>[<a name="dt-validating" id="dt-validating" title="妥当性を検証するプロセッサ">定義</a>: <b>妥当性を検証するプロセッサ</b>は、ユーザが選択した場合、<a title="文書型宣言" href="#dt-doctype">DTD</a>の宣言で表される制約の違反や、この仕様書で与えられる妥当性制約の不履行を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">報告しなければならない(MUST)</em>。] これを達成する為、妥当性を検証するプロセッサは、DTD全体、及び文書で参照されたすべての外部解析対象実体を読み取り、<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">処理しなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Validating processors</b> <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em>, at user option, report violations of the constraints expressed by the declarations in the <a title="Document Type Declaration" href="#dt-doctype">DTD</a>, and failures to fulfill the validity constraints given in this specification.] To accomplish this, validating XML processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> read and process the entire DTD and all external parsed entities referenced in the document.</p>
<p>妥当性を検証しないプロセッサでは、内部DTDサブセット全体を含めた<a title="文書実体" href="#dt-docent">文書実体</a>だけを、整形式性を調べる為に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">検査する事が必須とされる(REQUIRED)</em>。 [<a name="dt-use-mdecl" id="dt-use-mdecl" title="宣言を処理する">定義</a>: 妥当性を検証しないプロセッサは、妥当性を調べる為に文書を検査する事は要求されないが、内部DTDサブセットの中や、読み取ったパラメータ実体の中に現れる宣言を、<em>読み取らない</em>パラメータ実体への参照が最初に現れるまで<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><b>処理する</b>事が必須とされる(REQUIRED)</em>。つまり、妥当性を検証しないプロセッサは、それらの宣言に含まれる情報を、属性値を<a href="#AVNormalize"><cite>正規化し</cite></a>たり、内部実体の置換テキストを<a href="#included"><cite>インクルード</cite></a>したり、<a href="#sec-attr-defaults"><cite>デフォルト属性値</cite></a>を提供したりする為に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使わなければならない(MUST)</em>。] <code>standalone="yes"</code>である場合を除き、妥当性を検証しないプロセッサは、読み取らないパラメータ実体への参照に出くわした後に見つけた<a title="実体宣言" href="#dt-entdecl">実体宣言</a>や<a title="属性リスト宣言" href="#dt-attdecl">属性リスト宣言</a>を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード"><a title="宣言を処理する" href="#dt-use-mdecl">処理</a>してはならない(MUST NOT)</em>。これは、その読み取らない実体が上書きする宣言を持っているかも知れないからである。一方、<code>standalone="yes"</code>である場合は、プロセッサはこれらの宣言(読み取らないパラメータ実体への参照に出くわした後に見つけた宣言)を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">処理しなければならない(MUST)</em>。</p>
<p class="original" lang="en" xml:lang="en">Non-validating processors are <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em> to check only the <a title="Document Entity" href="#dt-docent">document entity</a>, including the entire internal DTD subset, for well-formedness. [Definition: While they are not required to check the document for validity, they are <em class="rfc2119" title="Keyword in RFC 2119 context">REQUIRED</em> to <b>process</b> all the declarations they read in the internal DTD subset and in any parameter entity that they read, up to the first reference to a parameter entity that they do <em>not</em> read; that is to say, they <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> use the information in those declarations to <a href="#AVNormalize"><cite>normalize</cite></a> attribute values, <a href="#included"><cite>include</cite></a> the replacement text of internal entities, and supply <a href="#sec-attr-defaults"><cite>default attribute values</cite></a>.] Except when <code>standalone="yes"</code>, they <em class="rfc2119" title="Keyword in RFC 2119 context">MUST NOT</em> <a title="Process Declarations" href="#dt-use-mdecl">process</a> <a title="entity declaration" href="#dt-entdecl">entity declarations</a> or <a title="Attribute-List Declaration" href="#dt-attdecl">attribute-list declarations</a> encountered after a reference to a parameter entity that is not read, since the entity may have contained overriding declarations; when <code>standalone="yes"</code>, processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> process these declarations.</p>
<p>注意してほしいのは、妥当でない文書を妥当性を検証しないプロセッサで処理する時、アプリケーションは矛盾の無い情報を受け取れない事があるかも知れない事である。例えば、文書における一意性に関する幾つかの要件が満たされないかも知れない(同じIDを持つ要素が二つ以上あったり、同じ名前を持つ要素型や記法の重複した宣言があったりするかも知れない)。これらの場合、それらの情報をアプリケーションに報告するという点では、パーサの動作は定義されない。</p>
<p class="original" lang="en" xml:lang="en">Note that when processing invalid documents with a non-validating processor the application may not be presented with consistent information. For example, several requirements for uniqueness within the document may not be met, including more than one element with the same id, duplicate declarations of elements or notations with the same name, etc. In these cases the behavior of the parser with respect to reporting such information to the application is undefined.</p>
<p>XML 1.1プロセッサは、XML 1.0文書とXML 1.1文書の両方を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">処理できなければならない(MUST)</em>。XMLを生成するプログラムは、XML 1.1特有の機能が必要とされない限り、XML 1.0を<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">生成する事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">XML 1.1 processors <em class="rfc2119" title="Keyword in RFC 2119 context">MUST</em> be able to process both XML 1.0 and XML 1.1 documents. Programs which generate XML <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> generate XML 1.0, unless one of the specific features of XML 1.1 is required.</p>
</div>

<div class="div2">
<h3><a name="safe-behavior" id="safe-behavior"></a>5.2 XMLプロセッサの使用<span class="original" lang="en" xml:lang="en"> Using XML Processors</span></h3>
<p>妥当性を検証するXMLプロセッサの動作は非常に予測しやすい。文書のすべての構成要素を読み取って、すべての整形式性違反と妥当性違反を報告しなければならないからである。妥当性を検証しないプロセッサではそれ程要求されない。文書実体以外の文書の構成要素は、読み取る事が必要とされないのである。この事には、XMLプロセッサのユーザにとって重要となる二つの効果がある。</p>
<p class="original" lang="en" xml:lang="en">The behavior of a validating XML processor is highly predictable; it must read every piece of a document and report all well-formedness and validity violations. Less is required of a non-validating processor; it need not read any part of the document other than the document entity. This has two effects that may be important to users of XML processors:</p>
<ul>
	<li>
		<p>ある種の整形式性エラー、特に外部実体の読み取りを必要とするものは、妥当性を検証しないプロセッサでは検知に失敗するかも知れない。例として、<a href="#wf-entdeclared"><cite>宣言された実体</cite></a>、<a href="#textent"><cite>解析対象実体</cite></a>、<a href="#norecursion"><cite>一切無い再帰</cite></a>と題された制約や、<a href="#entproc"><b>4.4 XMLプロセッサによる実体と参照の扱い<span class="original" lang="en" xml:lang="en"> XML Processor Treatment of Entities and References</span></b></a>で<a href="#forbidden"><cite>許されない</cite></a>として説明されている場合の内の幾つかが挙げられる。</p>
		<p class="original" lang="en" xml:lang="en">Certain well-formedness errors, specifically those that require reading external entities, may fail to be detected by a non-validating processor. Examples include the constraints entitled <a href="#wf-entdeclared"><cite>Entity Declared</cite></a>, <a href="#textent"><cite>Parsed Entity</cite></a>, and <a href="#norecursion"><cite>No Recursion</cite></a>, as well as some of the cases described as <a href="#forbidden"><cite>forbidden</cite></a> in <a href="#entproc"><b>4.4 XML Processor Treatment of Entities and References</b></a>.</p>
	</li>
	<li>
		<p>プロセッサからアプリケーションに渡される情報は、プロセッサが外部実体やパラメータ実体を読み取るかどうかによって、変化する事がある。例えば、妥当性を検証しないプロセッサは、属性値を<a href="#AVNormalize"><cite>正規化し</cite></a>たり、内部実体の置換テキストを<a href="#included"><cite>インクルード</cite></a>したり、<a href="#sec-attr-defaults"><cite>デフォルト属性値</cite></a>を提供したりする事ができないかも知れない(それらの遂行が外部実体やパラメータ実体の中の宣言の読み取りに依存する場合)。</p>
		<p class="original" lang="en" xml:lang="en">The information passed from the processor to the application may vary, depending on whether the processor reads parameter and external entities. For example, a non-validating processor may fail to <a href="#AVNormalize"><cite>normalize</cite></a> attribute values, <a href="#included"><cite>include</cite></a> the replacement text of internal entities, or supply <a href="#sec-attr-defaults"><cite>default attribute values</cite></a>, where doing so depends on having read declarations in external or parameter entities.</p>
	</li>
</ul>
<p>異なるXMLプロセッサと相互運用する際の信頼性を最大化する為には、妥当性を検証しないプロセッサを使うアプリケーションがそのプロセッサでは要求されない動作に<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">頼る事は望ましくない(SHOULD NOT)</em>。妥当性の検証に関係の無いDTDが提供する便利なもの(外部実体の中で指定される、あるいは指定されるかも知れないデフォルト属性の宣言や内部実体など)を必要とするアプリケーションは、妥当性を検証するプロセッサを<em class="rfc2119" title="RFC 2119で意味が定義されるキーワード">使う事が望ましい(SHOULD)</em>。</p>
<p class="original" lang="en" xml:lang="en">For maximum reliability in interoperating between different XML processors, applications which use non-validating processors <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD NOT</em> rely on any behaviors not required of such processors. Applications which require DTD facilities not related to validation (such as the declaration of default attributes and internal entities that are or may be specified in external entities) <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> use validating XML processors.</p>
</div>
</div>

<div class="div1">
<h2><a name="sec-notation" id="sec-notation"></a>6 仕様書の記法<span class="original" lang="en" xml:lang="en"> Notation</span></h2>
<p>XMLの正式な文法は、簡単なEBNF(Extended Backus-Naur Form)記法を用いてこの仕様書で与えられる。文法のそれぞれの規則は、次の形式で、一つのシンボルを定義する。</p>
<p class="original" lang="en" xml:lang="en">The formal grammar of XML is given in this specification using a simple Extended Backus-Naur Form (EBNF) notation. Each rule in the grammar defines one symbol, in the form</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre>
</div>
<p>シンボルは、正規言語を成す開始シンボルであれば最初の文字が大文字で、そうでなければ小文字で書かれる。リテラル文字列は引用符で囲まれる。</p>
<p class="original" lang="en" xml:lang="en">Symbols are written with an initial capital letter if they are the start symbol of a regular language, otherwise with an initial lowercase letter. Literal strings are quoted.</p>
<p>各規則の右辺の表現では、次の表現が一つ以上の文字を持つ文字列をマッチさせる為に使われている。</p>
<p class="original" lang="en" xml:lang="en">Within the expression on the right-hand side of a rule, the following expressions are used to match strings of one or more characters:</p>
<dl>
	<dt class="label"><code>#xN</code></dt>
	<dd>
		<p><code>N</code>は16進整数とする。この表現は、そのISO/IEC 10646での番号(コード点)が<code>N</code>である文字にマッチする。<code>#xN</code>形式の中で頭につくゼロの列は有意ではない。</p>
		<p class="original" lang="en" xml:lang="en">where <code>N</code> is a hexadecimal integer, the expression matches the character whose number (code point) in ISO/IEC 10646 is <code>N</code>. The number of leading zeros in the <code>#xN</code> form is insignificant.</p>
	</dd>
	<dt class="label"><code>[a-zA-Z]</code>, <code>[#xN-#xN]</code></dt>
	<dd>
		<p>示された範囲の中の値を持つすべての<a href="#NT-Char">Char</a>にマッチする。端の値も含まれる。</p>
		<p class="original" lang="en" xml:lang="en">matches any <a href="#NT-Char">Char</a> with a value in the range(s) indicated (inclusive).</p>
	</dd>
	<dt class="label"><code>[abc]</code>, <code>[#xN#xN#xN]</code></dt>
	<dd>
		<p>列挙された文字の中の値を持つすべての<a href="#NT-Char">Char</a>にマッチする。一つの大括弧の組の中で、列挙と範囲が混ざる事もある。</p>
		<p class="original" lang="en" xml:lang="en">matches any <a href="#NT-Char">Char</a> with a value among the characters enumerated. Enumerations and ranges can be mixed in one set of brackets.</p>
	</dd>
	<dt class="label"><code>[^a-z]</code>, <code>[^#xN-#xN]</code></dt>
	<dd>
		<p>示された範囲の<em>外の</em>値を持つすべての<a href="#NT-Char">Char</a>にマッチする。</p>
		<p class="original" lang="en" xml:lang="en">matches any <a href="#NT-Char">Char</a> with a value <em>outside</em> the range indicated.</p>
	</dd>
	<dt class="label"><code>[^abc]</code>, <code>[^#xN#xN#xN]</code></dt>
	<dd>
		<p>与えられた文字の中に無い値を持つすべての<a href="#NT-Char">Char</a>にマッチする。一つの大括弧の中で、許されない値の列挙と範囲が混ざる事もある。</p>
		<p class="original" lang="en" xml:lang="en">matches any <a href="#NT-Char">Char</a> with a value not among the characters given. Enumerations and ranges of forbidden values can be mixed in one set of brackets.</p>
	</dd>
	<dt class="label"><code>"string"</code></dt><dd>
		<p>二重引用符の中で与えられるリテラル文字列に<a title="マッチする" href="#dt-match">マッチ</a>する、リテラル文字列にマッチする。</p>
		<p class="original" lang="en" xml:lang="en">matches a literal string <a title="match" href="#dt-match">matching</a> that given inside the double quotes.</p>
	</dd>
	<dt class="label"><code>'string'</code></dt>
	<dd>
		<p>単引用符の中で与えられるリテラル文字列に<a title="マッチする" href="#dt-match">マッチ</a>する、リテラル文字列にマッチする。</p>
		<p class="original" lang="en" xml:lang="en">matches a literal string <a title="match" href="#dt-match">matching</a> that given inside the single quotes.</p>
	</dd>
</dl>
<p>これらのシンボルは、次に示されるようなより複雑なパターンにマッチする為に、組み合わされる事がある。ここでは、<code>A</code>と<code>B</code>は簡単な表現を表す。</p>
<p class="original" lang="en" xml:lang="en">These symbols may be combined to match more complex patterns as follows, where <code>A</code> and <code>B</code> represent simple expressions:</p>
<dl>
	<dt class="label">( <code>expression</code> )</dt>
	<dd>
		<p><code>expression</code>は一つの単位として扱われる。このリストで説明されるように組み合わされる事がある。</p>
		<p class="original" lang="en" xml:lang="en"><code>expression</code> is treated as a unit and may be combined as described in this list.</p>
	</dd>
	<dt class="label"><code>A?</code></dt>
	<dd>
		<p><code>A</code>にマッチするか、何にもマッチしない。つまり、この<code>A</code>の出現は任意である。</p>
		<p class="original" lang="en" xml:lang="en">matches <code>A</code> or nothing; optional <code>A</code>.</p>
	</dd>
	<dt class="label"><code>A B</code></dt>
	<dd>
		<p><code>B</code>が直後に続く<code>A</code>にマッチする。この演算子は代替よりも高い優先度を持つ。つまり、<code>A B | C D</code>は<code>( A B ) | ( C D )</code>と等価である。</p>
		<p class="original" lang="en" xml:lang="en">matches <code>A</code> followed by <code>B</code>. This operator has higher precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) | (C D)</code>.</p>
	</dd>
	<dt class="label"><code>A | B</code></dt>
	<dd>
		<p><code>A</code>か<code>B</code>にマッチする。</p>
		<p class="original" lang="en" xml:lang="en">matches <code>A</code> or <code>B</code>.</p>
	</dd>
	<dt class="label"><code>A - B</code></dt>
	<dd>
		<p><code>B</code>にマッチせず、かつ<code>A</code>にマッチする文字列にマッチする。</p>
		<p class="original" lang="en" xml:lang="en">matches any string that matches <code>A</code> but does not match <code>B</code>.</p>
	</dd>
	<dt class="label"><code>A+</code></dt>
	<dd>
		<p><code>A</code>の1回以上の出現にマッチする。連接は代替よりも高い優先度を持つ為、<code>A+ | B+</code>は<code>( A+ ) | ( B+ )</code>と等価である。</p>
		<p class="original" lang="en" xml:lang="en">matches one or more occurrences of <code>A</code>. Concatenation has higher precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) | (B+)</code>.</p>
	</dd>
	<dt class="label"><code>A*</code></dt>
	<dd>
		<p><code>A</code>の0回以上の出現にマッチする。連接は代替よりも高い優先度を持つ為、<code>A* | B*</code>は<code>( A* ) | ( B* )</code>と等価である。</p>
		<p class="original" lang="en" xml:lang="en">matches zero or more occurrences of <code>A</code>. Concatenation has higher precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) | (B*)</code>.</p>
	</dd>
</dl>
<p>生成規則で使われる他の記法は次の通り。</p>
<p class="original" lang="en" xml:lang="en">Other notations used in the productions are:</p>
<dl>
	<dt class="label"><code>/* ... */</code></dt>
	<dd>
		<p>コメント。</p>
		<p class="original" lang="en" xml:lang="en">comment.</p>
	</dd>
	<dt class="label"><code>[ wfc: ... ]</code></dt>
	<dd>
		<p>整形式性制約。これは、生成規則に関連付けられた、<a title="整形式性" href="#dt-wellformed">整形式</a>の文書に対する制約を名前で識別する。</p>
		<p class="original" lang="en" xml:lang="en">well-formedness constraint; this identifies by name a constraint on <a title="Well-Formed" href="#dt-wellformed">well-formed</a> documents associated with a production.</p>
	</dd>
	<dt class="label"><code>[ vc: ... ]</code></dt>
	<dd>
		<p>妥当性制約。これは、生成規則に関連付けられた、<a title="妥当性" href="#dt-valid">妥当</a>な文書に対する制約を名前で識別する。</p>
		<p class="original" lang="en" xml:lang="en">validity constraint; this identifies by name a constraint on <a title="Validity" href="#dt-valid">valid</a> documents associated with a production.</p>
	</dd>
</dl>
</div>

<div class="back">
<div class="div1">
<h2><a name="sec-bibliography" id="sec-bibliography"></a>A 参考文献<span class="original" lang="en" xml:lang="en"> References</span></h2>
<div class="div2">
<h3><a name="sec-existing-stds" id="sec-existing-stds"></a>A.1 規範的な参考文献<span class="original" lang="en" xml:lang="en"> Normative References</span></h3>
<dl lang="en" xml:lang="en">
	<dt class="label"><a name="IANA" id="IANA"></a>IANA-CHARSETS</dt>
	<dd>(Internet Assigned Numbers Authority) <a href="http://www.iana.org/assignments/character-sets"><cite>Official Names for Character Sets</cite></a>, ed. Keld Simonsen et al. (See http://www.iana.org/assignments/character-sets.)</dd>
	<dt class="label"><a name="rfc2119" id="rfc2119"></a>IETF RFC 2119</dt>
	<dd>IETF (Internet Engineering Task Force). <a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>RFC 2119: Key words for use in RFCs to Indicate Requirement Levels</cite></a>. Scott Bradner, 1997. (See http://www.ietf.org/rfc/rfc2119.txt.)</dd>
	<dt class="label"><a name="RFC1766" id="RFC1766"></a>IETF RFC 3066</dt>
	<dd>IETF (Internet Engineering Task Force). <a href="http://www.ietf.org/rfc/rfc3066.txt"><cite>RFC 3066: Tags for the Identification of Languages</cite></a>, ed. H. Alvestrand. 2001. (See http://www.ietf.org/rfc/rfc3066.txt.)</dd>
	<dt class="label"><a name="rfc3986" id="rfc3986"></a>IETF RFC 3986</dt>
	<dd>IETF (Internet Engineering Task Force). <a href="http://www.ietf.org/rfc/rfc3986.txt"><cite>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</cite></a>. T. Berners-Lee, R. Fielding, L. Masinter. 2005. (See http://www.ietf.org/rfc/rfc3986.txt.)</dd>
	<dt class="label"><a name="ISO10646" id="ISO10646"></a>ISO/IEC 10646</dt>
	<dd>ISO (International Organization for Standardization). <cite>ISO/IEC 10646-1:2000. Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 1: Architecture and Basic Multilingual Plane</cite> and <cite>ISO/IEC 10646-2:2001. Information technology — Universal Multiple-Octet Coded Character Set (UCS) — Part 2: Supplementary Planes</cite>, as, from time to time, amended, replaced by a new edition or expanded by the addition of new parts. [Geneva]: International Organization for Standardization. (See <a href="http://www.iso.ch">http://www.iso.ch</a> for the latest version.)</dd>
	<dt class="label"><a name="Unicode" id="Unicode"></a>Unicode</dt>
	<dd>The Unicode Consortium. <em>The Unicode Standard, Version 4.0.</em> Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. (See <a href="http://www.unicode.org/unicode/standard/versions"> http://www.unicode.org/unicode/standard/versions</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database).</dd>
	<dt class="label"><a name="XML1.0" id="XML1.0"></a>XML-1.0</dt>
	<dd>W3C. <a href="http://www.w3.org/TR/xml"><cite>Extensible Markup Language (XML) 1.0 (Fourth Edition)</cite></a>. Tim Bray, Jean Paoli, C.M. Sperberg-McQueen, Eve Maler, François Yergeau (editors) (See http://www.w3.org/TR/xml.)</dd>
</dl>
</div>

<div class="div2">
<h3><a name="null" id="null"></a>A.2 その他の参考文献<span class="original" lang="en" xml:lang="en"> Other References</span></h3>
<dl lang="en" xml:lang="en">
	<dt class="label"><a name="Aho" id="Aho"></a>Aho/Ullman</dt>
	<dd>Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. <cite>Compilers: Principles, Techniques, and Tools</cite>. Reading: Addison-Wesley, 1986, rpt. corr. 1988.</dd>
	<dt class="label"><a name="ABK" id="ABK"></a>Brüggemann-Klein</dt>
	<dd>Brüggemann-Klein, Anne. <a href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps"><cite>Formal Models in Document Processing</cite></a>. Habilitationsschrift. Faculty of Mathematics at the University of Freiburg, 1993. (See ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps.)</dd>
	<dt class="label"><a name="ABKDW" id="ABKDW"></a>Brüggemann-Klein and Wood</dt>
	<dd>Brüggemann-Klein, Anne, and Derick Wood. <cite>Deterministic Regular Languages</cite>. Universität Freiburg, Institut für Informatik, Bericht 38, Oktober 1991. Extended abstract in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184. Springer-Verlag, Berlin 1992. Lecture Notes in Computer Science 577. Full version titled <cite>One-Unambiguous Regular Languages</cite> in Information and Computation 140 (2): 229-253, February 1998.</dd>
	<dt class="label"><a name="Charmod" id="Charmod"></a>Charmod</dt>
	<dd>W3C Working Draft. <a href="http://www.w3.org/TR/2003/WD-charmod-20030822/"><cite>Character Model for the World Wide Web 1.0</cite></a>. Martin J. Dürst, François Yergeau, Richard Ishida, Misha Wolf, Tex Texin. (See http://www.w3.org/TR/2003/WD-charmod-20030822/.)</dd>
	<dt class="label"><a name="Clark" id="Clark"></a>Clark</dt>
	<dd>James Clark. <a href="http://www.w3.org/TR/NOTE-sgml-xml-971215"><cite>Comparison of SGML and XML</cite></a>. (See http://www.w3.org/TR/NOTE-sgml-xml-971215.)</dd>
	<dt class="label"><a name="IANA-LANGCODES" id="IANA-LANGCODES"></a>IANA-LANGCODES</dt>
	<dd>(Internet Assigned Numbers Authority) <a href="http://www.iana.org/assignments/language-tags"><cite>Registry of Language Tags</cite></a>, ed. Keld Simonsen et al. (See http://www.iana.org/assignments/language-tags.)</dd>
	<dt class="label"><a name="RFC2141" id="RFC2141"></a>IETF RFC 2141</dt>
	<dd>IETF (Internet Engineering Task Force). <a href="http://www.ietf.org/rfc/rfc2141.txt"><cite>RFC 2141: URN Syntax</cite></a>, ed. R. Moats. 1997. (See http://www.ietf.org/rfc/rfc2141.txt.)</dd>
	<dt class="label"><a name="rfc2376" id="rfc2376"></a>IETF RFC 3023</dt>
	<dd>IETF (Internet Engineering Task Force). <a href="http://www.ietf.org/rfc/rfc3023.txt"><cite>RFC 3023: XML Media Types</cite></a>. eds. M. Murata, S. St.Laurent, D. Kohn. 2001. (See http://www.ietf.org/rfc/rfc3023.txt.)</dd>
	<dt class="label"><a name="rfc2781" id="rfc2781"></a>IETF RFC 2781</dt>
	<dd>IETF (Internet Engineering Task Force). <a href="http://www.ietf.org/rfc/rfc2781.txt"><cite>RFC 2781: UTF-16, an encoding of ISO 10646</cite></a>, ed. P. Hoffman, F. Yergeau. 2000. (See http://www.ietf.org/rfc/rfc2781.txt.)</dd>
	<dt class="label"><a name="ISO639" id="ISO639"></a>ISO 639</dt>
	<dd>(International Organization for Standardization). <cite>ISO 639:1988 (E). Code for the representation of names of languages.</cite> [Geneva]: International Organization for Standardization, 1988.</dd>
	<dt class="label"><a name="ISO3166" id="ISO3166"></a>ISO 3166</dt>
	<dd>(International Organization for Standardization). <cite>ISO 3166-1:1997 (E). Codes for the representation of names of countries and their subdivisions — Part 1: Country codes</cite> [Geneva]: International Organization for Standardization, 1997.</dd>
	<dt class="label"><a name="ISO8879" id="ISO8879"></a>ISO 8879</dt>
	<dd>ISO (International Organization for Standardization). <cite>ISO 8879:1986(E). Information processing — Text and Office Systems — Standard Generalized Markup Language (SGML).</cite> First edition — 1986-10-15. [Geneva]: International Organization for Standardization, 1986.</dd>
	<dt class="label"><a name="ISO10744" id="ISO10744"></a>ISO/IEC 10744</dt>
	<dd>ISO (International Organization for Standardization). <cite>ISO/IEC 10744-1992 (E). Information technology — Hypermedia/Time-based Structuring Language (HyTime).</cite> [Geneva]: International Organization for Standardization, 1992. <em>Extended Facilities Annexe.</em> [Geneva]: International Organization for Standardization, 1996.</dd>
	<dt class="label"><a name="websgml" id="websgml"></a>WEBSGML</dt>
	<dd>ISO (International Organization for Standardization). <a href="http://www.sgmlsource.com/8879/n0029.htm"><cite>ISO 8879:1986 TC2. Information technology — Document Description and Processing Languages</cite></a>. [Geneva]: International Organization for Standardization, 1998. (See http://www.sgmlsource.com/8879/n0029.htm.)</dd>
	<dt class="label"><a name="xml-names" id="xml-names"></a>XML Names</dt>
	<dd>Tim Bray, Dave Hollander, and Andrew Layman, editors. <a href="http://www.w3.org/TR/REC-xml-names/"><cite>Namespaces in XML</cite></a>. Textuality, Hewlett-Packard, and Microsoft. World Wide Web Consortium, 1999. (See http://www.w3.org/TR/REC-xml-names/.)</dd>
</dl>
</div>
</div>

<div class="div1">
<h2><a name="sec-CharNorm" id="sec-CharNorm"></a>B 文字正規化の為の定義<span class="original" lang="en" xml:lang="en"> Definitions for Character Normalization</span></h2>
<p>この附録では、文字正規化に必要な定義を行う。更なる背景情報や例などについては、<a href="#Charmod">[Charmod]</a>を参照してほしい。</p>
<p class="original" lang="en" xml:lang="en">This appendix contains the necessary definitions for character normalization. For additional background information and examples, see <a href="#Charmod">[Charmod]</a>.</p>
<p>[<a name="dt-Uni-encform" id="dt-Uni-encform" title="Unicodeエンコーディング形式">定義</a>: テキストは、UTF-8、UTF-16、あるいはUTF-32で表されている時、<b>Unicodeエンコーディング形式</b>であると言われる。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: Text is said to be in a <b>Unicode encoding form</b> if it is encoded in UTF-8, UTF-16 or UTF-32.]</p>
<p>[<a name="dt-legacyenc" id="dt-legacyenc" title="レガシエンコーディング">定義</a>: <b>レガシエンコーディング</b>は、Unicodeに基づかないあらゆる文字エンコーディングを意味する。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Legacy encoding</b> is taken to mean any character encoding not based on Unicode.]</p>
<p>[<a name="dt-normtransc" id="dt-normtransc" title="正規化するトランスコーダ">定義</a>: <b>正規化するトランスコーダ</b>は、<a title="レガシエンコーディング" href="#dt-legacyenc">レガシエンコーディング</a>から<a title="Unicodeエンコーディング形式" href="#dt-Uni-encform">Unicodeエンコーディング形式</a>に変換し、その結果がUnicode正規形C(Unicode Normalization Form C、UAX #15 <a href="#Unicode">[Unicode]</a>を参照)であるようにするトランスコーダ(コード変換器)である。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A <b>normalizing transcoder</b> is a transcoder that converts from a <a title="legacy encoding" href="#dt-legacyenc">legacy encoding</a> to a <a title="Unicode encoding form" href="#dt-Uni-encform">Unicode encoding form</a> and ensures that the result is in Unicode Normalization Form C (see UAX #15 <a href="#Unicode">[Unicode]</a>).]</p>
<p>[<a name="dt-charesc" id="dt-charesc" title="文字エスケープ">定義</a>: <b>文字エスケープ</b>は、次の内の一つ以上の事を可能とする、マークアップ言語やプログラミング言語で定義される構文上の仕組みである。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A <b>character escape</b> is a syntactic device defined in a markup or programming language that allows one or more of:]</p>
<ol class="enumar">
	<li>
		<p>構文的に有意な文字を、その言語における構文上の意味を無くして表現する事。</p>
		<p class="original" lang="en" xml:lang="en">expressing syntax-significant characters while disregarding their significance in the syntax of the language, or</p>
	</li>
	<li>
		<p>その言語のインスタンスで選ばれた文字エンコーディングでは表せない文字を表現する事。</p>
		<p class="original" lang="en" xml:lang="en">expressing characters not representable in the character encoding chosen for an instance of the language, or</p>
	</li>
	<li>
		<p>概して、対応する文字コードを使わずに文字を表現する事。</p>
		<p class="original" lang="en" xml:lang="en">expressing characters in general, without use of the corresponding character codes.</p>
	</li>
</ol>
<p>[<a name="dt-certified" id="dt-certified" title="保証される">定義</a>: <b>保証</b>されたテキストとは、次の条件の内少なくとも一つを満たすテキストである。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: <b>Certified</b> text is text which satisfies at least one of the following conditions:]</p>
<ol class="enumar">
	<li>
		<p>そのテキストが正規形である事を検査して確認が取れている。</p>
		<p class="original" lang="en" xml:lang="en">it has been confirmed through inspection that the text is in normalized form</p>
	</li>
	<li>
		<p>入力元のテキスト処理コンポーネントが何であるかが知られており、かつ、そのコンポーネントは正規化されたテキストしか生成しないという事が知られている。</p>
		<p class="original" lang="en" xml:lang="en">the source text-processing component is identified and is known to produce only normalized text.</p>
	</li>
</ol>
<p>[<a name="dt-uninorm" id="dt-uninorm" title="Unicode正規化される">定義</a>: この仕様書では、テキストが<a title="Unicodeエンコーディング形式" href="#dt-Uni-encform">Unicodeエンコーディング形式</a>で表されていて、(Unicode Standard Annex #15のあるバージョンで説明されるように)Unicode正規形Cである場合、そのテキストは<b>Unicode正規化</b>されていると言う。ここで、Unicode Standard Annex #15 "Unicode Normalization Forms" <a href="#Unicode">[Unicode]</a>のあるバージョンとは、そのテキストで実際に使われているすべての文字を含むUnicode Standardの最も古いバージョンと同じか、それよりも新しいバージョンの事である。但し、バージョン3.2より古いバージョンのUnicode Standardは含まない。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: Text is, for the purposes of this specification, <b>Unicode-normalized</b> if it is in a <a title="Unicode encoding form" href="#dt-Uni-encform">Unicode encoding form</a> and is in Unicode Normalization Form C, according to a version of Unicode Standard Annex #15: Unicode Normalization Forms <a href="#Unicode">[Unicode]</a> at least as recent as the oldest version of the Unicode Standard that contains all the characters actually present in the text, but no earlier than version 3.2.]</p>
<p>[<a name="dt-inclnorm" id="dt-inclnorm" title="インクルードに関して正規化される">定義</a>: テキストは、次の条件の内何れかを満たす時、<b>インクルードに関して正規化</b>されていると言う。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: Text is <b>include-normalized</b> if:]</p>
<ol class="enumar">
	<li>
		<p><a title="Unicode正規化される" href="#dt-uninorm">Unicode正規化</a>されていて、かつ、展開した時に、最早そのテキストが<a title="Unicode正規化される" href="#dt-uninorm">Unicode正規化</a>されていなくなってしまうような<a title="文字エスケープ" href="#dt-charesc">文字エスケープ</a>や<a title="インクルードする" href="#dt-include">インクルード</a>を持っていない。</p>
		<p class="original" lang="en" xml:lang="en">the text is <a title="Unicode-normalized" href="#dt-uninorm">Unicode-normalized</a> and does not contain any <a title="character escape" href="#dt-charesc">character escapes</a> or <a title="Include" href="#dt-include">includes</a> whose expansion would cause the text to become no longer <a title="Unicode-normalized" href="#dt-uninorm">Unicode-normalized</a>; or</p>
	</li>
	<li>
		<p><a title="レガシエンコーディング" href="#dt-legacyenc">レガシエンコーディング</a>で表されていて、かつ、そのテキストが<a title="正規化するトランスコーダ" href="#dt-normtransc">正規化するトランスコーダ</a>を使って<a title="Unicodeエンコーディング形式" href="#dt-Uni-encform">Unicodeエンコーディング形式</a>にトランスコードされた場合、上記の1を満たす。</p>
		<p class="original" lang="en" xml:lang="en">the text is in a <a title="legacy encoding" href="#dt-legacyenc">legacy encoding</a> and, if it were transcoded to a <a title="Unicode encoding form" href="#dt-Uni-encform">Unicode encoding form</a> by a <a title="normalizing transcoder" href="#dt-normtransc">normalizing transcoder</a>, the resulting text would satisfy clause 1 above.</p>
	</li>
</ol>
<p>[<a name="dt-compchar" id="dt-compchar" title="合成化文字">定義</a>: <b>合成化文字</b>は、次の何れかあるいは両方に当てはまる文字である。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: A <b>composing character</b> is a character that is one or both of the following:]</p>
<ol class="enumar">
	<li>
		<p>特定の主要合成文字の極限分解マッピングにおいて、二番目の文字(主要合成文字はUAX #15 <a href="#Unicode">[Unicode]</a>のD3で定義される)。</p>
		<p class="original" lang="en" xml:lang="en">the second character in the canonical decomposition mapping of some primary composite (as defined in D3 of UAX #15 <a href="#Unicode">[Unicode]</a>), or</p>
	</li>
	<li>
		<p>非ゼロの極限結合クラスを持つ文字(極限結合クラスはUnicode <a href="#Unicode">[Unicode]</a>で定義される)。</p>
		<p class="original" lang="en" xml:lang="en">of non-zero canonical combining class (as defined in Unicode <a href="#Unicode">[Unicode]</a>).</p>
	</li>
</ol>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>合成化文字(Composing Character)は、ここで定義されている事から判るように、Unicode用語ではありません。合成化文字は、Unicode用語のComposite Character(日本語ではしばしば合成文字と訳される)とは<em>全くの別物</em>なので注意して下さい。Composing CharacterはむしろUnicode用語のCombining Character(しばしば結合文字と訳される)に近いものです。また、主要合成文字(Primary Composite)、極限分解マッピング(Canonical Decomposition Mapping)、極限結合クラス(Canonical Combining Class)はUnicode用語です。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<p>[<a name="dt-fullnorm" id="dt-fullnorm" title="完全に正規化される">定義</a>: テキストは次の条件の内何れかを満たす時、<b>完全に正規化</b>されていると言う。]</p>
<p class="original" lang="en" xml:lang="en">[Definition: Text is <b>fully-normalized</b> if:]</p>
<ol class="enumar">
	<li>
		<p><a title="Unicodeエンコーディング形式" href="#dt-Uni-encform">Unicodeエンコーディング形式</a>で表され、かつ<a title="インクルードに関して正規化される" href="#dt-inclnorm">インクルードに関して正規化</a>されていて、その上そのテキストを形成する<a title="" href="#dt-relconst">関連する構成子</a>が、何れも<a title="合成化文字" href="#dt-compchar">合成化文字</a>や<a title="合成化文字" href="#dt-compchar">合成化文字</a>を表す文字エスケープから始まらない。</p>
		<p class="original" lang="en" xml:lang="en">the text is in a <a title="Unicode encoding form" href="#dt-Uni-encform">Unicode encoding form</a>, is <a title="include-normalized" href="#dt-inclnorm">include-normalized</a> and none of the <a title="" href="#dt-relconst">relevant constructs</a> comprising the text begin with a <a title="composing character" href="#dt-compchar">composing character</a> or a character escape representing a <a title="composing character" href="#dt-compchar">composing character</a>; or</p>
	</li>
	<li>
		<p><a title="レガシエンコーディング" href="#dt-legacyenc">レガシエンコーディング</a>で表されていて、かつ、そのテキストが<a title="正規化するトランスコーダ" href="#dt-normtransc">正規化するトランスコーダ</a>を使って<a title="Unicodeエンコーディング形式" href="#dt-Uni-encform">Unicodeエンコーディング形式</a>にトランスコードされた場合、上記の1を満たす。</p>
		<p class="original" lang="en" xml:lang="en">the text is in a <a title="legacy encoding" href="#dt-legacyenc">legacy encoding</a> and, if it were transcoded to a <a title="Unicode encoding form" href="#dt-Uni-encform">Unicode encoding form</a> by a <a title="normalizing transcoder" href="#dt-normtransc">normalizing transcoder</a>, the resulting text would satisfy clause 1 above.</p>
	</li>
</ol>
</div>

<div class="div1">
<h2><a name="sec-entexpand" id="sec-entexpand"></a>C 実体参照と文字参照の展開(非規範的)<span class="original" lang="en" xml:lang="en"> Expansion of Entity and Character References (Non-Normative)</span></h2>
<p>この附録では、<a href="#entproc"><b>4.4 XMLプロセッサによる実体と参照の扱い<span class="original" lang="en" xml:lang="en"> XML Processor Treatment of Entities and References</span></b></a>で指定される、実体参照や文字参照の認識と展開の一連の流れを例で解説する。</p>
<p class="original" lang="en" xml:lang="en">This appendix contains some examples illustrating the sequence of entity- and character-reference recognition and expansion, as specified in <a href="#entproc"><b>4.4 XML Processor Treatment of Entities and References</b></a>.</p>
<p>DTDが次の宣言を持っていたとする。</p>
<p class="original" lang="en" xml:lang="en">If the DTD contains the declaration</p>
<div class="exampleInner">
<pre>
&lt;!ENTITY example "&lt;p&gt;An ampersand (&amp;#38;#38;) may be escaped
numerically (&amp;#38;#38;#38;) or with a general entity
(&amp;amp;amp;).&lt;/p&gt;" &gt;
</pre>
</div>
<p>XMLプロセッサは、この実体宣言を解析する時、文字参照を認識し、実体"<code>example</code>"の値として次の文字列を格納する前に、文字参照を解決するだろう。</p>
<p class="original" lang="en" xml:lang="en">then the XML processor will recognize the character references when it parses the entity declaration, and resolve them before storing the following string as the value of the entity "<code>example</code>":</p>
<div class="exampleInner">
<pre>
&lt;p&gt;An ampersand (&amp;#38;) may be escaped
numerically (&amp;#38;#38;) or with a general entity
(&amp;amp;amp;).&lt;/p&gt;
</pre>
</div>
<p>文書中に現れた参照"<code>&amp;example;</code>"は、このテキストを再び解析させる事となろう。その時、この<code>p</code>要素の開始タグと終了タグが認識され、三つの参照が認識されて展開され、次の内容を持つ<code>p</code>要素となるだろう(次の内容は、区切り子やマークアップを含まない、すべてのデータである)。</p>
<p class="original" lang="en" xml:lang="en">A reference in the document to "<code>&amp;example;</code>" will cause the text to be reparsed, at which time the start- and end-tags of the <code>p</code> element will be recognized and the three references will be recognized and expanded, resulting in a <code>p</code> element with the following content (all data, no delimiters or markup):</p>
<div class="exampleInner">
<pre>
An ampersand (&amp;) may be escaped
numerically (&amp;#38;) or with a general entity
(&amp;amp;).
</pre>
</div>
<p>更に複雑な例を用いれば、規則とその効果を完全に説明できるだろう。次の例では、行番号は単に後で参照する為に付けられたものである。</p>
<p class="original" lang="en" xml:lang="en">A more complex example will illustrate the rules and their effects fully. In the following example, the line numbers are solely for reference.</p>
<div class="exampleInner">
<pre>
1 &lt;?xml version='1.1'?&gt;
2 &lt;!DOCTYPE test [
3 &lt;!ELEMENT test (#PCDATA) &gt;
4 &lt;!ENTITY % xx '&amp;#37;zz;'&gt;
5 &lt;!ENTITY % zz '&amp;#60;!ENTITY tricky "error-prone" &gt;' &gt;
6 %xx;
7 ]&gt;
8 &lt;test&gt;This sample shows a &amp;tricky; method.&lt;/test&gt;
</pre>
</div>
<p>これは、次の結果を生む。</p>
<p class="original" lang="en" xml:lang="en">This produces the following:</p>
<ul>
	<li>
		<p>4行目で、文字37への参照は即座に展開され、パラメータ実体"<code>xx</code>"は、値"<code>%zz;</code>"を持つものとしてシンボルテーブルに格納される。置換テキストは再スキャンされないので、パラメータ実体"<code>zz</code>"への参照は認識されない(もし認識されてしまったら、"<code>zz</code>"はまだ宣言されていないのでエラーになるだろう)。</p>
		<p class="original" lang="en" xml:lang="en">in line 4, the reference to character 37 is expanded immediately, and the parameter entity "<code>xx</code>" is stored in the symbol table with the value "<code>%zz;</code>". Since the replacement text is not rescanned, the reference to parameter entity "<code>zz</code>" is not recognized. (And it would be an error if it were, since "<code>zz</code>" is not yet declared.)</p>
	</li>
	<li>
		<p>5行目で、文字参照"<code>&amp;#60;</code>"は即座に展開され、パラメータ実体"<code>zz</code>"は、置換テキスト"<code>&lt;!ENTITY tricky "error-prone"&gt;</code>"を持つものとして格納される。これは整形式の実体宣言である。</p>
		<p class="original" lang="en" xml:lang="en">in line 5, the character reference "<code>&amp;#60;</code>" is expanded immediately and the parameter entity "<code>zz</code>" is stored with the replacement text "<code>&lt;!ENTITY tricky "error-prone"&gt;</code>", which is a well-formed entity declaration.</p>
	</li>
	<li>
		<p>6行目で、"<code>xx</code>"への参照が認識され、"<code>xx</code>"の置換テキスト(即ち"<code>%zz;</code>")が解析される。今回は"<code>zz</code>"への参照が認識され、その置換テキスト("<code>&lt;!ENTITY tricky "error-prone"&gt;</code>")が解析される。よって、置換テキスト"<code>error-prone</code>"を持って、一般実体"<code>tricky</code>"が宣言される事となる。</p>
		<p class="original" lang="en" xml:lang="en">in line 6, the reference to "<code>xx</code>" is recognized, and the replacement text of "<code>xx</code>" (namely "<code>%zz;</code>") is parsed. The reference to "<code>zz</code>" is recognized in its turn, and its replacement text ("<code>&lt;!ENTITY tricky "error-prone"&gt;</code>") is parsed. The general entity "<code>tricky</code>" has now been declared, with the replacement text "<code>error-prone</code>".</p>
	</li>
	<li>
		<p>8行目で、一般実体"<code>tricky</code>"への参照が認識され、展開される。よって、この<code>test</code>要素の完全な内容は、それ自体が説明的な(文法的でない、ただの)文字列、<em>This sample shows a error-prone method.(この例はエラーになりやすい方法を示す。)となる。</em></p>
		<p class="original" lang="en" xml:lang="en">in line 8, the reference to the general entity "<code>tricky</code>" is recognized, and it is expanded, so the full content of the <code>test</code> element is the self-describing (and ungrammatical) string <em>This sample shows a error-prone method.</em></p>
	</li>
</ul>
</div>

<div class="div1">
<h2><a name="determinism" id="determinism"></a>D 決定的内容モデル(非規範的)<span class="original" lang="en" xml:lang="en"> Deterministic Content Models (Non-Normative)</span></h2>
<p><a href="#sec-element-content"><b>3.2.1 要素内容<span class="original" lang="en" xml:lang="en"> Element Content</span></b></a>で触れたように、要素型宣言の内容モデルは決定的である事が求められる。この要求は、SGMLとの<a title="互換性の為に" href="#dt-compat">互換性の為に</a>導入されている(SGMLでは、決定的内容モデルを「明白な」「曖昧でない」(unambiguous)ものと呼んでいる)。SGMLシステムを使って組み立てられたXMLプロセッサは、非決定的内容モデルをエラーとするかも知れない。</p>
<p class="original" lang="en" xml:lang="en">As noted in <a href="#sec-element-content"><b>3.2.1 Element Content</b></a>, it is required that content models in element type declarations be deterministic. This requirement is <a title="For Compatibility" href="#dt-compat">for compatibility</a> with SGML (which calls deterministic content models "unambiguous"); XML processors built using SGML systems may flag non-deterministic content models as errors.</p>
<p>例えば、内容モデル<code>((b, c) | (b, d))</code>は非決定的である。何故なら、最初に<code>b</code>を与えられても、内容モデルのどちらの<code>b</code>にマッチするものか、<code>b</code>に続く要素がどちらかを調べない事には、XMLプロセッサは知る事ができないからである。この場合、<code>b</code>への二つの参照は一つの参照にまとめる事ができ、<code>(b, (c | d))</code>というモデルとなる。これで、最初の<code>b</code>は、内容モデルに一つしかない名前にマッチするようになる事は明らかである。プロセッサは、次に何が続くかを調べる必要は無い。<code>c</code>も<code>d</code>も受け入れられるだろう。</p>
<p class="original" lang="en" xml:lang="en">For example, the content model <code>((b, c) | (b, d))</code> is non-deterministic, because given an initial <code>b</code> the XML processor cannot know which <code>b</code> in the model is being matched without looking ahead to see which element follows the <code>b</code>. In this case, the two references to <code>b</code> can be collapsed into a single reference, making the model read <code>(b, (c | d))</code>. An initial <code>b</code> now clearly matches only a single name in the content model. The processor doesn't need to look ahead to see what follows; either <code>c</code> or <code>d</code> would be accepted.</p>
<p>もっと形式的に言えば、標準アルゴリズム、例えばAho、Sethi、Ullmanによって書かれた<cite>Compilers: Principles, Techniques, and Tools</cite> <a href="#Aho">[Aho/Ullman]</a>のセクション3.9のアルゴリズム3.5を使って、内容モデルから有限状態オートマトンが構築され得る。そのようなアルゴリズムでは大概の場合、正規表現のそれぞれの位置(つまり、正規表現の為の構文木のそれぞれの末端ノード)の為にフォローセットが構築される。ここで、一つより多くの後続の位置が同じ要素型の名前を持っているようなフォローセットを持つ位置があるかも知れない。もしそのようなフォローセットを持っている位置があった場合、その内容モデルの存在はエラーとなる。これはエラーとして報告されるかも知れない。</p>
<p class="original" lang="en" xml:lang="en">More formally: a finite state automaton may be constructed from the content model using the standard algorithms, e.g. algorithm 3.5 in section 3.9 of Aho, Sethi, and Ullman <a href="#Aho">[Aho/Ullman]</a>. In many such algorithms, a follow set is constructed for each position in the regular expression (i.e., each leaf node in the syntax tree for the regular expression); if any position has a follow set in which more than one following position is labeled with the same element type name, then the content model is in error and may be reported as an error.</p>
<p>すべてではないが、多くの非決定的内容モデルを自動的に等価な決定的モデルにまとめる事ができるアルゴリズムが存在する。Brüggemann-Kleinの<cite>Formal Models in Document Processing</cite> (1991) <a href="#ABK">[Brüggemann-Klein]</a>を参照してほしい。</p>
<p class="original" lang="en" xml:lang="en">Algorithms exist which allow many but not all non-deterministic content models to be reduced automatically to equivalent deterministic models; see Brüggemann-Klein 1991 <a href="#ABK">[Brüggemann-Klein]</a>.</p>
</div>

<div class="div1">
<h2><a name="sec-guessing" id="sec-guessing"></a>E 文字エンコーディングの自動検知(非規範的)<span class="original" lang="en" xml:lang="en"> Autodetection of Character Encodings (Non-Normative)</span></h2>
<p>XMLのエンコーディング宣言は、それぞれの実体の内部ラベルとして機能し、どの文字エンコーディングが使われているかを示す。しかし、XMLプロセッサが内部ラベルを読む事ができるようになる前に、XMLプロセッサはどの文字エンコーディングが使われているか──内部ラベルが示そうとしているものはどれかを知らなければならない事は明らかである。一般的には、これを知る事はまず無理である。しかし、XMLでは必ずしも無理な話ではない。それはXMLが一般的な場合を二つの方法で制限しているからである。つまり、実装はそれぞれ有限の数の文字エンコーディングしかサポートしない事が想定されており、XMLエンコーディング宣言は、普通の場合でもそれぞれの実体で使われている文字エンコーディングを自動検知する事を可能にする為に位置と内容が制限されている。また、多くの場合はXMLのデータストリームそのものに加えて、他の情報源も利用可能である。XML実体が付随する(外部の)情報と共にプロセッサに渡されるか否かによって、二つの場合に分ける事ができるだろう。まず外部情報が渡されない場合を考える。</p>
<p class="original" lang="en" xml:lang="en">The XML encoding declaration functions as an internal label on each entity, indicating which character encoding is in use. Before an XML processor can read the internal label, however, it apparently has to know what character encoding is in use — which is what the internal label is trying to indicate. In the general case, this is a hopeless situation. It is not entirely hopeless in XML, however, because XML limits the general case in two ways: each implementation is assumed to support only a finite set of character encodings, and the XML encoding declaration is restricted in position and content in order to make it feasible to autodetect the character encoding in use in each entity in normal cases. Also, in many cases other sources of information are available in addition to the XML data stream itself. Two cases may be distinguished, depending on whether the XML entity is presented to the processor without, or with, any accompanying (external) information. We consider the first case first.</p>

<div class="div2">
<h3><a name="sec-guessing-no-ext-info" id="sec-guessing-no-ext-info"></a>E.1 外部エンコーディング情報を使わない検知<span class="original" lang="en" xml:lang="en"> Detection Without External Encoding Information</span></h3>
<p>外部エンコーディング情報を持たず、UTF-8でもUTF-16でもないエンコーディングで表されているXML実体は、XMLエンコーディング宣言から始まらなければならないので、そのような実体では最初の文字列は'<code>&lt;?xml</code>'しかあり得ない。よって、仕様に適合するプロセッサはすべて、入力の2から4オクテットを読み取る事で、次のどのケースが適用されるかを自動検知する事ができる。このリストを読むに当たって、UCS-4では、'&lt;'が"<code>#x0000003C</code>"で、'?'が"<code>#x0000003F</code>"、そしてUTF-16のデータストリームに必須とされるバイトオーダーマークは"<code>#xFEFF</code>"である事を知っておくと役に立つかも知れない。<var>##</var>という記法は、任意のバイト値を表す為に使われる。但し、二つの連続する<var>##</var>が両方とも00になる事は無い。</p>
<p class="original" lang="en" xml:lang="en">Because each XML entity not accompanied by external encoding information and not in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration, in which the first characters must be '<code>&lt;?xml</code>', any conforming processor can detect, after two to four octets of input, which of the following cases apply. In reading this list, it may help to know that in UCS-4, '&lt;' is "<code>#x0000003C</code>" and '?' is "<code>#x0000003F</code>", and the Byte Order Mark required of UTF-16 data streams is "<code>#xFEFF</code>". The notation <var>##</var> is used to denote any byte value except that two consecutive <var>##</var>s cannot be both 00.</p>
<p>バイトオーダーマークがある場合は次の通り。</p>
<p class="original" lang="en" xml:lang="en">With a Byte Order Mark:</p>
<table border="1" frame="border" summary="エンコーディング検知の要約">
<tbody>
	<tr>
		<td><code>00 00 FE FF</code></td>
		<td>UCS-4、ビッグエンディアン(1234の順)</td>
	</tr>
	<tr>
		<td><code>FF FE 00 00</code></td>
		<td>UCS-4、リトルエンディアン(4321の順)</td>
	</tr>
	<tr>
		<td><code>00 00 FF FE</code></td>
		<td>UCS-4、一般的でないオクテットの並び(2143)</td>
	</tr>
	<tr>
		<td><code>FE FF 00 00</code></td>
		<td>UCS-4、一般的でないオクテットの並び(3412)</td>
	</tr>
	<tr>
		<td><code>FE FF ## ##</code></td>
		<td>UTF-16、ビッグエンディアン</td>
	</tr>
	<tr>
		<td><code>FF FE ## ##</code></td>
		<td>UTF-16、リトルエンディアン</td>
	</tr>
	<tr>
		<td><code>EF BB BF</code></td>
		<td>UTF-8</td>
	</tr>
</tbody>
</table>
<table class="original" lang="en" xml:lang="en" border="1" frame="border" summary="Encoding detection summary">
<tbody>
	<tr>
		<td><code>00 00 FE FF</code></td>
		<td>UCS-4, big-endian machine (1234 order)</td>
	</tr>
	<tr>
		<td><code>FF FE 00 00</code></td>
		<td>UCS-4, little-endian machine (4321 order)</td>
	</tr>
	<tr>
		<td><code>00 00 FF FE</code></td>
		<td>UCS-4, unusual octet order (2143)</td>
	</tr>
	<tr>
		<td><code>FE FF 00 00</code></td>
		<td>UCS-4, unusual octet order (3412)</td>
	</tr>
	<tr>
		<td><code>FE FF ## ##</code></td>
		<td>UTF-16, big-endian</td>
	</tr>
	<tr>
		<td><code>FF FE ## ##</code></td>
		<td>UTF-16, little-endian</td>
	</tr>
	<tr>
		<td><code>EF BB BF</code></td>
		<td>UTF-8</td>
	</tr>
</tbody>
</table>
<p>バイトオーダーマークが無い場合は次の通り。</p>
<p class="original" lang="en" xml:lang="en">Without a Byte Order Mark:</p>
<table border="1" frame="border" summary="エンコーディング検知の要約">
<tbody>
	<tr>
		<td><code>00 00 00 3C</code></td>
		<td rowspan="4">UCS-4か、ASCII文字をASCII値でエンコードし32ビットをコード単位とする他のエンコーディング。順に、ビッグエンディアン(1234)、リトルエンディアン(4321)、そして二つの一般的でないオクテットの並び(2143と3412)である。この場合、エンコーディングがUCS-4なのか、(実装がサポートする)他の32ビットエンコーディングなのかを決める為、エンコーディング宣言を読み取らなければならない。</td>
	</tr>
	<tr>
		<td><code>3C 00 00 00</code></td>
	</tr>
	<tr>
		<td><code>00 00 3C 00</code></td>
	</tr>
	<tr>
		<td><code>00 3C 00 00</code></td>
	</tr>
	<tr>
		<td><code>00 3C 00 3F</code></td>
		<td>UTF-16BEか、ビッグエンディアンISO-10646-UCS-2か、ASCII文字をASCII値でエンコードしビッグエンディアンの並びの16ビットコード単位を持つ他のエンコーディング(どのエンコーディングなのかを決める為、エンコーディング宣言を読み取らなければならない)。</td>
	</tr>
	<tr>
		<td><code>3C 00 3F 00</code></td>
		<td>UTF-16LEか、リトルエンディアンISO-10646-UCS-2か、ASCII文字をASCII値でエンコードしリトルエンディアンの並びの16ビットコード単位を持つ他のエンコーディング(どのエンコーディングなのかを決める為、エンコーディング宣言を読み取らなければならない)。</td>
	</tr>
	<tr>
		<td><code>3C 3F 78 6D</code></td>
		<td>UTF-8か、ISO 646、ASCIIやISO 8859の幾つかのパート、Shift-JIS、EUC──それらでなければ、7ビット幅か8ビット幅、または混合幅を持ち、ASCIIの文字がその位置、幅、値を保つようにする他のエンコーディング。これらのどれが適用されるのかを検知する為にエンコーディング宣言を読み取らなければならないが、これらのエンコーディングはすべて関係するASCII文字に対して同じビットパターンを使うので、エンコーディング宣言自体は信頼を持って読み取る事ができる。</td>
	</tr>
	<tr>
		<td><code>4C 6F A7 94</code></td>
		<td>EBCDIC(の幾つかの種類。どのコードページが使われているかを知る為にエンコーディング宣言を読み取らなければならない)。</td>
	</tr>
	<tr>
		<td>その他</td>
		<td>エンコーディング宣言を持たないUTF-8、あるいは、データストリームが間違ってラベルされている(必須のエンコーディング宣言を欠いている)か、壊れているか、一部しかないか、何らかのラッパに包含されているかである。</td>
	</tr>
</tbody>
</table>
<table class="original" lang="en" xml:lang="en" border="1" frame="border" summary="Encoding detection summary">
<tbody>
	<tr>
		<td><code>00 00 00 3C</code></td>
		<td rowspan="4">UCS-4 or other encoding with a 32-bit code unit and ASCII characters encoded as ASCII values, in respectively big-endian (1234), little-endian (4321) and two unusual byte orders (2143 and 3412). The encoding declaration must be read to determine which of UCS-4 or other supported 32-bit encodings applies.</td>
	</tr>
	<tr>
		<td><code>3C 00 00 00</code></td>
	</tr>
	<tr>
		<td><code>00 00 3C 00</code></td>
	</tr>
	<tr>
		<td><code>00 3C 00 00</code></td>
	</tr>
	<tr>
		<td><code>00 3C 00 3F</code></td>
		<td>UTF-16BE or big-endian ISO-10646-UCS-2 or other encoding with a 16-bit code unit in big-endian order and ASCII characters encoded as ASCII values (the encoding declaration must be read to determine which)</td>
	</tr>
	<tr>
		<td><code>3C 00 3F 00</code></td>
		<td>UTF-16LE or little-endian ISO-10646-UCS-2 or other encoding with a 16-bit code unit in little-endian order and ASCII characters encoded as ASCII values (the encoding declaration must be read to determine which)</td>
	</tr>
	<tr>
		<td><code>3C 3F 78 6D</code></td>
		<td>UTF-8, ISO 646, ASCII, some part of ISO 8859, Shift-JIS, EUC, or any other 7-bit, 8-bit, or mixed-width encoding which ensures that the characters of ASCII have their normal positions, width, and values; the actual encoding declaration must be read to detect which of these applies, but since all of these encodings use the same bit patterns for the relevant ASCII characters, the encoding declaration itself may be read reliably</td>
	</tr>
	<tr>
		<td><code>4C 6F A7 94</code></td>
		<td>EBCDIC (in some flavor; the full encoding declaration must be read to tell which code page is in use)</td>
	</tr>
	<tr>
		<td>Other</td>
		<td>UTF-8 without an encoding declaration, or else the data stream is mislabeled (lacking a required encoding declaration), corrupt, fragmentary, or enclosed in a wrapper of some kind</td>
	</tr>
</tbody>
</table>
<div class="note">
	<p class="prefix"><b>メモ<span class="original" lang="en" xml:lang="en"> Note:</span></b></p>
	<p>上に挙げられている場合の内、エンコーディングを決める為にエンコーディング宣言を読み取る事を必要としない場合でも、セクション4.3.3で説明されているように、エンコーディング宣言が存在するならばその宣言は読み取られなければならず、エンコーディング名は実際に実体で使われているエンコーディングとマッチしている事を検査されなければならない。また、現在はエンコーディング方法を決める為にエンコーディング宣言を使う事が必要とされない場合もあるが、将来的にはそれらの場合でもエンコーディング宣言が必要になるような新しい文字エンコーディングが作られる事もあり得る。</p>
	<p class="original" lang="en" xml:lang="en">In cases above which do not require reading the encoding declaration to determine the encoding, section 4.3.3 still requires that the encoding declaration, if present, be read and that the encoding name be checked to match the actual encoding of the entity. Also, it is possible that new character encodings will be invented that will make it necessary to use the encoding declaration to determine the encoding, in cases where this is not required at present.</p>
</div>
<p>この段階まで自動検知を行えば、XMLエンコーディング宣言を読み取って文字エンコーディング識別子を解析するのには十分である。但し、エンコーディングファミリのメンバは区別する必要がある(例えば、UTF-8、8859、そして8859のパートをそれぞれ区別しなければならないし、使われているEBCDICコードページを知らなければならない。他の場合でも同様である)。</p>
<p class="original" lang="en" xml:lang="en">This level of autodetection is enough to read the XML encoding declaration and parse the character-encoding identifier, which is still necessary to distinguish the individual members of each family of encodings (e.g. to tell UTF-8 from 8859, and the parts of 8859 from each other, or to distinguish the specific EBCDIC code page in use, and so on).</p>
<p>エンコーディング宣言の内容は、エンコードされてはいるもののASCIIレパートリーの文字に制限されている為、プロセッサは、どのエンコーディングファミリが使われているかを検知次第、エンコーディング宣言全体を信頼を持って読み取る事ができる。実際には、広く使われている文字エンコーディングはすべて上に挙げられたカテゴリの中の一つに当てはまる為、たとえオペレーティングシステムレベルあるいは転送プロトコルレベルの外部情報源が信頼できない時でも、XMLエンコーディング宣言は文字エンコーディングの信頼に値するインバンドラベリングを合理的に可能にする。UTF-7などの、ASCII値のバイトをオーバーロードして使う文字エンコーディングは、信頼を持って検知できない事がある。</p>
<p class="original" lang="en" xml:lang="en">Because the contents of the encoding declaration are restricted to characters from the ASCII repertoire (however encoded), a processor can reliably read the entire encoding declaration as soon as it has detected which family of encodings is in use. Since in practice, all widely used character encodings fall into one of the categories above, the XML encoding declaration allows reasonably reliable in-band labeling of character encodings, even when external sources of information at the operating-system or transport-protocol level are unreliable. Character encodings such as UTF-7 that make overloaded usage of ASCII-valued bytes may fail to be reliably detected.</p>
<div class="annotation">
	<p class="context-flow">[訳者註開始]</p>
	<p class="prefix"><em>訳者註</em></p>
	<p>インバンド(In-Band)に、とは、ここでは「外部の情報源を用いる事無く、XML文書が含まれるストリームの中で」といった意味合いです。この翻訳版の以前の訳者註では、意味を取り違えていました。</p>
	<p class="context-flow">[訳者註終了]</p>
</div>
<p>プロセッサは、使われている文字エンコーディングを検知し終わったら、その後を適切に処理する事ができる。文字エンコーディングによってそれぞれ別の入力ルーチンを呼び出したり、入力から送られるそれぞれの文字について適切な変換関数を呼んだりできる。</p>
<p class="original" lang="en" xml:lang="en">Once the processor has detected the character encoding in use, it can act appropriately, whether by invoking a separate input routine for each case, or by calling the proper conversion function on each character of input.</p>
<p>何らかのソフトウェアが、実体の文字セットやエンコーディングをエンコーディング宣言を更新しないまま変更してしまった場合、他のセルフラベリングシステムと同様、XMLエンコーディング宣言はうまく機能しない。文字エンコーディングルーチンの実装者は、実体をラベルする為に使われる内部及び外部情報の正確性を保つよう注意を払うべきである。</p>
<p class="original" lang="en" xml:lang="en">Like any self-labeling system, the XML encoding declaration will not work if any software changes the entity's character set or encoding without updating the encoding declaration. Implementors of character-encoding routines should be careful to ensure the accuracy of the internal and external information used to label the entity.</p>
</div>

<div class="div2">
<h3><a name="sec-guessing-with-ext-info" id="sec-guessing-with-ext-info"></a>E.2 外部エンコーディング情報が存在する時の優先度<span class="original" lang="en" xml:lang="en"> Priorities in the Presence of External Encoding Information</span></h3>
<p>もう一つのケースは、特定のファイルシステムや特定のネットワークプロトコルで、XML実体がエンコーディング情報と共に与えられた時に起こる。幾つかの情報源が利用可能である時、それらの相対的な優先度や衝突を扱う望ましい方法などは、XMLを伝達する為に使われるより上層のプロトコルの一部として指定される事が望ましい。特に、<a href="#rfc2376">[IETF RFC 3023]</a>、あるいはその後継文書を参照してほしい。この文書は<code>text/xml</code>と<code>application/xml</code>の二つのMIMEタイプを定義し、便利な案内も提供する。しかし、相互運用性に配慮して、次の規則に従う事をお勧めする。</p>
<p class="original" lang="en" xml:lang="en">The second possible case occurs when the XML entity is accompanied by encoding information, as in some file systems and some network protocols. When multiple sources of information are available, their relative priority and the preferred method of handling conflict should be specified as part of the higher-level protocol used to deliver XML. In particular, please refer to <a href="#rfc2376">[IETF RFC 3023]</a> or its successor, which defines the <code>text/xml</code> and <code>application/xml</code> MIME types and provides some useful guidance. In the interests of interoperability, however, the following rule is recommended.</p>
<ul>
	<li>
		<p>XML実体がファイルに収められている場合、バイトオーダーマークやエンコーディング宣言があるならば、それらが文字エンコーディングを決定する為に使われる。</p>
		<p class="original" lang="en" xml:lang="en">If an XML entity is in a file, the Byte-Order Mark and encoding declaration are used (if present) to determine the character encoding.</p>
	</li>
</ul>
</div>
</div>

<div class="div1">
<h2><a name="sec-xml-wg" id="sec-xml-wg"></a>F W3C XML Working Group(非規範的)<span class="original" lang="en" xml:lang="en"> W3C XML Working Group (Non-Normative)</span></h2>
<p>この仕様書は、W3C XML Working Group (WG)によって準備され、公開を承認された。この仕様書のWGによる承認は、必ずしもすべてのWG参加者が承認投票を行った事を意味するものではない。XML WGの現在のメンバと過去に参加していたメンバは次の通り。</p>
<p class="original" lang="en" xml:lang="en">This specification was prepared and approved for publication by the W3C XML Working Group (WG). WG approval of this specification does not necessarily imply that all WG participants voted for its approval. The current and former members in the XML WG are:</p>
<ul lang="en" xml:lang="en">
	<li>Jon Bosak, Sun (<i>Chair</i>)</li>
	<li>James Clark (<i>Technical Lead</i>)</li>
	<li>Tim Bray, Textuality and Netscape (<i>XML Co-editor</i>)</li>
	<li>Jean Paoli, Microsoft (<i>XML Co-editor</i>)</li>
	<li>C. M. Sperberg-McQueen, U. of Ill. (<i>XML Co-editor</i>)</li>
	<li>Dan Connolly, W3C (<i>W3C Liaison</i>)</li>
	<li>Paula Angerstein, Texcel</li>
	<li>Steve DeRose, INSO</li>
	<li>Dave Hollander, HP</li>
	<li>Eliot Kimber, ISOGEN</li>
	<li>Eve Maler, ArborText</li>
	<li>Tom Magliery, NCSA</li>
	<li>Murray Maloney, SoftQuad, Grif SA, Muzmo and Veo Systems</li>
	<li>MURATA Makoto (FAMILY Given), Fuji Xerox Information Systems</li>
	<li>Joel Nava, Adobe</li>
	<li>Conleth O'Connell, Vignette</li>
	<li>Peter Sharpe, SoftQuad</li>
	<li>John Tigue, DataChannel</li>
</ul>
</div>

<div class="div1">
<h2><a name="sec-core-wg" id="sec-core-wg"></a>G W3C XML Core Working Group(非規範的)<span class="original" lang="en" xml:lang="en"> W3C XML Core Working Group (Non-Normative)</span></h2>
<p>この仕様書の第二版は、W3C XML Core Working Group (WG)によって準備された。この版の公開時のXML Core WGの参加者は次の通り。</p>
<p class="original" lang="en" xml:lang="en">The second edition of this specification was prepared by the W3C XML Core Working Group (WG). The participants in the WG at the time of publication of this edition were:</p>
<ul lang="en" xml:lang="en">
	<li>Leonid Arbouzov, Sun Microsystems</li>
	<li>John Cowan</li>
	<li>Andrew Fang, PTC-Arbortext</li>
	<li>Paul Grosso, PTC-Arbortext (<i>Co-Chair</i>)</li>
	<li>Konrad Lanz, A-SIT</li>
	<li>Philippe Le Hégaret, W3C (<i>Staff Contact</i>)</li>
	<li>Glenn Marcy, IBM</li>
	<li>Sandra Martinez, NIST</li>
	<li>Ravindrakumar R, CDAC</li>
	<li>Lew Shannon</li>
	<li>Henry Thompson, W3C (<i>Staff Contact</i>)</li>
	<li>Richard Tobin, University of Edinburgh</li>
	<li>Daniel Veillard</li>
	<li>Norman Walsh, Sun Microsystems (<i>Co-Chair</i>)</li>
	<li>François Yergeau</li>
</ul>
</div>

<div class="div1">
<h2><a name="prod-notes" id="prod-notes"></a>H 生成メモ(非規範的)<span class="original" lang="en" xml:lang="en"> Production Notes (Non-Normative)</span></h2>
<p>この版は、<a href="http://www.w3.org/2002/xmlspec/dtd/2.10/xmlspec.dtd">XMLspec DTD, 2.10</a>に少し手を加えたバージョンのDTDでエンコードされた。XHTMLバージョンは、<a href="http://www.w3.org/2002/xmlspec/xhtml/1.13/xmlspec.xsl">xmlspec.xsl</a>、<a href="http://www.w3.org/2002/xmlspec/xhtml/1.13/diffspec.xsl">diffspec.xsl</a>、<a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml.xsl">REC-xml.xsl</a>の三つのXSLTスタイルシートを組み合わせて生成された。</p>
<p class="original" lang="en" xml:lang="en">This edition was encoded in a slightly modified version of the <a href="http://www.w3.org/2002/xmlspec/dtd/2.10/xmlspec.dtd">XMLspec DTD, 2.10</a>. The XHTML versions were produced with a combination of the <a href="http://www.w3.org/2002/xmlspec/xhtml/1.13/xmlspec.xsl">xmlspec.xsl</a>, <a href="http://www.w3.org/2002/xmlspec/xhtml/1.13/diffspec.xsl">diffspec.xsl</a>, and <a href="http://www.w3.org/TR/2006/REC-xml11-20060816/REC-xml.xsl">REC-xml.xsl</a> XSLT stylesheets.</p>
</div>

<div class="div1">
<h2><a name="sec-suggested-names" id="sec-suggested-names"></a>I XML名前の為の提案(非規範的)<span class="original" lang="en" xml:lang="en"> Suggestions for XML Names (Non-Normative)</span></h2>
<p>次に挙げる提案は、要素名、属性名、処理命令対象、実体名、記法名、型IDの属性の値として使われるXML名前を構築する上で、最も良い方法だと考えられるものを明文化したものである。これらは、文書の著者やスキーマの設計者の為の案内となるよう意図されている。Unicodeへの参照は、Unicode Standardのバージョン3.0か、それより大きいバージョンを持つそれを指す。それらの内のどのバージョンが使われるかについては、文書の著者やスキーマの設計者の裁量に委ねられる。</p>
<p class="original" lang="en" xml:lang="en">The following suggestions define what is believed to be best practice in the construction of XML names used as element names, attribute names, processing instruction targets, entity names, notation names, and the values of attributes of type ID, and are intended as guidance for document authors and schema designers. All references to Unicode are understood with respect to a particular version of the Unicode Standard greater than or equal to 3.0; which version should be used is left to the discretion of the document author or schema designer.</p>
<p>最初の二つの提案は、Unicode Standardバージョン3.0)の識別子に適用される規則に直接由来する。これらは、すべての制御文字、空白を取らない内包マーク、非10進数字、プライベート利用文字、(例外はあるが)句読点、シンボル文字、未割り当てコード点、そしてホワイトスペース文字を除外するものである。その他の提案は、殆どが<a href="#XML1.0">[XML-1.0]</a>の附録Bに由来するものである。</p>
<p class="original" lang="en" xml:lang="en">The first two suggestions are directly derived from the rules given for identifiers in the Unicode Standard, version 3.0, and exclude all control characters, enclosing nonspacing marks, non-decimal numbers, private-use characters, punctuation characters (with the noted exceptions), symbol characters, unassigned codepoints, and white space characters. The other suggestions are mostly derived from <a href="#XML1.0">[XML-1.0]</a> Appendix B.</p>
<ol class="enumar">
	<li>
		<p>すべての名前において、最初の文字は、Unicode General CategoryのLl、Lu、Lo、Lm、Lt、Nlの何れかに分類される文字か、そうでなければ'_'(#x5F)である事が望ましい。</p>
		<p class="original" lang="en" xml:lang="en">The first character of any name should have a Unicode General Category of Ll, Lu, Lo, Lm, Lt, or Nl, or else be '_' #x5F.</p>
	</li>
	<li>
		<p>最初の文字以外の文字は、Unicode General CategoryのLl、Lu、Lo、Lm、Lt、Mc、Mn、Nl、Nd、Pc、Cfの何れかに分類される文字か、そうでなければ'-'(#x2D)、'.'(#x2E)、':'(#x3A)、'·'(#xB7、ミドルドット)である事が望ましい。但し、Cfの文字は直接目にする事はできないので、人間の目には同じに見えてもXMLプロセッサにとっては全く異なる名前を作ってしまう事がある。これを避ける為、Cfの文字は、どうしても必要な時にだけ注意を払いながら使うべきである。</p>
		<p class="original" lang="en" xml:lang="en">Characters other than the first should have a Unicode General Category of Ll, Lu, Lo, Lm, Lt, Mc, Mn, Nl, Nd, Pc, or Cf, or else be one of the following: '-' #x2D, '.' #x2E, ':' #x3A or '·' #xB7 (middle dot). Since Cf characters are not directly visible, they should be employed with caution and only when necessary, to avoid creating names which are distinct to XML processors but look the same to human beings.</p>
	</li>
	<li>
		<p>極限分解文字列を持つ表意文字([#xF900-#xFAFF]と[#x2F800-#x2FFFD]の範囲の文字を含むが、12個の例外がある)は、名前に使わない方が良い。</p>
		<p class="original" lang="en" xml:lang="en">Ideographic characters which have a canonical decomposition (including those in the ranges [#xF900-#xFAFF] and [#x2F800-#x2FFFD], with 12 exceptions) should not be used in names.</p>
	</li>
	<li>
		<p>互換性分解文字列を持つ文字(Unicode Character Databaseの5番目のフィールドに「互換性フォーマッティングタグ」を持つもの。このタグを持つ文字は、5番目のフィールドが"&lt;"で始まる)は、名前に使わない方が良い。この提案は、#x0E33(THAI CHARACTER SARA AM)や#x0EB3(LAO CHARACTER AM)には当てはまらない。それらは、互換性分解文字列を持つけれども、その言語の文章で普通に使われる。</p>
		<p class="original" lang="en" xml:lang="en">Characters which have a compatibility decomposition (those with a "compatibility formatting tag" in field 5 of the Unicode Character Database -- marked by field 5 beginning with a "&lt;") should not be used in names. This suggestion does not apply to #x0E33 THAI CHARACTER SARA AM or #x0EB3 LAO CHARACTER AM, which despite their compatibility decompositions are in regular use in those scripts.</p>
	</li>
	<li>
		<p>シンボルのみに付く為の結合文字([#x20D0-#x20EF]と[#x1D165-#x1D1AD]の範囲の文字を含む)は、名前に使わない方が良い。</p>
		<p class="original" lang="en" xml:lang="en">Combining characters meant for use with symbols only (including those in the ranges [#x20D0-#x20EF] and [#x1D165-#x1D1AD]) should not be used in names.</p>
	</li>
	<li>
		<p>行をまたぐ註釈文字(ルビ、即ち振り仮名の範囲指示用。[#xFFF9-#xFFFB])は、名前に使わない方が良い。</p>
		<p class="original" lang="en" xml:lang="en">The interlinear annotation characters ([#xFFF9-#xFFFB]) should not be used in names.</p>
	</li>
	<li>
		<p>バリエーションセレクタ文字は、名前に使わない方が良い。</p>
		<p class="original" lang="en" xml:lang="en">Variation selector characters should not be used in names.</p>
	</li>
	<li>
		<p>無意味な名前、発音できない名前、読みづらい名前、他の名前と間違えやすい名前は、使わない方が良い。</p>
		<p class="original" lang="en" xml:lang="en">Names which are nonsensical, unpronounceable, hard to read, or easily confusable with other names should not be employed.</p>
	</li>
</ol>
</div>
</div>

</body>

</html>
